      !!# INTERFACE MODULE: <INT_LAPACK2>
      MODULE INT_LAPACK2

      !!## PURPOSE
      !! Provies a level-2 interface to the LAPACK library.

      INTERFACE LA_LAMCH
       MODULE PROCEDURE SLAMCH_F95
       MODULE PROCEDURE DLAMCH_F95
      END INTERFACE

      INTERFACE LA_GGSVD
       MODULE PROCEDURE SGGSVD_F95
       MODULE PROCEDURE DGGSVD_F95
       MODULE PROCEDURE CGGSVD_F95
       MODULE PROCEDURE ZGGSVD_F95
      END INTERFACE

      INTERFACE LA_GEGV
       MODULE PROCEDURE SGEGV_F95
       MODULE PROCEDURE DGEGV_F95
       MODULE PROCEDURE CGEGV_F95
       MODULE PROCEDURE ZGEGV_F95
      END INTERFACE

      INTERFACE LA_GEGS
       MODULE PROCEDURE SGEGS_F95
       MODULE PROCEDURE DGEGS_F95
       MODULE PROCEDURE CGEGS_F95
       MODULE PROCEDURE ZGEGS_F95
      END INTERFACE

      INTERFACE LA_SBGVX
       MODULE PROCEDURE SSBGVX_F95
       MODULE PROCEDURE DSBGVX_F95
      END INTERFACE

      INTERFACE LA_HBGVX
       MODULE PROCEDURE CHBGVX_F95
       MODULE PROCEDURE ZHBGVX_F95
      END INTERFACE

      INTERFACE LA_SBGVD
       MODULE PROCEDURE SSBGVD_F95
       MODULE PROCEDURE DSBGVD_F95
      END INTERFACE

      INTERFACE LA_HBGVD
           MODULE PROCEDURE CHBGVD_F95
       MODULE PROCEDURE ZHBGVD_F95
      END INTERFACE

      INTERFACE LA_SBGV
       MODULE PROCEDURE SSBGV_F95
       MODULE PROCEDURE DSBGV_F95
      END INTERFACE

      INTERFACE LA_HBGV
       MODULE PROCEDURE CHBGV_F95
       MODULE PROCEDURE ZHBGV_F95
      END INTERFACE

      INTERFACE LA_SPGVX
       MODULE PROCEDURE SSPGVX_F95
       MODULE PROCEDURE DSPGVX_F95
      END INTERFACE

      INTERFACE LA_HPGVX
           MODULE PROCEDURE CHPGVX_F95
           MODULE PROCEDURE ZHPGVX_F95
      END INTERFACE

      INTERFACE LA_SPGVD
       MODULE PROCEDURE SSPGVD_F95
       MODULE PROCEDURE DSPGVD_F95
      END INTERFACE

      INTERFACE LA_HPGVD
       MODULE PROCEDURE CHPGVD_F95
       MODULE PROCEDURE ZHPGVD_F95
      END INTERFACE

      INTERFACE LA_SPGV
       MODULE PROCEDURE SSPGV_F95
       MODULE PROCEDURE DSPGV_F95
      END INTERFACE

      INTERFACE LA_HPGV
       MODULE PROCEDURE CHPGV_F95
       MODULE PROCEDURE ZHPGV_F95
      END INTERFACE

      INTERFACE LA_GESVD
       MODULE PROCEDURE SGESVD_F95
       MODULE PROCEDURE DGESVD_F95
       MODULE PROCEDURE CGESVD_F95
       MODULE PROCEDURE ZGESVD_F95
      END INTERFACE

      INTERFACE LA_GEEVX
       MODULE PROCEDURE SGEEVX_F95
       MODULE PROCEDURE DGEEVX_F95
       MODULE PROCEDURE CGEEVX_F95
       MODULE PROCEDURE ZGEEVX_F95
      END INTERFACE

      INTERFACE LA_GGEVX
       MODULE PROCEDURE SGGEVX_F95
       MODULE PROCEDURE DGGEVX_F95
       MODULE PROCEDURE CGGEVX_F95
       MODULE PROCEDURE ZGGEVX_F95
      END INTERFACE

      INTERFACE LA_GGEV
       MODULE PROCEDURE SGGEV_F95
       MODULE PROCEDURE DGGEV_F95
       MODULE PROCEDURE CGGEV_F95
       MODULE PROCEDURE ZGGEV_F95
      END INTERFACE

      INTERFACE LA_GEEV
       MODULE PROCEDURE SGEEV_F95
       MODULE PROCEDURE DGEEV_F95
       MODULE PROCEDURE CGEEV_F95
       MODULE PROCEDURE ZGEEV_F95
      END INTERFACE

      INTERFACE LA_GEESX
       MODULE PROCEDURE SGEESX_F95
       MODULE PROCEDURE DGEESX_F95
       MODULE PROCEDURE CGEESX_F95
       MODULE PROCEDURE ZGEESX_F95
      END INTERFACE

      INTERFACE LA_GGESX
       MODULE PROCEDURE SGGESX_F95
       MODULE PROCEDURE DGGESX_F95
       MODULE PROCEDURE CGGESX_F95
       MODULE PROCEDURE ZGGESX_F95
      END INTERFACE


      INTERFACE LA_GGES
       MODULE PROCEDURE SGGES_F95
       MODULE PROCEDURE DGGES_F95
       MODULE PROCEDURE CGGES_F95
       MODULE PROCEDURE ZGGES_F95
      END INTERFACE

      INTERFACE LA_GEES
       MODULE PROCEDURE SGEES_F95
       MODULE PROCEDURE DGEES_F95
       MODULE PROCEDURE CGEES_F95
       MODULE PROCEDURE ZGEES_F95
      END INTERFACE

      INTERFACE LA_STEVR
       MODULE PROCEDURE SSTEVR_F95
       MODULE PROCEDURE DSTEVR_F95
      END INTERFACE

      INTERFACE LA_STEVX
       MODULE PROCEDURE SSTEVX_F95
       MODULE PROCEDURE DSTEVX_F95
      END INTERFACE

      INTERFACE LA_STEVD
       MODULE PROCEDURE SSTEVD_F95
       MODULE PROCEDURE DSTEVD_F95
      END INTERFACE

      INTERFACE LA_STEV
       MODULE PROCEDURE SSTEV_F95
       MODULE PROCEDURE DSTEV_F95
      END INTERFACE

      INTERFACE LA_SBEVX
       MODULE PROCEDURE SSBEVX_F95
       MODULE PROCEDURE DSBEVX_F95
      END INTERFACE

      INTERFACE LA_HBEVX
       MODULE PROCEDURE CHBEVX_F95
       MODULE PROCEDURE ZHBEVX_F95
      END INTERFACE

      INTERFACE LA_SBEVD
       MODULE PROCEDURE SSBEVD_F95
       MODULE PROCEDURE DSBEVD_F95
      END INTERFACE

      INTERFACE LA_HBEVD
       MODULE PROCEDURE CHBEVD_F95
       MODULE PROCEDURE ZHBEVD_F95
      END INTERFACE

      INTERFACE LA_SBEV
       MODULE PROCEDURE SSBEV_F95
       MODULE PROCEDURE DSBEV_F95
      END INTERFACE

      INTERFACE LA_HBEV
       MODULE PROCEDURE CHBEV_F95
       MODULE PROCEDURE ZHBEV_F95
      END INTERFACE

      INTERFACE LA_SPEVX
       MODULE PROCEDURE SSPEVX_F95
       MODULE PROCEDURE DSPEVX_F95
      END INTERFACE

      INTERFACE LA_HPEVX
       MODULE PROCEDURE CHPEVX_F95
       MODULE PROCEDURE ZHPEVX_F95
      END INTERFACE

      INTERFACE LA_SPEVD
       MODULE PROCEDURE SSPEVD_F95
       MODULE PROCEDURE DSPEVD_F95
      END INTERFACE

      INTERFACE LA_HPEVD
       MODULE PROCEDURE CHPEVD_F95
       MODULE PROCEDURE ZHPEVD_F95
      END INTERFACE

      INTERFACE LA_SPEV
       MODULE PROCEDURE SSPEV_F95
       MODULE PROCEDURE DSPEV_F95
      END INTERFACE

      INTERFACE LA_HPEV
       MODULE PROCEDURE CHPEV_F95
       MODULE PROCEDURE ZHPEV_F95
      END INTERFACE

      INTERFACE LA_GGGLM
       MODULE PROCEDURE SGGGLM_F95
       MODULE PROCEDURE DGGGLM_F95
       MODULE PROCEDURE CGGGLM_F95
       MODULE PROCEDURE ZGGGLM_F95
      END INTERFACE

      INTERFACE LA_GGLSE
       MODULE PROCEDURE SGGLSE_F95
       MODULE PROCEDURE DGGLSE_F95
       MODULE PROCEDURE CGGLSE_F95
       MODULE PROCEDURE ZGGLSE_F95
      END INTERFACE

      INTERFACE LA_GELSY
       MODULE PROCEDURE SGELSY_F95
       MODULE PROCEDURE SGELSY1_F95
       MODULE PROCEDURE DGELSY_F95
       MODULE PROCEDURE DGELSY1_F95
       MODULE PROCEDURE CGELSY_F95
       MODULE PROCEDURE CGELSY1_F95
       MODULE PROCEDURE ZGELSY_F95
       MODULE PROCEDURE ZGELSY1_F95
      END INTERFACE

      INTERFACE LA_GELSD
       MODULE PROCEDURE SGELSD_F95
       MODULE PROCEDURE SGELSD1_F95
       MODULE PROCEDURE DGELSD_F95
       MODULE PROCEDURE DGELSD1_F95
       MODULE PROCEDURE CGELSD_F95
       MODULE PROCEDURE CGELSD1_F95
       MODULE PROCEDURE ZGELSD_F95
       MODULE PROCEDURE ZGELSD1_F95
      END INTERFACE

      INTERFACE LA_GELSX
       MODULE PROCEDURE SGELSX_F95
       MODULE PROCEDURE SGELSX1_F95
       MODULE PROCEDURE DGELSX_F95
       MODULE PROCEDURE DGELSX1_F95
       MODULE PROCEDURE CGELSX_F95
       MODULE PROCEDURE CGELSX1_F95
       MODULE PROCEDURE ZGELSX_F95
       MODULE PROCEDURE ZGELSX1_F95
      END INTERFACE

      INTERFACE LA_GELSS
       MODULE PROCEDURE SGELSS_F95
       MODULE PROCEDURE SGELSS1_F95

       MODULE PROCEDURE DGELSS_F95
       MODULE PROCEDURE DGELSS1_F95
       MODULE PROCEDURE CGELSS_F95
       MODULE PROCEDURE CGELSS1_F95
       MODULE PROCEDURE ZGELSS_F95
       MODULE PROCEDURE ZGELSS1_F95
      END INTERFACE

      INTERFACE LA_GELS
       MODULE PROCEDURE SGELS_F95
       MODULE PROCEDURE SGELS1_F95
       MODULE PROCEDURE DGELS_F95
       MODULE PROCEDURE DGELS1_F95
       MODULE PROCEDURE CGELS_F95
       MODULE PROCEDURE CGELS1_F95
       MODULE PROCEDURE ZGELS_F95
       MODULE PROCEDURE ZGELS1_F95
      END INTERFACE

      INTERFACE LA_SPSVX
       MODULE PROCEDURE SSPSVX_F95
       MODULE PROCEDURE SSPSVX1_F95
       MODULE PROCEDURE DSPSVX_F95
       MODULE PROCEDURE DSPSVX1_F95
       MODULE PROCEDURE CSPSVX_F95
       MODULE PROCEDURE CSPSVX1_F95
       MODULE PROCEDURE ZSPSVX_F95
       MODULE PROCEDURE ZSPSVX1_F95
      END INTERFACE

      INTERFACE LA_HPSVX
       MODULE PROCEDURE CHPSVX_F95
       MODULE PROCEDURE CHPSVX1_F95
       MODULE PROCEDURE ZHPSVX_F95
       MODULE PROCEDURE ZHPSVX1_F95
      END INTERFACE

      INTERFACE LA_SYSVX
       MODULE PROCEDURE SSYSVX_F95
       MODULE PROCEDURE SSYSVX1_F95
       MODULE PROCEDURE DSYSVX_F95
       MODULE PROCEDURE DSYSVX1_F95
       MODULE PROCEDURE CSYSVX_F95
       MODULE PROCEDURE CSYSVX1_F95
       MODULE PROCEDURE ZSYSVX_F95
       MODULE PROCEDURE ZSYSVX1_F95
      END INTERFACE

      INTERFACE LA_HESVX
       MODULE PROCEDURE CHESVX_F95
       MODULE PROCEDURE CHESVX1_F95
       MODULE PROCEDURE ZHESVX_F95
       MODULE PROCEDURE ZHESVX1_F95
      END INTERFACE

      INTERFACE LA_PTSVX
       MODULE PROCEDURE SPTSVX_F95
       MODULE PROCEDURE SPTSVX1_F95
       MODULE PROCEDURE DPTSVX_F95
       MODULE PROCEDURE DPTSVX1_F95
       MODULE PROCEDURE CPTSVX_F95
       MODULE PROCEDURE CPTSVX1_F95
       MODULE PROCEDURE ZPTSVX_F95
       MODULE PROCEDURE ZPTSVX1_F95
      END INTERFACE

      INTERFACE LA_PBSVX
       MODULE PROCEDURE SPBSVX_F95
       MODULE PROCEDURE SPBSVX1_F95
       MODULE PROCEDURE DPBSVX_F95
       MODULE PROCEDURE DPBSVX1_F95
       MODULE PROCEDURE CPBSVX_F95
       MODULE PROCEDURE CPBSVX1_F95
       MODULE PROCEDURE ZPBSVX_F95
       MODULE PROCEDURE ZPBSVX1_F95
      END INTERFACE

      INTERFACE LA_PPSVX
       MODULE PROCEDURE SPPSVX_F95
       MODULE PROCEDURE SPPSVX1_F95
       MODULE PROCEDURE DPPSVX_F95
       MODULE PROCEDURE DPPSVX1_F95
       MODULE PROCEDURE CPPSVX_F95
       MODULE PROCEDURE CPPSVX1_F95
       MODULE PROCEDURE ZPPSVX_F95
       MODULE PROCEDURE ZPPSVX1_F95
      END INTERFACE

      INTERFACE LA_POSVX
       MODULE PROCEDURE SPOSVX_F95
       MODULE PROCEDURE SPOSVX1_F95
       MODULE PROCEDURE DPOSVX_F95
       MODULE PROCEDURE DPOSVX1_F95
       MODULE PROCEDURE CPOSVX_F95
       MODULE PROCEDURE CPOSVX1_F95
       MODULE PROCEDURE ZPOSVX_F95
       MODULE PROCEDURE ZPOSVX1_F95
      END INTERFACE

      INTERFACE LA_GTSVX
       MODULE PROCEDURE SGTSVX_F95
       MODULE PROCEDURE SGTSVX1_F95
       MODULE PROCEDURE DGTSVX_F95
       MODULE PROCEDURE DGTSVX1_F95
       MODULE PROCEDURE CGTSVX_F95
       MODULE PROCEDURE CGTSVX1_F95
       MODULE PROCEDURE ZGTSVX_F95
       MODULE PROCEDURE ZGTSVX1_F95
      END INTERFACE

      INTERFACE LA_GBSVX
       MODULE PROCEDURE SGBSVX_F95
       MODULE PROCEDURE SGBSVX1_F95
       MODULE PROCEDURE DGBSVX_F95
       MODULE PROCEDURE DGBSVX1_F95
       MODULE PROCEDURE CGBSVX_F95
       MODULE PROCEDURE CGBSVX1_F95
       MODULE PROCEDURE ZGBSVX_F95
       MODULE PROCEDURE ZGBSVX1_F95
      END INTERFACE

      INTERFACE LA_SPSV
       MODULE PROCEDURE SSPSV_F95
       MODULE PROCEDURE SSPSV1_F95
       MODULE PROCEDURE DSPSV_F95
       MODULE PROCEDURE DSPSV1_F95
       MODULE PROCEDURE CSPSV_F95
       MODULE PROCEDURE CSPSV1_F95
       MODULE PROCEDURE ZSPSV_F95
       MODULE PROCEDURE ZSPSV1_F95
      END INTERFACE

      INTERFACE LA_HPSV
       MODULE PROCEDURE CHPSV_F95
       MODULE PROCEDURE CHPSV1_F95
       MODULE PROCEDURE ZHPSV_F95
       MODULE PROCEDURE ZHPSV1_F95
      END INTERFACE

      INTERFACE LA_SYSV
       MODULE PROCEDURE SSYSV_F95
       MODULE PROCEDURE SSYSV1_F95
       MODULE PROCEDURE DSYSV_F95
       MODULE PROCEDURE DSYSV1_F95
       MODULE PROCEDURE CSYSV_F95
       MODULE PROCEDURE CSYSV1_F95
       MODULE PROCEDURE ZSYSV_F95
       MODULE PROCEDURE ZSYSV1_F95
      END INTERFACE

      INTERFACE LA_HESV
       MODULE PROCEDURE CHESV_F95
       MODULE PROCEDURE CHESV1_F95
       MODULE PROCEDURE ZHESV_F95
       MODULE PROCEDURE ZHESV1_F95
      END INTERFACE

      INTERFACE LA_PTSV
       MODULE PROCEDURE SPTSV_F95
       MODULE PROCEDURE SPTSV1_F95
       MODULE PROCEDURE DPTSV_F95
       MODULE PROCEDURE DPTSV1_F95
       MODULE PROCEDURE CPTSV_F95
       MODULE PROCEDURE CPTSV1_F95
       MODULE PROCEDURE ZPTSV_F95
       MODULE PROCEDURE ZPTSV1_F95
      END INTERFACE

      INTERFACE LA_PBSV
       MODULE PROCEDURE SPBSV_F95
       MODULE PROCEDURE SPBSV1_F95
       MODULE PROCEDURE DPBSV_F95
       MODULE PROCEDURE DPBSV1_F95
       MODULE PROCEDURE CPBSV_F95
       MODULE PROCEDURE CPBSV1_F95
       MODULE PROCEDURE ZPBSV_F95
       MODULE PROCEDURE ZPBSV1_F95
      END INTERFACE

      INTERFACE LA_PPSV
       MODULE PROCEDURE SPPSV_F95
       MODULE PROCEDURE SPPSV1_F95
       MODULE PROCEDURE DPPSV_F95
       MODULE PROCEDURE DPPSV1_F95
       MODULE PROCEDURE CPPSV_F95
       MODULE PROCEDURE CPPSV1_F95
       MODULE PROCEDURE ZPPSV_F95
       MODULE PROCEDURE ZPPSV1_F95
      END INTERFACE

      INTERFACE LA_POSV
       MODULE PROCEDURE SPOSV_F95
       MODULE PROCEDURE SPOSV1_F95
       MODULE PROCEDURE DPOSV_F95
       MODULE PROCEDURE DPOSV1_F95
       MODULE PROCEDURE CPOSV_F95
       MODULE PROCEDURE CPOSV1_F95
       MODULE PROCEDURE ZPOSV_F95
       MODULE PROCEDURE ZPOSV1_F95
      END INTERFACE

      INTERFACE LA_GTSV
       MODULE PROCEDURE SGTSV_F95
       MODULE PROCEDURE SGTSV1_F95
       MODULE PROCEDURE DGTSV_F95
       MODULE PROCEDURE DGTSV1_F95
       MODULE PROCEDURE CGTSV_F95
       MODULE PROCEDURE CGTSV1_F95
       MODULE PROCEDURE ZGTSV_F95
       MODULE PROCEDURE ZGTSV1_F95
      END INTERFACE

      INTERFACE LA_GBSV
       MODULE PROCEDURE SGBSV_F95
       MODULE PROCEDURE SGBSV1_F95
       MODULE PROCEDURE DGBSV_F95
       MODULE PROCEDURE DGBSV1_F95
       MODULE PROCEDURE CGBSV_F95
       MODULE PROCEDURE CGBSV1_F95
       MODULE PROCEDURE ZGBSV_F95
       MODULE PROCEDURE ZGBSV1_F95
      END INTERFACE

      INTERFACE LA_GESV
       MODULE PROCEDURE SGESV_F95
       MODULE PROCEDURE SGESV1_F95
       MODULE PROCEDURE DGESV_F95
       MODULE PROCEDURE DGESV1_F95
       MODULE PROCEDURE CGESV_F95
       MODULE PROCEDURE CGESV1_F95
       MODULE PROCEDURE ZGESV_F95
       MODULE PROCEDURE ZGESV1_F95
      END INTERFACE

      INTERFACE LA_GESVX
       MODULE PROCEDURE SGESVX_F95
       MODULE PROCEDURE SGESVX1_F95
       MODULE PROCEDURE DGESVX_F95
       MODULE PROCEDURE DGESVX1_F95
       MODULE PROCEDURE CGESVX_F95
       MODULE PROCEDURE CGESVX1_F95
       MODULE PROCEDURE ZGESVX_F95
       MODULE PROCEDURE ZGESVX1_F95
      END INTERFACE

      INTERFACE LA_GETRF
       MODULE PROCEDURE SGETRF_F95
       MODULE PROCEDURE DGETRF_F95
       MODULE PROCEDURE CGETRF_F95
       MODULE PROCEDURE ZGETRF_F95
      END INTERFACE

      INTERFACE LA_GETRS
       MODULE PROCEDURE SGETRS_F95
       MODULE PROCEDURE SGETRS1_F95
       MODULE PROCEDURE DGETRS_F95
       MODULE PROCEDURE DGETRS1_F95
       MODULE PROCEDURE CGETRS_F95
       MODULE PROCEDURE CGETRS1_F95
       MODULE PROCEDURE ZGETRS_F95
       MODULE PROCEDURE ZGETRS1_F95
      END INTERFACE

      INTERFACE LA_GETRI
       MODULE PROCEDURE SGETRI_F95
       MODULE PROCEDURE DGETRI_F95
       MODULE PROCEDURE CGETRI_F95
       MODULE PROCEDURE ZGETRI_F95
      END INTERFACE

      INTERFACE LA_GERFS
       MODULE PROCEDURE SGERFS_F95
       MODULE PROCEDURE SGERFS1_F95
       MODULE PROCEDURE DGERFS_F95
       MODULE PROCEDURE DGERFS1_F95
       MODULE PROCEDURE CGERFS_F95
       MODULE PROCEDURE CGERFS1_F95
       MODULE PROCEDURE ZGERFS_F95
       MODULE PROCEDURE ZGERFS1_F95
      END INTERFACE

      INTERFACE LA_GEEQU
       MODULE PROCEDURE SGEEQU_F95
       MODULE PROCEDURE DGEEQU_F95
       MODULE PROCEDURE CGEEQU_F95
       MODULE PROCEDURE ZGEEQU_F95
      END INTERFACE

      INTERFACE LA_SYEV
       MODULE PROCEDURE SSYEV_F95
       MODULE PROCEDURE DSYEV_F95
      END INTERFACE

      INTERFACE LA_HEEV
       MODULE PROCEDURE CHEEV_F95
       MODULE PROCEDURE ZHEEV_F95
      END INTERFACE

      INTERFACE LA_SYEVD
       MODULE PROCEDURE SSYEVD_F95
       MODULE PROCEDURE DSYEVD_F95
      END INTERFACE

      INTERFACE LA_HEEVD
       MODULE PROCEDURE CHEEVD_F95
       MODULE PROCEDURE ZHEEVD_F95
      END INTERFACE

      INTERFACE LA_SYEVR
       MODULE PROCEDURE SSYEVR_F95
       MODULE PROCEDURE DSYEVR_F95
      END INTERFACE

      INTERFACE LA_HEEVR
       MODULE PROCEDURE CHEEVR_F95
       MODULE PROCEDURE ZHEEVR_F95
      END INTERFACE

      INTERFACE LA_SYEVX
       MODULE PROCEDURE SSYEVX_F95
       MODULE PROCEDURE DSYEVX_F95
          END INTERFACE

      INTERFACE LA_HEEVX
       MODULE PROCEDURE CHEEVX_F95
       MODULE PROCEDURE ZHEEVX_F95
      END INTERFACE

      INTERFACE LA_SYGST
       MODULE PROCEDURE SSYGST_F95
       MODULE PROCEDURE DSYGST_F95
      END INTERFACE

      INTERFACE LA_HEGST
       MODULE PROCEDURE CHEGST_F95
           MODULE PROCEDURE ZHEGST_F95
      END INTERFACE

      INTERFACE LA_SYGV
       MODULE PROCEDURE SSYGV_F95
       MODULE PROCEDURE DSYGV_F95
          END INTERFACE

      INTERFACE LA_HEGV
       MODULE PROCEDURE CHEGV_F95
       MODULE PROCEDURE ZHEGV_F95
      END INTERFACE

      INTERFACE LA_SYGVX
       MODULE PROCEDURE SSYGVX_F95
       MODULE PROCEDURE DSYGVX_F95
      END INTERFACE

      INTERFACE LA_HEGVX
       MODULE PROCEDURE CHEGVX_F95
       MODULE PROCEDURE ZHEGVX_F95
      END INTERFACE

      INTERFACE LA_SYGVD
       MODULE PROCEDURE SSYGVD_F95
       MODULE PROCEDURE DSYGVD_F95
      END INTERFACE

      INTERFACE LA_HEGVD
       MODULE PROCEDURE CHEGVD_F95
       MODULE PROCEDURE ZHEGVD_F95
      END INTERFACE

      INTERFACE LA_SYTRD
       MODULE PROCEDURE SSYTRD_F95
       MODULE PROCEDURE DSYTRD_F95
      END INTERFACE

      INTERFACE LA_HETRD
       MODULE PROCEDURE CHETRD_F95
       MODULE PROCEDURE ZHETRD_F95
      END INTERFACE

      INTERFACE LA_ORGTR
       MODULE PROCEDURE SORGTR_F95
       MODULE PROCEDURE DORGTR_F95
          END INTERFACE

      INTERFACE LA_UNGTR
       MODULE PROCEDURE CUNGTR_F95
       MODULE PROCEDURE ZUNGTR_F95
          END INTERFACE

      INTERFACE LA_POTRF
       MODULE PROCEDURE SPOTRF_F95
       MODULE PROCEDURE DPOTRF_F95
       MODULE PROCEDURE CPOTRF_F95
       MODULE PROCEDURE ZPOTRF_F95
      END INTERFACE

      INTERFACE LA_LAGGE
       MODULE PROCEDURE SLAGGE_F95
       MODULE PROCEDURE DLAGGE_F95
       MODULE PROCEDURE CLAGGE_F95
       MODULE PROCEDURE ZLAGGE_F95
      END INTERFACE

      INTERFACE LA_LANGE
       MODULE PROCEDURE SLANGE_F95
       MODULE PROCEDURE SLANGE1_F95
       MODULE PROCEDURE DLANGE_F95
       MODULE PROCEDURE DLANGE1_F95
       MODULE PROCEDURE CLANGE_F95
       MODULE PROCEDURE CLANGE1_F95
       MODULE PROCEDURE ZLANGE_F95
       MODULE PROCEDURE ZLANGE1_F95
      END INTERFACE

      INTERFACE LA_GESDD
       MODULE PROCEDURE SGESDD_F95
       MODULE PROCEDURE DGESDD_F95
       MODULE PROCEDURE CGESDD_F95
       MODULE PROCEDURE ZGESDD_F95
      END INTERFACE

      CONTAINS

      SUBROUTINE CGBSV1_F95( A, B, K, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: K
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, LK, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LK -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LK -1
          CALL GBSV_F77( N, LK, KU, 1, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGBSV1_F95
 SUBROUTINE CGBSV_F95( A, B, KL, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: KL
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GBSV computes the solution to a real or complex linear system
!! of equations A*X = B, where A is a square band matrix and X and B are
!! rectangular matrices or vectors. The LU decomposition with row
!! interchanges is used to factor A as A = L*U , where L is a product of
!! permutation and unit lower triangular matrices with kl subdiagonals,
!! and U is upper triangular with kl + ku superdiagonals. The factored
!! form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSV( AB, B, KL=kl, IPIV=ipiv, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             INTEGER, INTENT(IN), OPTIONAL :: KL
!!             INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!         with size(AB,1) = 2*kl+ku+1 and size(AB,2) = n, where kl and ku
!!         are, respectively, the numbers of subdiagonals and
!!         superdiagonals in the band of A, and n is the order of A.
!!         On entry, the matrix A in band storage. The (kl + ku + 1)
!!         diagonals of A are stored in rows (kl + 1) to (2*kl + ku + 1)
!!         of AB, so that the j-th column of A is stored in the j-th
!!         column of AB as follows:
!!         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                        1<=j<=n
!!         The remaining elements in AB need not be set.
!!         On exit, details of the factorization. U is an upper triangular
!!         band matrix with (kl + ku + 1) diagonals. These are stored in
!!         the first (kl + ku + 1) rows of AB. The multipliers that arise
!!         during the factorization are stored in the remaining rows.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! KL      Optional (input) INTEGER.
!!         The number of subdiagonals in the band of A (KL = kl).
!!         The number of superdiagonals in the band is given by
!!         ku = size(AB,1) - 2 * kl - 1.
!!         Default value: (size(AB,1)-1)/3.
!! IPIV    Optional (output) INTEGER array, shape (:) with size(IPIV) = n.
!!         The pivot indices that define the row interchanges; row i of the
!!         matrix was interchanged with row IPIV(i).
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, U(i,i) = 0. The factorization has been
!!         completed, but the factor U is singular, so the solution could
!!         not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, NRHS, LKL, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LKL -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LKL -1 < 0 .OR. LKL < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LKL -1
          CALL GBSV_F77( N, LKL, KU, NRHS, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGBSV_F95
SUBROUTINE CGBSVX1_F95(A, B, X, KL, AF, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, &
              SC, SR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LC(:), LR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = 2*LKL+LKU+1; S2AF = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA - LKL -LKU -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AF /= 2*LKL+LKU+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, 1, A, LDA, LAF, S1AF, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGBSVX1_F95
SUBROUTINE CGBSVX_F95(A, B, X, KL, AFB, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFB(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GBSVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square band matrix and X and B are rectangular matrices or vectors.
!!    LA_GBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSVX( AB, B, X, KL=kl, AFB=afb, IPIV=ipiv, &
!!                  FACT=fact, TRANS=trans, EQUED=equed, R=r, C=c, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, &
!!                  RPVGRW=rpvgrw, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          INTEGER, INTENT(IN), OPTIONAL :: KL
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: C(:), R(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB        (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!           with size(AB,1) = kl + ku + 1 and size(AB,2) = n, where kl
!!           and ku are, respectively, the numbers of subdiagonals and
!!           superdiagonals in the band of A, and n is the order of A.
!!           On entry, the matrix A or its equilibration in band storage.
!!           The (kl + ku + 1) diagonals of A are stored in rows 1 to
!!           (kl + ku + 1) of AB, so that the j-th column of A is
!!           stored in the j-th column of AB as follows:
!!           AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                     1<=j<=n.
!!           The remaining elements in AB need not be set.
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during the previous call
!!           to LA GBSVX.
!!           On exit, if FACT = "E", the equilibrated version of A is
!!           stored in AB; otherwise, AB is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = n or shape (:) with size(B) = n.
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!           and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!           The solution matrix X .
!! KL        Optional (input) INTEGER.
!!           The number of subdiagonals in the band of A (KL = kl).
!!           The number of superdiagonals in the band is given by
!!           ku =  size(AB,1) - kl - 1.
!!           Default value: (size(AB,1) - 1) / 2.
!! AFB       Optional (input or output) REAL or COMPLEX rectangular array,
!!           shape (:,:) with size(AFB,1) = 2*kl+ku+1 and size(AFB,2)=n
!!           If FACT = "F" then AFB is an input argument that contains the
!!           details of the factorization of (the equilibrated) A returned
!!           by a previous call to LA_GBSVX.
!!           If FACT /= "F" then AFB is an output argument that contains
!!           the details of the factorization of (the equilibrated) A. U is
!!           an upper triangular band matrix with (kl + ku + 1) diagonals.
!!           These are stored in the first (kl + ku + 1) rows of AFB. The
!!           multipliers that arise during the factorization are stored in
!!           the remaining rows.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = n.
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A, returned by a previous call to LA_GBSVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!             = "N": The matrix A will be copied to AFB and factored (no
!!                  equilibration).
!!             = "E": The matrix A will be equilibrated, then copied to
!!                  AFB and factored.
!!             = "F": AFB and IPIV contain the factored form of (the
!!                  equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!             = "N": A*X = B (No transpose)
!!             = "T": A^T*X = B (Transpose)
!!             = "C": A^H*X = B (Conjugate transpose)
!!           Default value: "N".
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!             = "N": No equilibration (always true if FACT = "N").
!!             = "R": Row equilibration, i.e., A has been premultiplied
!!                  by diag(R).
!!             = "C": Column equilibration, i.e., A has been postmultiplied
!!                  by diag(C).
!!             = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with
!!           size(R) = size(A,1).
!!           The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with
!!           size(C) = size(A,1).
!!           The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j), FERR(j) is an
!!           estimated upper bound for the magnitude of the largest element
!!           in (X(j)-XTRUE) divided by the magnitude of the largest
!!           element in X(j). The estimate is as reliable as the estimate
!!           for RCOND and is almost always a slight overestimate of the
!!           true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any element
!!           of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition is
!!           indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!             <= n: U(i,i) = 0. The factorization has been completed,
!!                 but the factor U is singular, so the solution could
!!                 not be computed.
!!             = n+1: U is nonsingular, but RCOND is less than machine
!!                 precision, so the matrix is singular to working
!!                 precision. Nevertheless, the solution and error
!!                 bounds are computed because the computed solution can
!!                 be more accurate than the value of RCOND would suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, S1AFB, S2AFB, &
              SC, SR, SFERR, SBERR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LC(:), LR(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAFB(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); NRHS = SIZE(B, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFB) )THEN; S1AFB = SIZE(AFB,1); S2AFB = SIZE(AFB,2)
   ELSE; S1AFB = 2*LKL+LKU+1; S2AFB = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AFB /= 2*LKL+LKU+1 .OR. S2AFB /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -12
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -13
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFB) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFB) ) THEN; ALLOCATE( LAFB(S1AFB,N), STAT=ISTAT )
      ELSE; LAFB => AFB; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, NRHS, A, LDA, LAFB, S1AFB, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AFB) ) DEALLOCATE( LAFB, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGBSVX_F95
      SUBROUTINE CGBTRF_F95( A, K, M, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GBTRF_F77 => LA_GBTRF, LANGB_F77 => LA_LANGB, & !!((07-B-INT_LAPACK1.f90))
                                          GBCON_F77 => LA_GBCON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(IN), OPTIONAL :: K, M
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      COMPLEX(WP), INTENT( INOUT ) :: A( :, : )
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBTRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV, &
                 LK, KU, LM
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      LD = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0
      IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LD-1)/3; ENDIF
      IF( PRESENT(M) ) THEN; LM = M; ELSE; LM = N; ENDIF; MINMN = MIN(LM,N)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( N < 0 .OR. LD < 0 )THEN; LINFO = -1
      ELSE IF( LD - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -2
      ELSE IF( LM < 0 )THEN; LINFO = -3
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -4
      ELSE IF( PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -5
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -6
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( RWORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGB_F77( LNORM, MINMN, LK, KU, A, LD, RWORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(RWORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GBTRF_F77( LM, N, LK, KU, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(2*MINMN), RWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GBCON_F77( LNORM, MINMN, LK, KU, A, LD, LIPIV, &
                                     LANORM, RCOND, WORK, RWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE CGBTRF_F95
SUBROUTINE CGEEQU_F95( A, R, C, ROWCND, COLCND, AMAX, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEQU_F77 => LA_GEEQU                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT( OUT ), OPTIONAL :: AMAX, COLCND, ROWCND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT( IN ) :: A( :, : )
   REAL(WP), INTENT( OUT ) :: C( : ), R( : )
!---------------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GEEQU computes row and column scalings intended to equilibrate a
!! rectangle matrix A and reduce its condition number.  R returns the
!! row scale factors and C the column scale factors, chosen to try to
!! make the largest entry in each row and column of the matrix B with
!! elements B(i,j) = R(i) A(i,j) C(j) have absolute value 1.
!
!! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
!! number and BIGNUM = largest safe number. Use of these scaling
!! factors is not guaranteed to reduce the condition number of A but
!! works well in practice.
!
!! Arguments
!! =========
!
!! SUBROUTINE LA_GEEQU ( A, R, C, ROWCND, COLCND, AMAX, INFO )
!!    <type>(<wp>), INTENT(IN) :: A(:,:)
!!    REAL(<wp>), INTENT( OUT ) :: R(:), C(:)
!!    REAL(<wp>), INTENT( OUT ), OPTIONAL :: ROWCND, COLCND, AMAX
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! ====================
!
!! A       (input) either REAL or COMPLEX array, shape (:,:).
!!         The matrix A, whose equilibration factors are to be computed.
!
!! R       (output) REAL array, shape (:), size(R) == size(A,1).
!!         If INFO = 0 or INFO > size(A,1), R contains the row
!!         scale factors for A.
!
!! C       (output) REAL array, shape (:), size(C) == size(A,2).
!!         If INFO = 0, C contains the column scale factors for A.
!
!! ROWCND  Optional (output) REAL.
!!         If INFO = 0 or INFO > size(A,1), ROWCND contains the ratio
!!         of the smallest R(i) to the largest R(i).  If ROWCND >= 0.1
!!         and AMAX is neither too large nor too small, it is not worth
!!         scaling by R.
!
!! COLCND  Optional (output) REAL.
!!         If INFO = 0, COLCND contains the ratio of the smallest
!!         C(i) to the largest C(i).  If COLCND >= 0.1, it is not
!!         worth scaling by C.
!
!! AMAX    Optional (output) REAL.
!!         Absolute value of largest matrix element.  If AMAX is very
!!         close to overflow or very close to underflow, the matrix
!!         should be scaled.
!
!! INFO    Optional (output) INTEGER
!!         If INFO is present
!!            = 0:  successful exit
!!            < 0:  if INFO = -k, the k-th argument had an illegal value
!!            > 0:  if INFO = k,  and k is
!!                  <= M:  the k-th row of A is exactly zero
!!                  >  M:  the (k-M)-th column of A is exactly zero
!!                         where M = size(A,1)
!!         If INFO is not present and an error occurs, then the program is
!!            terminated with an error message.
!
!-------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEQU"
!!  .. LOCAL SCALARS ..
   INTEGER :: LINFO, M, N
   REAL(WP) :: LAMAX, LCOLCND, LROWCND
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; M = SIZE(A, 1); N = SIZE(A, 2)
!!  .. TEST THE ARGUMENTS
   IF ( SIZE(R) /= M ) THEN; LINFO = -2
   ELSE IF ( SIZE(C) /= N ) THEN; LINFO = -3
   ELSE
!!     .. CALL LAPACK77 ROUTINE
      CALL GEEQU_F77( M, N, A, MAX(1,M), R, C, LROWCND, LCOLCND, LAMAX, LINFO )
      IF( PRESENT( ROWCND ) ) ROWCND = LROWCND
      IF( PRESENT( COLCND ) ) COLCND = LCOLCND
      IF( PRESENT( AMAX ) ) AMAX = LAMAX
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE CGEEQU_F95
    SUBROUTINE CGEES_F95( A, W, VS, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEES_F77 => LA_GEES                                !!((07-B-INT_LAPACK1.f90))
!!  use LA_EXTERNAL, ONLY: SELECT
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
   INTERFACE
      LOGICAL FUNCTION SELECT(W)
         use KND_LA_PRECISION, ONLY: WP => SP                                !!((05-B-KND_LA_PRECISION.f90))
         COMPLEX(WP), INTENT(IN) :: W
      END FUNCTION SELECT
   END INTERFACE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GEES computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! Schur factorization
!!                        A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left. The leading
!! columns of Z then form an orthonormal basis for the invariant subspace
!! corresponding to the selected eigenvalues.
!!      A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks are
!! standardized in the form
!!                       [ a  b ]
!!                       [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!! A complex matrix is in complex-Schur form if it is upper triangular.
!!
!! =========
!!
!!        SUBROUTINE LA_GEES( A, <w>, VS=vs, SELECT=select, &
!!                                   SDIM=sdim, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           <type>(<wp>), INTENT(OUT) :: <w(:)>
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!           INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!           END INTERFACE
!!           OPTIONAL :: SELECT
!!           INTEGER, INTENT(OUT), OPTIONAL :: SDIM, INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <w>    ::= WR, WI | W
!!           <w(:)> ::= WR(:), WI(:) | W(:)
!!           <w(j)> ::= WR(j) , WI(j) |  W(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the Schur form T.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues in the order in which they appear on
!!          the diagonal of the Schur form T.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VS       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VS,1) = size(A,1).
!!          The matrix Z of Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION.
!!          LOGICAL FUNCTION SELECT( <w(j)> )
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!          where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j) , WI(j) | W(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!             interface in the calling (sub)program.
!!          2. SELECT is called by LA_GEES for every computed eigenvalue
!!           w(j) (but only once for a complex conjugate pair when A is
!!           real). It is used to select the eigenvalues that will be
!!             ordered to the top left of the Schur form. The eigenvalue
!!           w(j) is selected if SELECT(w(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!           SELECT(w(j)) = .TRUE. after ordering, since ordering may
!!           change the value of complex eigenvalues (especially if the
!!           eigenvalue is ill-conditioned). In this case INFO is set to
!!           size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which
!!          SELECT=.TRUE. (If A is real, complex conjugate pairs for which
!!          SELECT=.TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of w contain
!!                    those eigenvalues which have converged. VS contains
!!                    the matrix which reduces A to its partially converged
!!                    Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                  problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                  in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!-------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEES"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
!!  .. LOCAL ARRAYS ..
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   COMPLEX(WP), TARGET :: LLVS(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LSDIM = 0
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(SDIM) .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      IF( ISTAT == 0 ) THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), RWORK(N),  STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VS) )THEN
          IF( PRESENT(SDIM) )THEN
             ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        VS, S1VS, WORK, LWORK, RWORK, BWORK, LINFO )
            ELSE
               CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        VS, S1VS, WORK, LWORK, RWORK, LLBWORK, LINFO )
            ENDIF
           ELSE
            IF( PRESENT(SDIM) )THEN
              ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        LLVS, S1VS, WORK, LWORK, RWORK, BWORK, LINFO )
            ELSE
               CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        LLVS, S1VS, WORK, LWORK, RWORK, LLBWORK, LINFO )
            ENDIF
           ENDIF

         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
!!      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   IF( PRESENT(SDIM) ) SDIM = LSDIM
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGEES_F95
SUBROUTINE CGEESX_F95( A, W, VS, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEESX_F77 => LA_GEESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
   REAL(WP), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
      INTERFACE
         FUNCTION SELECT(W)
            use KND_LA_PRECISION, ONLY: WP => SP                             !!((05-B-KND_LA_PRECISION.f90))
            COMPLEX(WP), INTENT(IN) :: W
            LOGICAL :: SELECT
         END FUNCTION SELECT
      END INTERFACE
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GEESX computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! factorization
!!                     A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left, computes a
!! reciprocal condition number for the average of the selected eigenvalues
!! and computes a reciprocal condition number for the right invariant
!! subspace corresponding to the selected eigenvalues. The leading columns
!! of Z form an orthonormal basis for this invariant subspace.
!! A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks
!! are standardized in the form
!!                        [ a  b ]
!!                        [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!!
!! =========
!!
!!       SUBROUTINE LA_GEESX( A, <w>, VS=vs, SELECT=select, SDIM=sdim, &
!!                              RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!            INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!            END INTERFACE
!!            OPTIONAL :: SELECT
!!            INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the Schur form T .
!! <w>     (output) REAL or COMPLEX array, shape (:) with size(w) =
!!         size(A,1).
!!         The computed eigenvalues in the order in which they appear on
!!         the diagonal of the Schur form T.
!!         <w(:)> ::= WR(:), WI(:) | W(:),
!!         where
!!         WR(:), WI(:) are of REAL type (for the real and imaginary
!!         parts) and W(:) is of COMPLEX type.
!!         Note: If A is real, then a complex-conjugate pair appear
!!         consecutively, with the eigenvalue having the positive
!!         imaginary part appearing first.
!! VS      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VS,1) = size(A,1).
!!         The matrix Z of Schur vectors.
!! SELECT  Optional (input) LOGICAL FUNCTION
!!         LOGICAL FUNCTION SELECT( <w(j)>)
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp> ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!         1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!         2. SELECT is called by LA_GEES for every computed eigenvalue
!!          <w(j)> (but only once for a complex conjugate pair when A
!!          is real). It is used to select the eigenvalues that will be
!!          ordered to the top left of the Schur form. The eigenvalue
!!          <w(j)> is selected if SELECT(<w(j)>) has the value .TRUE.
!!         3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<w(j)>) = .TRUE. after ordering, since ordering may
!!          change the value of complex eigenvalues (especially if the
!!          eigenvalue is ill-conditioned). In this case INFO is set to
!!          size(A,1) + 2 (see INFO below).
!!         Note: Select must be present if SDIM, RCONDE and RCONDF are
!!         desired.
!! SDIM    Optional (output) INTEGER.
!!         The number of eigenvalues (after sorting) for which
!!         SELECT = .TRUE. (If A is real, complex conjugate pairs for which
!!         SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE  Optional (output) REAL.
!!         The reciprocal condition number for the average of the selected
!!         eigenvalues.
!! RCONDV  Optional (output) REAL.
!!         The reciprocal condition number for the selected right
!!         invariant subspace.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of <w>
!!                    contain those eigenvalues which have converged.
!!                    VS contains the matrix which reduces A to its
!!                    partially converged Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                    problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                    in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
   REAL(WP) :: LRCONDE, LRCONDV
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   COMPLEX(WP), TARGET :: LLVS(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -3
   ELSE IF( LSAME(LSORT,"S") .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      IF( LSAME(LSORT,"S") )THEN
        ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      ALLOCATE( RWORK(MAX(1,N)), STAT=ISTAT )
      IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 200; ENDIF

      LWORK = MAX(1, 2*N, N*N/2)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 300; ENDIF
      IF (PRESENT (VS)) THEN
          CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, W, &
     &        VS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &        RWORK, BWORK, LINFO )
       ELSE
          CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, W, &
     &        LLVS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &        RWORK, BWORK, LINFO )
      ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( PRESENT(RCONDE) ) RCONDE = LRCONDE
      IF( PRESENT(RCONDV) ) RCONDV = LRCONDV
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)

      DEALLOCATE(WORK, STAT=ISTAT)
300   DEALLOCATE(RWORK, STAT=ISTAT )
200   IF( LSAME(LSORT,"S")) DEALLOCATE(BWORK,STAT=ISTAT)
    ENDIF
100 CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGEESX_F95
SUBROUTINE CGEEV_F95( A, W, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEV_F77 => LA_GEEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEV computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors. A
!! right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j).
!!
!! =========
!!
!!       SUBROUTINE LA_GEEV( A, <w>, VL=vl, VR=vr, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors were computed. Elements
!!          i+1 : n of <w> contain eigenvalues which have converged.
!!          n is the order of A
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      LWORK = MAX( 1, 2*N, LWORK)
      ALLOCATE(WORK(LWORK), RWORK(MAX(1,2*N)), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            LWORK = MAX( 1, 2*N )
            ALLOCATE(WORK(LWORK), RWORK(MAX(1,2*N)), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VL) )THEN
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        VL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        VL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
            ENDIF
           ELSE
            IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        LLVL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        LLVL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
            ENDIF
           ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGEEV_F95
SUBROUTINE CGEEVX_F95( A, W, VL, VR, BALANC, ILO, IHI, &
                       SCALE, ABNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEVX_F77 => LA_GEEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, ILO, IHI
   REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: SCALE(:), RCONDE(:), RCONDV(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEVX computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors.
!! Optionally, it also balances A and computes reciprocal condition
!! numbers for the  eigenvalues and right eigenvectors.
!! A right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j). The computed
!! eigenvectors are normalized to have Euclidean norm equal to 1 and
!! largest component real.
!!        Balancing A involves permuting its rows and columns to make
!! it more nearly upper triangular and then scaling rows and columns by
!! a diagonal similarity transformation to reduce the condition numbers
!! of the eigenvalues and eigenvectors.
!!        Computed reciprocal condition numbers pertain to the matrix
!! after balancing. Permuting does not change condition numbers (in
!! exact arithmetic), but scaling does.
!
!! =========
!!
!!    SUBROUTINE LA_GEEVX( A, <w>, VL=vl, VR=vr, BALANC=balanc, ILO=ilo, &
!!                     IHI=ihi, SCALE=scale, ABNRM=abnrm, RCONDE=rconde, &
!!                     RCONDV=rcondv, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <w(:)>
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!         INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: SCALE(:), ABNRM, &
!!               RCONDE(:), RCONDV(:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!         <w>    ::= WR, WI | W
!!         <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC   Optional (input) CHARACTER(LEN=1).
!!          Indicates whether the input matrix should be permuted and/or
!!          diagonally scaled.
!!             = "N": Do not permute or scale;
!!             = "P": Permute but do not scale;
!!             = "S": Scale but do not permute;
!!             = "B": Both permute and scale.
!!           Default value: "N".
!! ILO,IHI  Optional (output) INTEGER.
!!          ILO and IHI are determined when A is balanced. The balanced
!!          A(i,j) = 0 if i > j and j = 1, ..., ILO-1 or
!!          i = IHI+1, ... , size(A,1).
!! SCALE    Optional (output) REAL array, shape (:) with size(SCALE) =
!!          size(A,1).
!!          Details of the permutations and scaling factors applied when
!!          balancing A. If P(j) is the index of the row and column
!!          interchanged with row and column j, and D(j) is the
!!          scaling factor applied to row and column j, then
!!          P(j) = SCALE(j), j = 1, ..., ILO-1 and j =IHI+1, ...,  n
!!          D(j) = SCALE(j), j = ILO, ... , IHI.
!! ABNRM    Optional (output) REAL.
!!          The l1 norm of the balanced matrix (the maximum of the sum
!!          of absolute values of elements of any column).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE) =
!!          size(A,1). RCONDE(j) is the reciprocal condition number of
!!          the j-th eigenvalue.
!! RCONDV   Optional (output) REAL array, shape (:), size(RCONDV) =
!!          size(A,1). RCONDV(j) is the reciprocal condition number of
!!          the j-th right eigenvector.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors or condition numbers were
!!          computed; elements 1:ILO-1 and i+1:n of <w> contain
!!          eigenvalues which have converged.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LBALANC, LJOBVL, LJOBVR, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, NN, &
              LILO, LIHI, SSCALE, SRCONDE, SRCONDV
   REAL(WP) :: LABNRM
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
   REAL(WP), POINTER :: LSCALE(:), LRCONDE(:), LRCONDV(:)
   COMPLEX(WP), POINTER :: LLVL(:,:), LLVR(:,:)
   COMPLEX(WP), POINTER :: WORK(:)

!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = N; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = N; LJOBVR = "N"; END IF
   IF( PRESENT(SCALE) )THEN; SSCALE = SIZE(SCALE); ELSE; SSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -4
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
                   LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -5
   ELSE IF( SSCALE /= N )THEN; LINFO = -8
   ELSE IF( SRCONDE /= N )THEN; LINFO = -10
   ELSE IF( SRCONDV /= N )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
      IF( PRESENT(SCALE) )THEN; LSCALE => SCALE
      ELSE
        ALLOCATE( LSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 100; END IF
      ENDIF
      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE
        ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 200; END IF
      ENDIF
      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE
        ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 300; END IF
      END IF
      ALLOCATE( RWORK(MAX(1,2*N)), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 400; END IF
      IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN; NN = 2*N
      ELSE IF( LSAME(LSENSE,"V") .OR. LSAME(LSENSE,"B") )THEN; NN = N*(N+2)
      ELSE; NN = 2*N; ENDIF
      IF (LSAME (LSENSE,"E") .OR. LSAME(LSENSE,"B") ) THEN
         LJOBVL = "V"; LJOBVR = "V"; S1VR=N; S1VL=N
      ENDIF
      IF (PRESENT (VL)) THEN; LLVL => VL
      ELSE; ALLOCATE (LLVL(N,N), STAT = ISTAT); ENDIF
      IF (PRESENT (VR)) THEN; LLVR => VR
      ELSE; ALLOCATE (LLVR(N,N), STAT = ISTAT); ENDIF
      LWORK = -1
      IF (PRESENT (VL)) THEN
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ENDIF
        ELSE
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ENDIF
         ENDIF
       LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
        DEALLOCATE(WORK, STAT=ISTAT1)
        LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 500; END IF
      END IF
      IF (PRESENT (VL)) THEN
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ENDIF
       ELSE
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ENDIF
        ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO;
      IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM

      DEALLOCATE(WORK, STAT=ISTAT1)
500   DEALLOCATE(RWORK, STAT=ISTAT1)
400   IF( .NOT. PRESENT(RCONDV) ) DEALLOCATE( LRCONDV, STAT=ISTAT1 )
300   IF( .NOT. PRESENT(RCONDE) ) DEALLOCATE( LRCONDE, STAT=ISTAT1 )
200   IF( .NOT. PRESENT(SCALE) ) DEALLOCATE( LSCALE, STAT=ISTAT1 )
      IF (.NOT.PRESENT (VL)) DEALLOCATE(LLVL)
      IF (.NOT.PRESENT (VR)) DEALLOCATE(LLVR)
   ENDIF
100   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)

END SUBROUTINE CGEEVX_F95
    SUBROUTINE CGEGS_F95( A, B, ALPHA, BETA, VSL, VSR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGS_F77 => LA_GEGS                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGS computes for a pair of n-by-n real nonsymmetric matrices
!!  A, B: the generalized eigenvalues (alphar alpha, beta),
!!  the Schur form (A, B), and optionally left and/or right
!!  Schur vectors (VSL and VSR).
!
!!  (If only the generalized eigenvalues are needed, use the driver SGEGV
!!  instead.)
!
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!
!!  The (generalized) Schur form of a pair of matrices is the result of
!!  multiplying both matrices on the left by one orthogonal matrix and
!!  both on the right by another orthogonal matrix, these two orthogonal
!!  matrices being chosen so as to bring the pair of matrices into
!!  (real) Schur form.
!
!!  A pair of matrices A, B is in generalized real Schur form if B is
!!  upper triangular with non-negative diagonal and A is block upper
!!  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
!!  to real generalized eigenvalues, while 2-by-2 blocks of A will be
!!  "standardized" by making the corresponding elements of B have the
!!  form:
!!          [  a  0  ]
!!          [  0  b  ]
!
!!  and the pair of corresponding 2-by-2 blocks in A and B will
!!  have a complex conjugate pair of generalized eigenvalues.
!
!!  The left and right Schur vectors are the columns of VSL and VSR,
!!  respectively, where VSL and VSR are the orthogonal matrices
!!  which reduce A and B to Schur form:
!
!!  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
!
!! =========
!
!!   SUBROUTINE LA_GEGS( A, B, <alpha>, BETA, VSL, VSR, INFO )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose generalized
!!      eigenvalues and (optionally) Schur vectors are to be
!!      computed.
!!      On exit, the generalized Schur form of A.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      A should be less than the overflow threshold.
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) Schur vectors are
!!      to be computed.
!!      On exit, the generalized Schur form of B.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      B should be less than the overflow threshold.
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
!!      j=1,...,n  and  BETA(j),j=1,...,n  are the diagonals of the
!!      complex Schur form (A,B) that would result if the 2-by-2
!!      diagonal blocks of the real Schur form of (A,B) were further
!!      reduced to triangular form using 2-by-2 complex unitary
!!      transformations.  If ALPHAI(j) is zero, then the j-th
!!      eigenvalue is real; if positive, then the j-th and (j+1)-st
!!      eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
!!      negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VSL  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSL will contain the left Schur vectors. (See "Purpose", above.)
!
!! VSR  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSR will contain the right Schur vectors. (See "Purpose", above.)
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  (A,B) are not in Schur
!!            form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
!!            be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_GGBAK (computing VSL)
!!            =n+8: error return from LA_GGBAK (computing VSR)
!!            =n+9: error return from LA_LASCL (various places)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VSL, S2VSL, S1VSR, S2VSR, &
              SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   COMPLEX(WP), POINTER :: WORK(:), &
     &                    LALPHA(:), LBETA(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHA) )THEN; SALPHA = SIZE(ALPHA); ELSE; SALPHA = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHA) )THEN; LALPHA => ALPHA
      ELSE; ALLOCATE(LALPHA(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE( RWORK(MAX(1,3*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VSL, S1VSL, VSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ENDIF
          ELSE
            IF( PRESENT(VSR) )THEN
               CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVSL, S1VSL, VSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ENDIF
          ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGEGS_F95
    SUBROUTINE CGEGV_F95( A, B, ALPHA, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGV_F77 => LA_GEGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGV computes for a pair of N-by-N complex nonsymmetric
!!  matrices A and B, the generalized eigenvalues (alpha, beta),
!!  and optionally, the left and/or right generalized eigenvectors
!!  (VL and VR).
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!!  A right generalized eigenvector corresponding to a generalized
!!  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
!!  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
!!  l such that l**H * (A - w B) = 0, where l**H is the
!!  conjugate-transpose of l.
!!  Note: this routine performs "full balancing" on A and B -- see
!!  "Further Details", below.
!
!! =========
!
!!   SUBROUTINE LA_GEGV( A, B, <alpha>, BETA, VL, VR, INFO )
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of A on exit, see "Further
!!      Details", below.)
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of B on exit, see "Further
!!      Details", below.)
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  If ALPHAI(j) is zero, then
!!      the j-th eigenvalue is real; if positive, then the j-th and
!!      (j+1)-st eigenvalues are a complex conjugate pair, with
!!      ALPHAI(j+1) negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VL   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VL,1) == SIZE(VL,2) == n.
!!      The left generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! VR   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VR,1) == SIZE(VR,2) == n.
!!      The right generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  No eigenvectors have been
!!            calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
!!            should be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_TGEVC
!!            =n+8: error return from LA_GGBAK (computing VL)
!!            =n+9: error return from LA_GGBAK (computing VR)
!!            =n+10: error return from LA_LASCL (various calls)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!! Further Details
!! ===============
!
!! Balancing
!! ---------
!
!! This driver calls SGGBAL to both permute and scale rows and columns
!! of A and B.  The permutations PL and PR are chosen so that PL*A*PR
!! and PL*B*R will be upper triangular except for the diagonal blocks
!! A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
!! possible.  The diagonal scaling matrices DL and DR are chosen so
!! that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
!! one (except for the elements that start out zero.)
!
!! After the eigenvalues and eigenvectors of the balanced matrices
!! have been computed, SGGBAK transforms the eigenvectors back to what
!! they would have been (in perfect arithmetic) if they had not been
!! balanced.
!
!! Contents of A and B on Exit
!! -------- -- - --- - -- ----
!
!! If any eigenvectors are computed (either VL or VR or both), then on
!! exit the arrays A and B will contain the real Schur form[*] of the
!! "balanced" versions of A and B. If no eigenvectors are computed,
!! then only the diagonal blocks will be correct.
!
!! [*] See LA_HGEQZ, LA_GEGS, or read the book "Matrix Computations",
!!     by Golub & van Loan, pub. by Johns Hopkins U. Press.
!--------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, &
              SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   COMPLEX(WP), POINTER :: WORK(:), LALPHA(:), LBETA(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHA) )THEN; SALPHA = SIZE(ALPHA); ELSE; SALPHA = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHA) )THEN; LALPHA => ALPHA
      ELSE; ALLOCATE(LALPHA(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE( RWORK(MAX(1, 8*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VL) )THEN
          IF( PRESENT(VR) )THEN
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
             ELSE
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
             ENDIF
            ELSE
             IF( PRESENT(VR) )THEN
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
             ELSE
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
             ENDIF
            ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGEGV_F95
 SUBROUTINE CGELS1_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "C"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"C") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, 1, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGELS1_F95
 SUBROUTINE CGELS_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GELS computes the minimum-norm least squares solution to one
!! or more real or complex linear systems of the form A*x = b, A^T*x = b
!! or A^H*x = b using a QR or LQ factorization of A. Matrix A is
!! rectangular assumed to be of full rank. The vectors b and correspon-
!! ding solution vectors x are the columns of matrices denoted B and X,
!! respectively.
!!
!! ==========
!!
!!       SUBROUTINE LA_GELS( A, B, TRANS=trans, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX rectangular array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, if size(A,1) >= size(A,2), A is overwritten by
!!          details of its QR factorization. If size(A,1) < size(A,2), A
!!          is overwritten by details of its LQ factorization.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!          size(B) = max(size(A,1); size(A,2)).
!!          On entry, the matrix B.
!!          On exit, the solution matrix X. There are four cases:
!!          1. If TRANS = "N" and size(A,1) >= size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the least squares
!!             solution vector(s); the residual sum of squares for the
!!             solution vector in a column of B is given by the sum of
!!             squares of elements in rows size(A,2)+1 to size(A,1) of
!!             that column.
!!          2. If TRANS = "N" and size(A,1) < size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the minimum norm
!!             solution vector(s).
!!          3. If TRANS = "T" or TRANS = "C", and size(A,1)>=size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             minimum norm solution vector(s).
!!          4. If TRANS = "T" or TRANS = "C", and size(A,1) < size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             least squares solution vector(s); the residual sum of
!!             squares for the solution vector in a column of B is given
!!             by the sum of squares of elements in rows size(A,1)+1 to
!!             size(A,2) of that column.
!! TRANS    Optional (input) CHARACTER(LEN=1).
!!          Specifies the form of the system of equations:
!!          = "N": Ax = b (No transpose)
!!          = "T": A^T*x = b (Transpose)
!!          = "C": A^H*x = b (Conjugate transpose)
!!          Default value: "N".
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!---------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "C"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, NRHS
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"C") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, NRHS, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N,NRHS)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGELS_F95
SUBROUTINE CGELSD1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL, LRWORK
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
       SMLSIZ = ILAENV_F77( 9, "ZGELSD", " ", 0, 0, 0, 0 )
       NLVL = MAX(INT(LOG(DBLE(MAX(1,MN))/DBLE(SMLSIZ+1))/LOG(TWO)),0)
!! NEXT LINE SHOULD BE  LIWORK = 3 * MN * NLVL + 11 * MN, WHEN THE LAPACK CODE IS FIXED
       LIWORK = 2*(3 * MN * NLVL + 11 * MN)
       LRWORK = 8  * MN + 2*MN*SMLSIZ + 8*MN*NLVL + MN

       LRWORK = 25000
       ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF

       IF( PRESENT(RCOND) )THEN; LRCOND = RCOND
       ELSE; LRCOND = 100*EPSILON(1.0_WP); ENDIF
       IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
       IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
       ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N)) THEN; LINFO = -2
       ELSE IF( SS /= MN ) THEN; LINFO = -4
       ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
       ELSE
          IF( PRESENT(S) )THEN; LS => S
          ELSE
            ALLOCATE( LS(MN), STAT = ISTAT );
            IF (ISTAT /= 0) THEN ;
             LINFO=-200; GOTO 200; ENDIF
          END IF
          LWORK=-1

          CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &         LS, LRCOND, LRANK, WORKMIN, LWORK, RWORK, IWORKMIN, LINFO )
          LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED, WHEN THE LAPACK CODE IS FIXED.
          LWORK = 10 * LWORK
          ALLOCATE( WORK(LWORK), IWORK(LIWORK), STAT = ISTAT )
          IF (ISTAT /= 0) THEN;
            LINFO=-300; GOTO 300
          ENDIF

          CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, SIZE(B,1), &
     &      LS, LRCOND, LRANK, WORK, LWORK, RWORK, IWORK, LINFO )

          IF( PRESENT(RANK) ) RANK = LRANK
          DEALLOCATE(WORK, IWORK, STAT = ISTAT)
300       IF (.NOT. PRESENT(S)) DEALLOCATE(LS, STAT = ISTAT)
        END IF
200     DEALLOCATE(RWORK, STAT = ISTAT)
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGELSD1_F95
SUBROUTINE CGELSD_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, NRHS, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL, LRWORK
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
       SMLSIZ = ILAENV_F77( 9, "ZGELSD", " ", 0, 0, 0, 0 )
       NLVL = MAX(INT(LOG(DBLE(MAX(1,MN))/DBLE(SMLSIZ+1))/LOG(TWO)),0)
!! NEXT LINE SHOULD BE  LIWORK = 3 * MN * NLVL + 11 * MN, WHEN THE LAPACK CODE IS FIXED
       LIWORK = 2*(3 * MN * NLVL + 11 * MN)
       LRWORK = 8  * MN + 2*MN*SMLSIZ + 8*MN*NLVL + MN*NRHS

       LRWORK = 25000
       ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF

       IF( PRESENT(RCOND) )THEN; LRCOND = RCOND
       ELSE; LRCOND = 100*EPSILON(1.0_WP); ENDIF
       IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
       IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
       ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
       ELSE IF( SS /= MN ) THEN; LINFO = -4
       ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
       ELSE
          IF( PRESENT(S) )THEN; LS => S
          ELSE
            ALLOCATE( LS(MN), STAT = ISTAT );
            IF (ISTAT /= 0) THEN ;
             LINFO=-200; GOTO 200; ENDIF
          END IF
          LWORK=-1

          CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &         LS, LRCOND, LRANK, WORKMIN, LWORK, RWORK, IWORKMIN, LINFO )
          LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED, WHEN THE LAPACK CODE IS FIXED.
          LWORK = 10 * LWORK
          ALLOCATE( WORK(LWORK), IWORK(LIWORK), STAT = ISTAT )
          IF (ISTAT /= 0) THEN;
            LINFO=-300; GOTO 300
          ENDIF

          CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, SIZE(B,1), &
     &      LS, LRCOND, LRANK, WORK, LWORK, RWORK, IWORK, LINFO )

          IF( PRESENT(RANK) ) RANK = LRANK
          DEALLOCATE(WORK, IWORK, STAT = ISTAT)
300       IF (.NOT. PRESENT(S)) DEALLOCATE(LS, STAT = ISTAT)
        END IF
200     DEALLOCATE(RWORK, STAT = ISTAT)
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGELSD_F95
 SUBROUTINE CGELSS1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "C"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: RWORK(:), LS(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = 1; MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          ALLOCATE( RWORK( MAX(1, 5*MIN(M,N) -4)), STAT = ISTAT )
       END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 2*MIN(M,N) + MAX( M, N, NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGELSS1_F95
 SUBROUTINE CGELSS_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "C"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: RWORK(:), LS(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          ALLOCATE( RWORK( MAX(1, 5*MIN(M,N) -4)), STAT = ISTAT )
       END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 2*MIN(M,N) + MAX( M, N, NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGELSS_F95
 SUBROUTINE CGELSX1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    COMPLEX(WP), POINTER :: WORK(:)
    REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE
         ALLOCATE( LJPVT(N), STAT = ISTAT )
         IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 100; END IF
         LJPVT = 0
       END IF
       LWORK = 2*MAX( 1, MIN(M,N) + MAX( N,2*MIN(M,N) + 1 ) )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 200; END IF
       ALLOCATE( RWORK(MAX(1,2*N)), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 300; END IF

       CALL GELSX_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                      LJPVT, LRCOND, LRANK, WORK, RWORK, LINFO )

       IF( PRESENT(RANK) ) RANK = LRANK
!!       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(RWORK, STAT = ISTAT1 )
300    DEALLOCATE(WORK, STAT = ISTAT1 )
200    IF (.NOT. PRESENT(JPVT)) DEALLOCATE(LJPVT, STAT = ISTAT1 )
     END IF
100 CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGELSX1_F95
 SUBROUTINE CGELSX_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GELSX computes the minimum-norm solution to a real linear least
!! squares problem:
!!     minimize || A * X - B ||
!! using a complete orthogonal factorization of A.  A is an m-by-n
!! matrix which may be rank-deficient.
!! Several right hand side vectors b and solution vectors x can be
!! handled in a single call; they are stored as the columns of the
!! M-by-NRHS right hand side matrix B and the n-by-nrhs solution
!! matrix X.
!! The routine first computes a QR factorization with column pivoting:
!!     A * P = Q * [ R11 R12 ]
!!                 [  0  R22 ]
!! with R11 defined as the largest leading submatrix whose estimated
!! condition number is less than 1/RCOND.  The order of R11, RANK,
!! is the effective rank of A.
!! Then, R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal transformations from the right, arriving at the
!! complete orthogonal factorization:
!!    A * P = Q * [ T11 0 ] * Z
!!                [  0  0 ]
!! The minimum-norm solution is then
!!    X = P * Z" [ inv(T11)*Q1"*B ]
!!               [        0       ]
!! where Q1 consists of the first RANK columns of Q.
!
!
!! Arguments
!! =========
!
!!  SUBROUTINE LA_GELSX( A, B, RANK, JPVT, RCOND, INFO )
!!    <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!    INTEGER, INTENT(IN), OPTIONAL :: RANK
!!    INTEGER, INTENT(OUT), OPTIONAL :: JPVT(:)
!!    REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A    (input/output) Deither REAL or COMPLEX array, shape (:,:),
!!      SIZE(A,1) == m, SIZE(A,2) == n.
!!      On entry, the m-by-n matrix A.
!!      On exit, A has been overwritten by details of its
!!      complete orthogonal factorization.
!!      INFO = -1 if SIZE(A,1) < 0 or SIZE(A,2) < 0
!
!! B    Optional (input/output) either REAL or COMPLEX array, shape either
!!      (:,:) or (:), size(B,1) or size(B) == size(A,1). SIZE(B,2) == nrhs.
!!      On entry, the m-by-nrhs right hand side matrix B.
!!      On exit, the n-by-nrhs solution matrix X.
!!      If m >= n and RANK = n, the residual sum-of-squares for
!!      the solution in the i-th column is given by the sum of
!!      squares of elements n+1:m in that column.
!!      INFO = -2 if SIZE(B,1) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                    and if shape of B is (:,:) or
!!                if SIZE(B) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                   and if shape of B is (:)
!
!! RANK Optional (output) INTEGER
!!      The effective rank of A, i.e., the order of the submatrix
!!      R11.  This is the same as the order of the submatrix T11
!!      in the complete orthogonal factorization of A.
!
!! JPVT Optional (input/output) INTEGER array, shape (:), SIZE(JPVT) == n
!!      On entry, if JPVT(i) .ne. 0, the i-th column of A is an
!!      initial column, otherwise it is a free column.  Before
!!      the QR factorization of A, all initial columns are
!!      permuted to the leading positions; only the remaining
!!      free columns are moved as a result of column pivoting
!!      during the factorization.
!!      On exit, if JPVT(i) = k, then the i-th column of A*P
!!      was the k-th column of A.
!!      INFO = -4 if SIZE(S) /= SIZE(A,2)
!
!! RCOND Optional (input) REAL
!!      RCOND is used to determine the effective rank of A, which
!!      is defined as the order of the largest leading triangular
!!      submatrix R11 in the QR factorization with pivoting of A,
!!      whose estimated condition number < 1/RCOND.
!
!! INFO    (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!--------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    COMPLEX(WP), POINTER :: WORK(:)
    REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
       LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE
         ALLOCATE( LJPVT(N), STAT = ISTAT )
         IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 100; END IF
         LJPVT = 0
       END IF
       LWORK = 2*MAX( 1, MIN(M,N) + MAX( N,2*MIN(M,N) + NRHS ) )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 200; END IF
       ALLOCATE( RWORK(MAX(1,2*N)), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 300; END IF

       CALL GELSX_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                      LJPVT, LRCOND, LRANK, WORK, RWORK, LINFO )

       IF( PRESENT(RANK) ) RANK = LRANK
!!       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(RWORK, STAT = ISTAT1 )
300    DEALLOCATE(WORK, STAT = ISTAT1 )
200    IF (.NOT. PRESENT(JPVT)) DEALLOCATE(LJPVT, STAT = ISTAT1 )
     END IF
100 CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGELSX_F95
      SUBROUTINE CGELSY1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      COMPLEX(WP), POINTER :: WORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
         LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= MAX(1,M,N)) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF

        ALLOCATE(RWORK(2*N), STAT=ISTAT)
        IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, RWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE CGELSY1_F95
      SUBROUTINE CGELSY_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GELSY computes the minimum-norm least squares solution to one
!! or more real or complex linear systems A*x = b using a complete
!! orthogonal factorization of A. Matrix A is rectangular and may be
!! rankdeficient. The vectors b and corresponding solution vectors x are
!! the columns of matrices denoted B and X, respectively.
!!     The routine computes a QR factorization of A with column pivoting:
!!           A * P = Q * [ R11 R12 ]
!!                       [  0  R22 ]
!! where R11 is the largest leading submatrix whose estimated condition
!! number is less than 1/RCOND. The order of R11, RANK, is the effective
!! rank of A. R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal (unitary) transformations from the right, yielding the
!! complete orthogonal (unitary) factorization
!!           A * P = Q * [ T11  0  ] * Z
!!                     [  0   0  ]
!! The minimum-norm least squares solution is then
!!           x = P * Z^H [ T11^-1 * Q1^H * b ]
!!                     [        0          ]
!! where Q1 consists of the first RANK columns of Q.
!!
!! =========
!!
!!          SUBROUTINE LA_GELSY( A, B, RANK=rank, &
!!                     JPVT= jpvt, RCOND= rcond, INFO= info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!              INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!              INTEGER, INTENT(INOUT), OPTIONAL :: JPVT(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been overwritten by details of its complete
!!         orthogonal factorization.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1),size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, rows 1 to size(A,2) contain the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution vector in a column of B is
!!         given by the sum of squares of elements in rows size(A,2)+1 :
!!         size(A,1) of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the order of the submatrix R11.
!!         This is the same as the order of the submatrix T11 in the
!!         complete orthogonal factorization of A.
!! JPVT    Optional (input/output) INTEGER array, shape (:) with
!!         size(JPVT) = size(A,2).
!!         On entry, if JPVT(i) /= 0, the i-th column of A is an initial
!!         column, otherwise it is a free column.
!!         Before the QR factorization of A, all initial columns are
!!         permuted to the leading positions; only the remaining free
!!         columns are moved as a result of column pivoting during the
!!         factorization.
!!         On exit, if JPVT(i) = k, then the i-th column of the matrix
!!         product A*P was the k-th column of A.
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A. This is
!!         defined as the order of the largest leading triangular
!!         submatrix R11 in the QR factorization of A, with pivoting,
!!         whose estimated condition number < 1/RCOND.
!!         Default value: 10*max(size(A,1),size(A,2))*BEPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      COMPLEX(WP), POINTER :: WORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
          LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF

        ALLOCATE(RWORK(2*N), STAT=ISTAT)
        IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, RWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE CGELSY_F95
SUBROUTINE CGERFS1_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(IN) :: A(:,:), AF(:,:)
   COMPLEX(WP), INTENT(IN) :: B(:)
   COMPLEX(WP), INTENT(INOUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: N, LINFO, ISTAT, ISTAT1, LD
   REAL(WP) :: LFERR, LBERR
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); ISTAT = 0; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N ) THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, 1, A, LD, AF, LD, IPIV, &
                    B, LD, X, LD, LFERR, LBERR, WORK, RWORK, LINFO )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGERFS1_F95
SUBROUTINE CGERFS_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN), TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(IN) :: A(:,:), AF(:,:), B(:,:)
   COMPLEX(WP), INTENT(INOUT) :: X(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GERFS improves the computed solution X of a system of linear
!! equations   A X = B  or  A^T X = B
!! and provides error bounds and backward error estimates for
!! the solution. LA_GERFS uses the LU factors computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GERFS (A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:), AF(:,:), <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    <type>(<wp>), INTENT(INOUT) :: <sol>
!!    REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!!    <sol>  ::= X(:,:) | X(:)
!!    <err>  ::= FERR(:), BERR(:) | FERR, BERR
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The original matrix A.
!
!! AF    (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(AF,1) == size(AF,2) == size(A,1).
!!       The factors L and U from the factorization A = PLU
!!       as computed by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       The right hand side vector(s) of matrix B for
!!       the system of equations AX = B.
!
!! X     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(X,1) or size(X) == size(A,1).
!!       On entry, the solution matrix X, as computed by LA_GETRS.
!!       On exit, the improved solution matrix X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!       of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! FERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(FERR) == size(X,2).
!!       The estimated forward error bound for each solution vector
!!       X(j) (the j-th column of the solution matrix X).
!!       If XTRUE is the true solution corresponding to X(j), FERR(j)
!!       is an estimated upper bound for the magnitude of the largest
!!       element in (X(j) - XTRUE) divided by the magnitude of the
!!       largest element in X(j).  The estimate is as reliable as
!!       the estimate for RCOND, and is almost always a slight
!!       overestimate of the true error.
!
!! BERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(BERR) == size(X,2).
!!       The componentwise relative backward error of each solution
!!       vector X(j) (i.e., the smallest relative change in
!!       any element of A or B that makes X(j) an exact solution).
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!
!! Internal Parameters
!! ===================
!
!! ITMAX is the maximum number of steps of iterative refinement.
!! It is set to 5 in the LAPACK77 subroutines
!! -----------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SFERR, SBERR
!!  .. LOCAL ARRAYS, POINTERS ..
   REAL(WP), POINTER :: RWORK(:)
   REAL(WP), POINTER :: LFERR(:), LBERR(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF ( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF ( SIZE(B, 1) /= N ) THEN; LINFO = -4
   ELSE IF ( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -7
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -8
   ELSE IF ( N > 0 ) THEN
      IF( .NOT.PRESENT(FERR) ) THEN
         ALLOCATE( LFERR(NRHS), STAT=ISTAT )
      ELSE; LFERR => FERR; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) ) THEN
            ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN; ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT ); END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, NRHS, A, MAX(1,N), AF, MAX(1,N), &
                         IPIV, B, MAX(1,N), X, MAX(1,N), LFERR, &
                         LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGERFS_F95
SUBROUTINE CGESDD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESDD_F77 => LA_GESDD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESDD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, JOBZ
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, S1U, S2U, S1VT, S2VT, &
&             MN, LRWORK
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLVT(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   COMPLEX(WP), ALLOCATABLE :: W1(:,:), W2(:,:)
   REAL(WP), POINTER :: RWORK(:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)

   IF( PRESENT(JOB) )THEN; LJOBZ = JOB; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF(.NOT. (LSAME(LJOBZ, "N") .OR. LSAME(LJOBZ,"U") .OR. LSAME(LJOBZ, "V"))) THEN ; LINFO = -6
   ELSE
        LWORK = MAX(1, 2*MN*MN+2*MN+MAX(M,N))
        LWORK = 5*LWORK

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF( ISTAT == 0 ) THEN
          ALLOCATE(IWORK(5*(8*MIN(M,N))), STAT=ISTAT)
          IF (ISTAT == 0 ) THEN
         LRWORK = (5*MIN(M,N)*MIN(M,N) + 7*MIN(M,N))
!! NEXT LINE SHOULD BE REMOVED WHEN LAPACK IS FIXED
         LRWORK = 5*LRWORK
         ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
         IF( ISTAT == 0 ) THEN
           IF (.NOT.PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
             ALLOCATE(W1(M,M), W2(N,N), STAT=ISTAT)
             IF (ISTAT == 0) THEN
               IF (.NOT. LSAME(LJOBZ, "N")) THEN
                 JOBZ = "S"
               ELSE
                 JOBZ = "N"
               ENDIF
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
               SELECT CASE(LJOBZ)
                 CASE ("U")
                   A(1:MN, 1:MN) = W1(1:MN, 1:MN)
                 CASE ("V")
                   A(1:MN, 1:MN) = W2(1:MN, 1:MN)
               END SELECT
               DEALLOCATE(W1, W2)
             ELSE
               LINFO = -100
             END IF
           ELSE IF (.NOT. PRESENT(U) .AND. PRESENT(VT)) THEN
             JOBZ = "A"
             ALLOCATE(W1(M,M), STAT=ISTAT)
             IF (ISTAT == 0) THEN
              IF (PRESENT (VT)) THEN
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                VT, MAX(1, S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
              ELSE
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                LLVT, MAX(1, S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
             ENDIF
               IF (LSAME(LJOBZ, "U")) THEN
                 A(1:M, 1:MN) = W1(1:M, 1:MN)
               END IF
               DEALLOCATE(W1)
             ELSE
               LINFO = -100
             END IF
           ELSE IF (PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
             JOBZ = "A"
             ALLOCATE(W2(N,N), STAT=ISTAT)
             IF (ISTAT == 0) THEN
              IF (PRESENT (U)) THEN
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
              ELSE
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
              ENDIF
               IF (LSAME(LJOBZ, "V")) A(1:MN, 1:N) = W2(1:MN, 1:N)
               DEALLOCATE(W2)
             ELSE
               LINFO = -100
             END IF
           ELSE
             JOBZ = "A"
             IF (PRESENT (VT)) THEN
               IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                    VT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                    VT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ENDIF
             ELSE
               IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                    LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                    LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ENDIF
             ENDIF
             IF (PRESENT(WW)) WW = WORK(1)
           ENDIF
           DEALLOCATE(RWORK, STAT=ISTAT)
         ELSE
           LINFO = -100
         END IF
         DEALLOCATE(IWORK, STAT=ISTAT)
       ELSE
         LINFO = -100
       END IF
       DEALLOCATE(WORK, STAT=ISTAT)
     ENDIF
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
    END SUBROUTINE CGESDD_F95
      SUBROUTINE CGESV1_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!     .. PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= SIZE(A,1) ) THEN; LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN; LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN; LPIV => IPIV
         ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
         IF ( ISTAT == 0 ) THEN
!!        .. CALL LAPACK77 ROUTINE ..
            CALL GESV_F77( SIZE(A,1), 1, A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)),         &
                           LINFO )
         ELSE; LINFO = -100; END IF
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE(LPIV, STAT = ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE CGESV1_F95
      SUBROUTINE CGESV_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. "Local Pointers" ..
      INTEGER, POINTER :: LPIV(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. "Test the arguments" ..
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN
         LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= SIZE(A,1) .OR. SIZE(B,2) < 0 ) THEN
         LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN
            LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN
            LPIV => IPIV
         ELSE
            ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT )
         END IF
         IF ( ISTAT == 0 ) THEN
!!        .. "Call LAPACK77 routine" ..
            CALL GESV_F77( SIZE(A,1), SIZE(B,2), A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)), &
                           LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            DEALLOCATE(LPIV, STAT = ISTAT1 )
         END IF
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE CGESV_F95
SUBROUTINE CGESVD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESVD_F77 => LA_GESVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOB
   CHARACTER(LEN=1) :: LJOBU, LJOBVT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, ISTAT1, S1U, S2U, S1VT, S2VT, &
              NN, MN, SWW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLVT(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)
   IF( PRESENT(JOB) )THEN; LJOB = JOB; ELSE; LJOB = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
   IF( PRESENT(WW) )THEN; SWW = SIZE(WW); ELSE; SWW = MN-1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF( SWW /= MN-1 .AND. MN > 0 ) THEN; LINFO = -5
   ELSE IF( PRESENT(JOB) .AND. ( .NOT. ( LSAME(LJOB,"U") .OR. &
            LSAME(LJOB,"V") .OR. LSAME(LJOB,"N") ) .OR. &
            LSAME(LJOB,"U") .AND. PRESENT(U) .OR. &
            LSAME(LJOB,"V") .AND. PRESENT(VT)) )THEN; LINFO = -6
   ELSE
      IF( PRESENT(U) )THEN
         IF( S2U == M )THEN; LJOBU = "A"; ELSE; LJOBU = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"U") ) THEN; LJOBU = "O"
         ELSE; LJOBU = "N"; ENDIF
      ENDIF
      IF( PRESENT(VT) )THEN
         IF( S1VT == N )THEN; LJOBVT = "A"; ELSE; LJOBVT = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"V") )THEN; LJOBVT = "O"
         ELSE; LJOBVT = "N"; ENDIF
      ENDIF
        ALLOCATE( RWORK( MAX(1, 5*MIN(M,N))), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
        LWORK = -1
        IF( PRESENT(U) ) THEN
        IF ( PRESENT(VT) )THEN
        CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
&             VT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ENDIF
         ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             VT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED
         LWORK = LWORK + 1
         ALLOCATE(WORK(LWORK), STAT = ISTAT)
         IF( ISTAT /= 0 )THEN
           DEALLOCATE(WORK,STAT=ISTAT1)
         NN = 2*MIN(M,N)+MAX(M,N)
         LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
          IF( PRESENT(U) ) THEN
            IF ( PRESENT(VT) )THEN
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
              VT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
            ELSE
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
&             LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
            ENDIF
          ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
&             VT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
&             LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = INT(WORK(1)+1)
         IF( LINFO > 0 .AND. PRESENT(WW) ) WW(1:MN-1) = RWORK(1:MN-1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGESVD_F95
      SUBROUTINE CGESVX1_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,    &
                              RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
      COMPLEX(WP), INTENT(OUT) :: X(:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SC, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), RWORK(:)
      COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
      ELSE; LEQUED="N"; END IF
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
      IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE; S1AF = N; S2AF = N; END IF
      IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
      ELSE; MVC = TINY(1.0_WP); END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B) /= N )THEN
         LINFO = -2
      ELSE IF( SIZE(X) /= N )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE
            LPIV => IPIV
         END IF
         IF( .NOT.PRESENT(R) )THEN
            ALLOCATE( LR(N), STAT=ISTAT )
         ELSE
            LR => R
         END IF
         IF( .NOT.PRESENT(C) )THEN
            ALLOCATE( LC(N), STAT=ISTAT )
         ELSE
            LC => C
         END IF
            ALLOCATE(WORK(2*N), RWORK(2*N), STAT=ISTAT )
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
         DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE CGESVX1_F95
      SUBROUTINE CGESVX_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,     &
                             RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: X(:,:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square matrix and X and B are rectangular matrices or vectors.
!!    LA_GESVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_GESVX ( A, B, X, AF=af, IPIV=ipiv, FACT=fact, &
!!                  TRANS=trans, EQUED=equed, R=r, C=c, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, RPVGRW=rpvgrw, &
!!                  INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, &
!!                                       TRANS
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: R(:), C(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A         (input/output) REAL or COMPLEX square array, shape (:,:).
!!           On entry, the matrix A or its equilibration:
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during a previous call
!!           to LA_GESVX.
!!           On exit, if FACT = "E", then the equilibrated version of A
!!           is stored in A; otherwise, A is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!           size(A,1) and size(X,2) = size(B,2), or shape (:) with
!!           size(X) = size(A,1).
!!           The solution matrix X .
!! AF        Optional (input or output) REAL or COMPLEX square array,
!!           shape (:,:) with the same size as A.
!!           If FACT = "F" then AF is an input argument that contains the
!!           factors L and U of (the equilibrated) A returned by a
!!           previous call to LA_GESVX.
!!           If FACT /= "F" then AF is an output argument that contains
!!           the factors L and U of (the equilibrated) A.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = size(A,1).
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A, returned by a previous call to LA_GESVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF and IPIV contain the factored form of (the
!!                 equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "R": Row equilibration, i.e., A has been premultiplied by
!!                 diag(R).
!!            = "C": Column equilibration, i.e., A has been postmultiplied
!!                 by diag(C).
!!            = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with size(R)
!!           = size(A,1). The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with size(C)
!!           = size(A,1). The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j) , FERR(j) is an
!!           estimated upper bound for the magnitude of the largest
!!           element in (X(j)-XTRUE) divided by the magnitude of the
!!           largest element in X(j). The estimate is as reliable as the
!!           estimate for RCOND and is almost always a slight
!!           overestimate of the true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any
!!           element of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition
!!           is indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!               <= n: U(i,i) = 0. The factorization has been completed,
!!                    but the factor U is singular, so the solution could
!!                  not be computed.
!!               = n+1: U is nonsingular, but RCOND is less than machine
!!                  precision, so the matrix is singular to working
!!                  precision. Nevertheless, the solution and error
!!                    bounds are computed because the computed solution
!!                  can be more accurate than the value of RCOND would
!!                  suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SBERR, SC, SFERR, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:), RWORK(:)
      COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
      LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN
         LFACT = FACT
      ELSE
         LFACT="N"
      END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN
         LEQUED = EQUED
      ELSE
         LEQUED="N"
      END IF
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = N
      END IF
      IF( PRESENT(AF) )THEN
         S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE
         S1AF = N; S2AF = N
      END IF
      IF( ( PRESENT(C) ) )THEN
         SC = SIZE(C)
      ELSE
         SC = N
      END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN
         MVC = MINVAL(C)
      ELSE
         MVC = TINY(1.0_WP)
      END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF( PRESENT(FERR) )THEN
         SFERR = SIZE(FERR)
      ELSE
         SFERR = NRHS
      END IF
      IF( PRESENT(BERR) )THEN
         SBERR = SIZE(BERR)
      ELSE
         SBERR = NRHS
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN
         LINFO = -2
      ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( SFERR /= NRHS )THEN
         LINFO = -11
      ELSE IF( SBERR /= NRHS )THEN
         LINFO = -12
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(IPIV) )THEN
               ALLOCATE( LPIV(N), STAT=ISTAT )
            ELSE
               LPIV => IPIV
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(R) )THEN
               ALLOCATE( LR(N), STAT=ISTAT )
            ELSE
               LR => R
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(C) )THEN
               ALLOCATE( LC(N), STAT=ISTAT )
            ELSE
               LC => C
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(FERR) )THEN
               ALLOCATE( LFERR(NRHS), STAT=ISTAT )
            ELSE
               LFERR => FERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(BERR) )THEN
               ALLOCATE( LBERR(NRHS), STAT=ISTAT )
            ELSE
               LBERR => BERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            ALLOCATE(WORK(2*N), RWORK(2*N), STAT=ISTAT )
         END IF
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
         IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE CGESVX_F95
      SUBROUTINE CGETRF_F95( A, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GETRF_F77 => LA_GETRF, LANGE_F77 => LA_LANGE, & !!((07-B-INT_LAPACK1.f90))
                                          GECON_F77 => LA_GECON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      COMPLEX(WP), INTENT( INOUT ) :: A( :, : )
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, M, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MAX, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      M = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0; MINMN = MIN(M,N)
      LD = MAX(1,M)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 .OR. PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -1
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -2
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -4
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( RWORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGE_F77( LNORM, MINMN, MINMN, A, LD, RWORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(RWORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GETRF_F77( M, N, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(2*MINMN), RWORK(2*MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GECON_F77( LNORM, MINMN, A, LD, LANORM, &
                                     RCOND, WORK, RWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE CGETRF_F95
SUBROUTINE CGETRI_F95( A, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRI_F77 => LA_GETRI, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRI computes the inverse of a matrix using the LU factorization
!! computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRI (A, IPIV, INFO)
!!    <type>(<wp>), INTENT(INOUT)  :: A(:,:)
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! =====================
!
!! A      (input/output) either REAL or COMPLEX square array, shape (:,:),
!!        size(A,1) == size(A,2).
!!        On entry contains the factors L and U from the factorization
!!           A = PLU as computed by LA_GETRF.
!!        On exit, if INFO = 0, the inverse of the original matrix A.
!
!! IPIV   (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!        The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i of
!!        the matrix was interchanged with row IPIV(i).
!
!! INFO   Optional (output) INTEGER.
!!        If INFO is present
!!           = 0: successful exit
!!           < 0: if INFO = -k, the k-th argument had an illegal value
!!           > 0: if INFO = k, U(k,k) is exactly zero.  The matrix is
!!               singular and its inverse could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!           terminated with an error message.
!-----------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRI"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CGETRI"
!!  .. LOCAL SCALARS ..
   INTEGER    :: LINFO, N, LD, LWORK, ISTAT, ISTAT1, NB
!!  .. LOCAL ARRAY ..
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LINFO = 0; LD = MAX(1,N); ISTAT = 0
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N )THEN; LINFO = -2
   ELSE IF( N > 0 )THEN
!!     DETERMINE THE WORK SPACE.
      NB = ILAENV_F77( 1, BSNAME, " ", N, -1, -1, -1 )
      IF( NB < 1 .OR. NB >= N )THEN; NB = 1; END IF
      LWORK = MAX( N*NB, 1 )
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = MAX(1,N); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( LINFO == 0 )THEN
         CALL GETRI_F77( N, A, LD, IPIV, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGETRI_F95
SUBROUTINE CGETRS1_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE CGETRS1_F95
SUBROUTINE CGETRS_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRS solves a system of linear equations
!!    A X = B, A^T X = B or  A^H X = B
!! with a general square matrix A using the LU factorization computed
!! by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRS (A, IPIV, B, TRANS, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:)
!!    <type>(<wp>), INTENT(INOUT) :: <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The factors L and U from the factorization A = PLU as computed
!!       by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       On entry, the right hand side vector(s) of matrix B for
!!          the system of equations AX = B.
!!       On exit, if there is no error, the matrix of solution
!!          vector(s) X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!          of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!---------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = SIZE(B,2); LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B, 1 ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE CGETRS_F95
       SUBROUTINE CGGES_F95( A, B, ALPHA, BETA, VSL, VSR, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  SP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGES_F77 => LA_GGES                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT( ALPHA, BETA)
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      COMPLEX(WP), INTENT(IN) :: ALPHA, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGES computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!
!! =========
!!
!!           SUBROUTINE LA_GGES( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGES for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGES"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHA, SBETA
      INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
        REAL(WP), POINTER :: RWORK(:)
      LOGICAL, POINTER :: BWORK(:)
      LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHA = SIZE(ALPHA)
   IF (PRESENT (SELECT)) THEN
      LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
       ELSE IF( SALPHA /= N )THEN; LINFO = -3
       ELSE IF( SBETA /= N )THEN; LINFO = -4
       ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N) )THEN; LINFO = -5
       ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6

       ELSE IF( N >= 0 )THEN
       IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 500; ENDIF
       ELSE; BWORK => LLBWORK; END IF

       ALLOCATE(RWORK(8*N), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
        LWORK = -1
        IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ELSE
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VSR) )THEN
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ELSE
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ENDIF
         ENDIF
        LWORK = WORKMIN(1)

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 400; ENDIF

        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
          IF (PRESENT(SDIM)) SDIM = LSDIM

          DEALLOCATE(WORK)
400       DEALLOCATE(RWORK)
100       IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK)
        ENDIF
500     CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGGES_F95
SUBROUTINE CGGESX_F95( A, B,  ALPHA, &
&   BETA, VSL, VSR, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGESX_F77 => LA_GGESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: RCONDE(2), RCONDV(2)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT(ALPHA, BETA)
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      COMPLEX(WP), INTENT(IN) :: ALPHA, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGESX computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       LA_GGESX also computes two reciprocal condition numbers for the
!! average of the selected eigenvalues and reciprocal condition numbers
!! for the right and left deflating subspaces corresponding to the
!! selected eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_GGESX( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim,
!!                      RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE(2), RCONDV(2)
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGESX for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE)=2.
!!          The reciprocal condition numbers for the average of the
!!          selected eigenvalues.
!! RCONDV   Optional (output) REAL array, shape (:) with size(RCONDV)=2.
!!          The reciprocal condition numbers for the left and right
!!          deflating subspaces corresponding to the selected
!!          eigenvalues.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHA, SBETA, LIWORK
   INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), TARGET :: LLRCONDE(2), LLRCONDV(2)
   COMPLEX(WP), POINTER :: WORK(:)
   LOGICAL, POINTER :: BWORK(:)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHA = SIZE(ALPHA)
   IF  (PRESENT (SELECT)) THEN
     LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
     ELSE IF( SALPHA /= N )THEN; LINFO = -3
     ELSE IF( SBETA /= N )THEN; LINFO = -4
     ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -5
     ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6

   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-101; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      ALLOCATE(RWORK(8*N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-103; GOTO 300; ENDIF

      IF ( LSAME (LSENSE, "N")) THEN
        LWORK =  2 * N
      ELSE
        LWORK = MAX( 2*N, N*N/2+1 )
      ENDIF
      ALLOCATE (WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-105; GOTO 500; ENDIF
      LIWORK = N+2
      ALLOCATE (IWORK(LIWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-106; GOTO 600; ENDIF

        IF (PRESENT (RCONDV)) THEN
          IF (PRESENT(RCONDE)) THEN
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ELSE
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT(RCONDE)) THEN
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ELSE
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        IF (PRESENT(SDIM)) SDIM = LSDIM

        DEALLOCATE(IWORK, STAT=ISTAT)
600     DEALLOCATE(WORK, STAT=ISTAT)
500     DEALLOCATE(RWORK, STAT=ISTAT)
300     IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK, STAT=ISTAT)

    ENDIF
100   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGGESX_F95
      SUBROUTINE CGGEV_F95( A, B, ALPHA, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEV_F77 => LA_GGEV                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
       COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!! LA_GGEV computes for a pair of n by n real or complex matrices (A,B)
!! the generalized eigenvalues in the form of scalar pairs (alpha, beta)
!! and, optionally, the left and/or right generalized eigenvectors.
!!       A generalized eigenvalue of the pair (A,B) is, roughly
!! speaking, a scalar of the form  lambda=alpha/beta such that the matrix
!! A-lambda*B is singular. It is usually represented as the pair
!! (alpha; beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector v such that (A-lambda*B)*v=0. A left
!! generalized eigenvector is a vector u such that u^H*(A-lambda*B)=0,
!! where u^H is the conjugate-transpose of u.
!!       The computation is based on the (generalized) real or complex
!! Schur form of (A,B). (See LA_GGES for details of this form.)
!!
!! =========
!!
!!     SUBROUTINE LA_GGEV( A, B, <alpha>, BETA, VL=vl, &
!!                 VR=vr, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!         <type>     ::= REAL | COMPLEX
!!         <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!         <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!         <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B.
!!         On exit, B has been destroyed.
!! <alpha> (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!         size(A,1).
!!         The values of alpha.
!!         alpha(:) ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!         where
!!         ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!         imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA    (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!         size(A,1).
!!         The values of beta.
!!         Note: The generalized eigenvalues of the pair (A,B) are the
!!         scalars lambda(j)=alpha(j)/beta(j). These quotients may easily
!!         over- or underflow, and beta(j) may even be zero. Thus, the
!!         USEr should avoid computing them naively.
!!         Note: If A and B are real then complex eigenvalues occur in
!!         complex conjugate pairs. Each pair is stored consecutively.
!!         Thus a complex conjugate pair is given by
!!             lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!             lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!         where
!!             ALPHAI(j)/BETA(j) = -(ALPHAI(j+1)/BETA(j+1))
!! VL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VL,1) = size(A,1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag:part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!            <= n: The QZ iteration failed. No eigenvectors have been
!!                  calculated, but (alpha(j), BETA(j)) should be
!!                  correct for j = INFO+1, ..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: a failure occurred during the computation of the
!!                  generalized eigenvectors.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------

!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGEV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
     REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHA = SIZE(ALPHA)
   SBETA = SIZE(BETA)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2

       ELSE IF( SALPHA /= N )THEN; LINFO = -3
       ELSE IF( SBETA /= N )THEN; LINFO = -4
       ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
       ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
       ELSE IF( N > 0 )THEN

       ALLOCATE(RWORK(8*N),STAT=ISTAT)
       IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 200; ENDIF

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
         IF (PRESENT (VR)) THEN
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, VL, S1VL, VR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ELSE
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, VL, S1VL, LLVR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ENDIF
       ELSE
         IF (PRESENT (VR)) THEN
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, LLVL, S1VL, VR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ELSE
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, LLVL, S1VL, LLVR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ENDIF
       ENDIF
      LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
         IF (PRESENT (VR)) THEN
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, VL, S1VL, VR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ELSE
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ENDIF
      ELSE
         IF (PRESENT (VR)) THEN
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ELSE
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      DEALLOCATE(WORK)
200  DEALLOCATE(RWORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGGEV_F95
      SUBROUTINE CGGEVX_F95( A, B, ALPHA, BETA, VL, VR, &
     &  BALANC, ILO, IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEVX_F77 => LA_GGEVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: ILO,IHI
      REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!  .. ARRAY ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: LSCALE(:), RSCALE(:), &
     &  RCONDE(:), RCONDV(:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGEVX computes for a pair of n-by-n real or complex matrices
!! (A, B) the generalized eigenvalues in the form of scalar pairs
!! (alpha; beta) and, optionally, the left and/or right generalized
!! eigenvectors.
!!      A generalized eigenvalue of the pair (A; B) is, roughly speaking,
!! a scalar of the form lambda = alpha / beta such that the matrix
!! A - lambda * B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!      A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector  v  such that ( A - lambda*B)* v = 0.
!! A left generalized eigenvector is a vector u such that
!! u^H*(A-lambda*B) = 0, where u^H is the conjugate-transpose of u.
!!      The computation is based on the (generalized) real or complex
!! Schur form of (A, B). (See LA_GGES for details of this form.)
!!      Optionally, LA_GGEVX also computes a balancing transformation
!! (to improve the conditioning of the eigenvalues and eigenvectors),
!! reciprocal condition numbers for the eigenvalues, and reciprocal
!! condition numbers for the right eigenvectors. The balancing
!! transformation consists of a permutation of rows and columns and/or a
!! scaling of rows and columns.
!!
!! ==========
!!
!!    SUBROUTINE LA_GGEVX( A, B, <alpha>, BETA, VL=vl, &
!!          VR=vr, BALANC=balanc, ILO=ilo, IHI=ihi, &
!!          LSCALE=lscale, RSCALE=rscale, ABNRM=abnrm, &
!!          BBNRM=bbnrm, RCONDE=rconde, RCONDV=rcondv, &
!!          INFO=info )
!!        <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!        <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!        <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!        CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!        INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: LSCALE(:),
!!             RSCALE(:), RCONDE(:), RCONDV(:)
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!        INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!        <type>     ::= REAL | COMPLEX
!!        <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!        <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!        <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:, :).
!!          On entry, the matrix A.
!!          On exit, A has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then A contains
!!          the first part of the real/complex Schur form of the
!!          "balanced" versions of the matrix pair (A, B).
!! B        (input/output) REAL or COMPLEX square array, shape (:, :)
!!          with size(B, 1) = size(A, 1).
!!          On entry, the matrix B.
!!          On exit, B has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then B contains
!!          the second part of the real/complex Schur form of the "bal-
!!          anced" versions of the matrix pair (A, B).
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with
!!          size(<alpha>) = size(A, 1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) |  ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with
!!          size(BETA) = size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A, B) are the
!!          scalars lambda(j) = alpha(j) / beta(j) . These quotients
!!          may easily over- or underflow, and beta(j) may even be zero.
!!          Thus, the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!                 lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!                 lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!              ALPHAI(j)/BETA(j)= - (ALPHAI(j+1)/BETA(j+1))
!! VL       Optional (output) REAL or COMPLEX square array, shape (:, :)
!!          with  size(VL, 1) = size(A, 1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!         | realpart | + | imag.part | = 1,except that for eigenvalues
!!         with alpha = beta = 0, a zero vector is returned as the
!!         corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC  Optional (input) CHARACTER(LEN=1).
!!         Specifies the balance option to be performed.
!!            = "N": do not permute or scale;
!!            = "P": permute only;
!!            = "S": scale only;
!!            = "B": both permute and scale.
!!         Default value: "N".
!!         Note: Computed reciprocal condition numbers will be for the
!!         matrices after balancing. Permuting does not change condition
!!         numbers (in exact arithmetic), but scaling does.
!! ILO,IHI Optional (output) INTEGER.
!!         ILO and IHI are integer values such that on exit A(i,j) = 0
!!         and B(i,j) = 0 if i > j and j =1,...,ILO-1 or
!!         i = IHI+1,...,n.
!!         If BALANC = "N" or "S", then ILO = 1 and IHI = n.
!! LSCALE  Optional (output) REAL array, shape (:) with size(LSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to
!!         the left side of A and B. If PL(j) is the index of the row
!!         interchanged with row j, and DL(j) is the scaling factor
!!         applied to row j, then
!!                 PL(j) = LSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!               DL(j) = LSCALE(j),  j = ILO, ..., IHI
!! RSCALE  Optional (output) REAL array, shape (:), size(RSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to the
!!         right side of A and B. If PR(j) is the index of the column
!!         interchanged with column j, and DR(j) is the scaling factor
!!         applied to column j, then
!!                PR(j) = RSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!                DR(j) = RSCALE(j),  j = ILO, ..., IHI
!! ABNRM   Optional (output) REAL.
!!         The l1 norm of A after balancing.
!! BBNRM   Optional (output) REAL.
!!         The l 1 norm of B after balancing.
!! RCONDE  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The reciprocal condition numbers of the eigenvalues.
!! RCONDV  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The estimated reciprocal condition numbers of the right
!!         eigenvectors. If the eigenvalues cannot be reordered to
!!         compute RCONDV(j) then RCONDV(j) is set to 0. This can only
!!         occur when the true value would be very small.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!           <= n: The QZ iteration failed. No eigenvectors have been
!!                 calculated, but (alpha(j) , BETA(j) ) should be
!!          correct for j = INFO + 1,..., n.
!!             = n+1: another part of the algorithm failed.
!!             = n+2: a failure occurred during the computation of the
!!                 generalized eigenvectors.
!!         If INFO is not present and an error occurs, then the program
!!       is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGEVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR, LBALANC, LSENSE
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHA, SBETA, LILO, LIHI, SRCONDE, SRCONDV, SLSCALE, SRSCALE
      REAL(WP) :: LABNRM, LBBNRM
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: LRCONDE(:), LRCONDV(:), LLSCALE(:), LRSCALE(:)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
      INTEGER, POINTER :: IWORK(:)
      LOGICAL, POINTER :: BWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHA = SIZE(ALPHA); SBETA = SIZE(BETA)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(LSCALE) )THEN; SLSCALE = SIZE(LSCALE); ELSE; SLSCALE = N; ENDIF
   IF( PRESENT(RSCALE) )THEN; SRSCALE = SIZE(RSCALE); ELSE; SRSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
     &  LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -7
   ELSE IF( SLSCALE /= N )THEN; LINFO = -10
   ELSE IF( SRSCALE /= N )THEN; LINFO = -11
   ELSE IF( SRCONDE /= N )THEN; LINFO = -14
   ELSE IF( SRCONDV /= N )THEN; LINFO = -15
   ELSE IF( N > 0 )THEN
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF

      ALLOCATE(RWORK(6*N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1100; ENDIF

      ALLOCATE(BWORK(N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1000; ENDIF

      ALLOCATE(IWORK(N+6), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 900; ENDIF

      IF( PRESENT(LSCALE) )THEN; LLSCALE => LSCALE
      ELSE; ALLOCATE( LLSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 800; ENDIF
      END IF

      IF( PRESENT(RSCALE) )THEN; LRSCALE => RSCALE
      ELSE; ALLOCATE( LRSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 700; ENDIF
      END IF

      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 600; ENDIF
      END IF

      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 500; ENDIF
      END IF

      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
      ENDIF
!! NEXT LINE SHOULD BE LWORK = WORKMIN(1)
      LWORK = 5*WORKMIN(1)

      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO
      IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( PRESENT(BBNRM) ) BBNRM = LBBNRM

      DEALLOCATE(WORK)
100  IF (.NOT. PRESENT(RCONDE)) DEALLOCATE(LRCONDE)
500  IF (.NOT. PRESENT(RCONDV)) DEALLOCATE(LRCONDV)
600  IF (.NOT. PRESENT(RSCALE)) DEALLOCATE(LRSCALE)
700  IF (.NOT. PRESENT(LSCALE)) DEALLOCATE(LLSCALE)
800  DEALLOCATE (IWORK)
900  DEALLOCATE (BWORK)
1000  DEALLOCATE (RWORK)
     ENDIF
1100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGGEVX_F95
SUBROUTINE CGGGLM_F95( A, B, D, X, Y, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGGLM_F77 => LA_GGGLM                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:), D(:)
    COMPLEX(WP), INTENT(OUT) :: X(:), Y(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GGGLM solves the general (Gauss-Markov) linear model (GLM)
!! problem:
!!      min ||y||2  subject to d=A*x + B*y
!!       x
!! where A and B are real or complex rectangular matrices and d is a real
!! or complex vector. Further, A is n by m, B is n by p, and d is n by 1,
!! and it is assumed that m <= n <= m+p, rank(A) = m, rank(A, B) = n.
!! These conditions ensure that the GLM problem has unique solution
!! vectors x and y. The problem is solved using the generalized QR
!! factorization of A and B.
!!        If matrix B is square and nonsingular, then the GLM problem is
!! equivalent to the weighted linear least squares problem
!!         min ||B^-1 * (d-A*x)||2
!!          x
!!
!! =========
!!
!!       SUBROUTINE LA_GGGLM( A, B, D, X, Y, INFO=info )
!!           <type>(<wp>), INTENT( INOUT ) :: A( :, : ), B(:,:), D(:)
!!           <type>(<wp>), INTENT( OUT ) :: X(:), Y(:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(A,1) = n and size(A,2) = m.
!!       On entry, the matrix A.
!!       On exit, the contents of A are destroyed.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n and size(B,2) = p.
!!       On entry, the matrix B.
!!       On exit, the contents of B are destroyed.
!! D     (input/output) REAL or COMPLEX array, shape (:) with
!!       size(D) = n.
!!       On entry, the vector d.
!!       On exit, the contents of D are destroyed.
!! X     (output) REAL or COMPLEX array, shape (:) with size(X) = m.
!!       The solution vector x.
!! Y     (output) REAL or COMPLEX array, shape (:) with size(Y) = p.
!!       The solution vector y.
!! INFO  Optional (output) INTEGER.
!!       = 0: successful exit
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGGLM"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); M = SIZE(A,2); P = SIZE(B,2)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < M ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P < N-M .OR. SIZE(B,1) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(D) /= N ) THEN; LINFO = -3
    ELSE IF( SIZE(X) /= M ) THEN; LINFO = -4
    ELSE IF( SIZE(Y) /= P ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGGLM_F77( N, M, P, A, MAX(1,N), B, MAX(1,N), &
                          D, X, Y, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT( WORK(1) )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGGGLM_F95
SUBROUTINE CGGLSE_F95( A, B, C, D, X, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGLSE_F77 => LA_GGLSE                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:), C(:), D(:)
    COMPLEX(WP), INTENT(OUT) :: X(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GGLSE solves the linear equality-constrained least squares
!! (LSE) problem:
!!      min || c - A*x||2 subject to B*x = d,
!! where A and B are real or complex rectangular matrices and c and d are
!! real or complex vectors. Further, A is m by n, B is p by n, c is m by 1
!! and d is p by 1, and it is assumed that
!!       p <= n <=  m + p, rank(B) = p,  rank [ A ] = n.
!!                                            [ B ]
!! These conditions ensure that the LSE problem has a unique solution x.
!! This is obtained using the generalized RQ factorization of the matrices
!! B and A.
!!
!! =========
!!
!!        SUBROUTINE LA_GGLSE( A, B, C, D, X, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A(:,:), B(:,:), C(:), D(:)
!!          <type>(<wp>), INTENT( OUT ) :: X(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(A,1) = m and size(A,2) = n.
!!         On entry, the matrix A.
!!         On exit, the contents of A are destroyed.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = p and size(B,2) = n.
!!         On entry, the matrix B.
!!         On exit, the contents of B are destroyed.
!! C       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(C) = m.
!!         On entry, the vector c.
!!         On exit, the residual sum of squares for the solution is given
!!         by the sum of squares of elements n-p+1 to m.
!! D       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(D) = p.
!!         On entry, The vectors d.
!!         On exit, the contents of D are destroyed.
!! X       (output) REAL or COMPLEX array, shape (:) with size(X) = n.
!!         The solution vector x.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGLSE"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P > N .OR. P < N-M .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(C) /= M ) THEN; LINFO = -3
    ELSE IF( SIZE(D) /= P ) THEN; LINFO = -4
    ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGLSE_F77( M, N, P, A, MAX(1,M), B, MAX(1,P), &
                          C, D, X, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT(WORK(1))
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CGGLSE_F95
SUBROUTINE CGGSVD_F95( A, B, ALPHA, BETA, K, L, U, V, Q, IWORK, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGSVD_F77 => LA_GGSVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, K, L
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), V(:,:), Q(:,:)
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IWORK(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGSVD computes the generalized singular values and, optionally,
!! the transformation matrices from the generalized singular value
!! decomposition (GSVD) of a real or complex matrix pair (A,B), where A
!! is m by n and B is p by n. The GSVD of (A,B) is written
!!       A = U * SIGMA1(0, R)*Q^H , B = V * SIGMA2(0, R)*Q^H
!! where U , V and Q are orthogonal (unitary) matrices of dimensions m by m,
!! p by p and n by n, respectively. Let l be the rank of B and r the rank of
!! the (m + p) * n matrix ( A )
!!                        ( B )
!! , and let k = r-l. Then SIGMA1 and SIGMA2 are m*(k + l) and p * (k + l)
!! "diagonal" matrices, respectively, and R is a (k + l) * (k + l)
!! nonsingular triangular matrix. The detailed structure of SIGMA1 ,SIGMA2
!! and R depends on the sign of (m - k - l) as follows:
!!       The case m-k-l>=0:
!!
!!                               k   l
!!                      k      ( I   0 )
!!        SIGMA1 =      l      ( 0   C )
!!                    m-k-l    ( 0   0 )
!!
!!
!!                           k   l
!!       SIGMA2 =    l   ( 0   S )
!!                 p - l ( 0   S )
!!
!!
!!                          n-k-l   k     l
!!          (0, R) =   k   (  0    R11   R12  )
!!                     l   (  0     0    R22  )
!!
!! where C^2 + S^2 = I . We define
!! alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i=1,2,...,l
!! beta(1) = beta(2) = ... = beta(k) = 0, beta(k+i) = s(i i), i=1,2,...,l
!!
!! The case m-k-l < 0:
!!
!!                                k    m-k    k+l-m
!!            SIGMA1 =    k    (  I     0       0   )
!!                       m-k   (  0     C       0   )
!!
!!
!!                              k    m-k     k+l-m
!!                        m-k   ( 0     S        0  )
!!            SIGMA2 =   k+l-m  ( 0     0        I  )
!!                        p-l   ( 0     0        0  )
!!
!!
!!                                  n-k-l    k     m-k   k+l-m
!!                         k      (   0     R11    R12    R13  )
!!              (0,R) =   m-k     (   0      0     R22    R23  )
!!                       k+l-m    (   0      0      0     R33  )
!!
!! where C^2 + S^2 = I . We define
!!  alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i =1,2,...,m-k,
!!  alpha(m+1) = alpha(m+2)=...= alpha(k+l) = 0
!!  beta(1)=beta(2)= ... =beta(k)=0, beta(k+i)=s(i i), i=1,2,...,m-k,
!!  beta(m+1) = beta(m+2) = ... = beta(k+l) = 1
!!
!! In both cases the generalized singular values of the pair (A,B) are the
!! ratios
!!  sigma(i) = alpha(i)/beta(i), i = 1,2, ... ,k+l
!!
!! The first k singular values are infinite. The finite singular values
!! are real and nonnegative.
!!     LA_GGSVD computes the real (nonnegative) scalars alpha(i), beta(i),
!! i=1,2,..., k+l , the matrix R, and, optionally, the transformation
!! matrices U , V and Q.
!!
!! =========
!!
!!      SUBROUTINE LA_GGSVD( A, B, ALPHA, BETA, K=k, L=l, &
!!                       U=u, V=v, Q=q, IWORK=iwork, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: ALPHA(:), BETA(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: K, L
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), V(:,:), Q(:,:)
!!          INTEGER, INTENT(IN), OPTIONAL :: IWORK(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(A,1) = m and size(A,2) = n.
!!        On entry, the matrix A.
!!        On exit, A contains the triangular matrix R, or part of R, as
!!        follows:
!!        If m-k-l >= 0, then R is stored in A(1:k+l,n-k-l+1:n).
!!        If m-k-l < 0, then the matrix
!!                  ( R11     R12    R13 )
!!                (  0      R22    R23 )
!!        is stored in A(1:m,n-k-l+1:n).
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = p and size(B,2) = n.
!!        On entry, the matrix B.
!!        On exit, if m-k-l < 0, then R33 is stored in
!!        B(m-k+1:l,n+m-k-l+1:n).
!! ALPHA  (output) REAL array, shape (:) with size(ALPHA) = n
!!        The real scalars alpha(i) , i = 1, 2,..., k+l.
!! BETA   (output) REAL array, shape (:) with size(BETA) = n.
!!        The real scalars beta(i) , i = 1, 2, ..., k+l.
!!        Note: The generalized singular values of the pair (A,B) are
!!        sigma(i) = ALPHA(i)/BETA(i), i = 1, 2, ...,  k+l.
!!        If k + l < n, then ALPHA(k+l+1:n) = BETA(k+l+1:n) = 0.
!! K, L   Optional (output) INTEGER.
!!        The dimension parameters k and l.
!! U      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(U,1) = m.
!!        The matrix U .
!! V      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(V,1) = p.
!!        The matrix V .
!! Q      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Q,1) = n.
!!        The matrix Q.
!! IWORK  Optional (output) INTEGER array, shape(:) with size(IWORK) = n.
!!        IWORK contains sorting information. More precisely, the loop
!!             for i = k + 1, min(m, k + l)
!!                   swap ALPHA(i) and ALPHA(IWORK(i))
!!             end
!!        will sort ALPHA so that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(n).
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = 1, the algorithm failed to converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGSVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBU, LJOBV, LJOBQ
   INTEGER :: M, N, P, LINFO, ISTAT, ISTAT1, S1U, S2U, S1V, S2V, &
              S1Q, S2Q, LK, LL
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLV(1,1), LLQ(1,1)
   INTEGER, POINTER :: LIWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2); LJOBU = "U"
   ELSE; S1U = 1; S2U = 1; LJOBU = "N"; END IF
   IF( PRESENT(V) )THEN; S1V = SIZE(V,1); S2V = SIZE(V,2); LJOBV = "V"
   ELSE; S1V = 1; S2V = 1; LJOBV = "N"; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2); LJOBQ = "Q"
   ELSE; S1Q = 1; S2Q = 1; LJOBQ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < N )THEN; LINFO = -1
   ELSE IF( SIZE(B,2) /= N .OR. P < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( ALPHA ) /= N )THEN; LINFO = -3
   ELSE IF( SIZE( BETA ) /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(U) .AND. ( S1U /= MAX(1,M) .OR.  S2U /= M ) )THEN; LINFO = -7
   ELSE IF( PRESENT(V) .AND. ( S1V /= MAX(1,P) .OR.  S2V /= P ) )THEN; LINFO = -8
   ELSE IF( PRESENT(Q) .AND. ( S1Q /= MAX(1,N) .OR.  S2Q /= N ) )THEN; LINFO = -9
   ELSE
    IF (PRESENT(IWORK)) THEN
      LIWORK => IWORK
    ELSE
      ALLOCATE( LIWORK(MAX(1,N)), STAT=ISTAT )
    ENDIF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( RWORK(MAX(1,2*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( WORK( MAX(1,MAX(3*N,M,P)+N) ), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(U) )THEN
           IF( PRESENT(V) )THEN
             IF( PRESENT(Q) )THEN
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ELSE
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ENDIF
               ELSE
                IF( PRESENT(Q) )THEN
                   CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ELSE
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ENDIF
               ENDIF
               ELSE
                 IF( PRESENT(V) )THEN
                   IF( PRESENT(Q) )THEN
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ELSE
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ENDIF
                  ELSE
                   IF( PRESENT(Q) )THEN
                      CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ELSE
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ENDIF
                  ENDIF
                 ENDIF
         IF( PRESENT(K) ) K = LK
         IF( PRESENT(L) ) L = LL
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
      IF (.NOT. PRESENT(IWORK)) DEALLOCATE(LIWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CGGSVD_F95
 SUBROUTINE CGTSV1_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, 1, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CGTSV1_F95
 SUBROUTINE CGTSV_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GTSV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square tridiagonal matrix and X and B
!! are rectangular matrices or vectors. The LU decomposition is used to
!! factor the matrix A as A = L*U , where L is a product of permutation
!! and unit lower bidiagonal matrices and U is upper triangular with
!! nonzeros in only the main diagonal and first two superdiagonals.
!! The factored form of A is then used to solve the above system.
!!
!! Note: The system A^T*X = B may be solved by interchanging the order of
!! the arguments DU and DL.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSV( DL, D, DU, B, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: DL(:), D(:), DU(:), <rhs>
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs> ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! DL    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1, where n is the order of A.
!!       On entry, the subdiagonal of A.
!!       On exit, the n-2 elements of the second superdiagonal of U in
!!       DL(1),..., DL(n-2).
!! D     (input/output) REAL or COMPLEX array, shape (:) with size(D) = n.
!!       On entry, the diagonal of A.
!!       On exit, the diagonal of U .
!! DU    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1.
!!       On entry, the superdiagonal of A.
!!       On exit, the first superdiagonal of U .
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n or shape (:) with size(B) = n.
!!       On entry, the matrix B.
!!       On exit, the solution matrix X .
!! INFO  Optional (output) INTEGER
!!       = 0: successful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, then U(i,i) = 0. The factorization has not been
!!       completed unless i = n. The factor U is singular, so the solution
!!       could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, NRHS, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CGTSV_F95
SUBROUTINE CGTSVX1_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                            IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0 ) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, 1, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGTSVX1_F95
SUBROUTINE CGTSVX_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                           IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GTSVX computes the solution to a real or complex linear system
!! of equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square tridiagonal matrix and X and B are rectangular matrices or
!! vectors.
!!     LA_GTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSVX( DL, D, DU, B, X, DLF=dlf, DF=df, DUF=duf, &
!!               DU2=du2, IPIV=ipiv, FACT=fact, TRANS=trans, FERR=ferr, &
!!               BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(IN) :: DL(:), D(:), DU(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: DLF(:), DF(:), &
!!                                                   DUF(:), DU2(:)
!!           INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, TRANS
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! DL     (input) REAL or COMPLEX array, shape (:) with size(DL) = n-1.
!!        The subdiagonal of A.
!! D      (input) REAL or COMPLEX array, shape (:) with size(D) = n.
!!        The diagonal of A.
!! DU     (input) REAL or COMPLEX array, shape (:) with size(DU) = n-1.
!!        The superdiagonal of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        The matrix B.
!! X      (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!        and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!        The solution matrix X .
!! DLF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DLF)= n-1.
!!        If FACT = "F" then DLF is an input argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!!        If FACT = "N" then DLF is an output argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!! DF     Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DF)= n.
!!        If FACT = "F" then DF is an input argument that contains the
!!        diagonal of the matrix U .
!!        If FACT = "N" then DF is an output argument that contains the
!!        diagonal of the matrix U .
!! DUF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DUF) = n-1.
!!        If FACT = "F" then DUF is an input argument that contains the
!!        first superdiagonal of U.
!!        If FACT = "N" then DUF is an output argument that contains the
!!        first superdiagonal of U.
!! DU2    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DU2) = n-2.
!!        If FACT = "F", then DU2 is an input argument that contains the
!!        second superdiagonal of U.
!!        If FACT = "N", then DU2 is an output argument that contains the
!!        second superdiagonal of U.
!! IPIV   Optional (input or output) INTEGER array, shape (:) with
!!        size(IPIV) = n.
!!        If FACT = "F" then IPIV is an input argument that contains the
!!        pivot indices from the LU factorization of A.
!!        If FACT = "N", then IPIV is an output argument that contains the
!!        pivot indices from the LU factorization of A; row i of the
!!        matrix was interchanged with row IPIV(i). IPIV(i) will always
!!        be either i or i+1; IPIV(i) = i indicates a row interchange was
!!        not required.
!! FACT   Optional (input) CHARACTER(LEN=1).
!!        Specifies whether the factored form of A is supplied on entry.
!!            = "N": The matrix will be copied to DLF, DF and DUF and
!!                 factored.
!!            = "F": DLF, DF, DUF, DU2 and IPIV contain the factored form
!!                 of A.
!!        Default value: "N".
!! TRANS  Optional (input) CHARACTER(LEN=1).
!!        Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!!        Default value: "N".
!! FERR   Optional (output) REAL array of shape (:), with size(FERR) =
!!        size(X,2), or REAL scalar.
!!        The estimated forward error bound for each solution vector X(j)
!!        (the j-th column of the solution matrix X). If XTRUE is the true
!!        solution corresponding to X(j) , FERR(j) is an estimated upper
!!        bound for the magnitude of the largest element in (X(j)-XTRUE)
!!        divided by the magnitude of the largest element in X(j). The
!!        estimate is as reliable as the estimate for RCOND and is almost
!!        always a slight overestimate of the true error.
!! BERR   Optional (output) REAL array of shape (:), with size(BERR) =
!!        size(X,2), or REAL scalar.
!!        The componentwise relative backward error of each solution
!!        vector X(j) (i.e.,the smallest relative change in any element of
!!        A or B that makes X(j) an exact solution).
!! RCOND  Optional (output) REAL.
!!        The estimate of the reciprocal condition number of the matrix A.
!!        If RCOND is less than the machine precision, the matrix is
!!        singular to working precision. This condition is indicated by
!!        a return code of INFO > 0.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, and i is
!!           <= n: U(i,i) = 0. The factorization has not been completed
!!               unless i = n. The factor U is singular, so the solution
!!               could not be computed.
!!           = n+1: U is nonsingular, but RCOND is less than machine
!!               precision, meaning that the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!                 error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2, &
              SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  PRINT *, LINFO, ISTAT, N, NRHS, LFACT, SIPIV, SDLF, SDF, SDUF, SDU2, SFERR, SBERR, LTRANS
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0) THEN; LINFO = -3
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -4
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -13
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -14
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, NRHS, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CGTSVX_F95
SUBROUTINE CHBEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBEV_F77 => LA_HBEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HBEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,N)), RWORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
            CALL HBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, RWORK, LINFO )
         ELSE
            CALL HBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, RWORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHBEV_F95
SUBROUTINE CHBEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBEVD_F77 => LA_HBEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LRWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0, &
                    LRWORKN = 0, LRWORKV = 0
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1)); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
         LRWORK = MAX( 1, N, LIWORKN )
      ELSE
         LWORK = MAX( 1, 2*N**2, LWORKV )
         LRWORK = MAX(1+5*N+2*N**2, LWORKV)
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, RWORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX(1,N)
            LRWORK = MAX(1,N); LIWORK = 1
         ELSE; LRWORK = 1+5*N+2*N**2
           LWORK = MAX(1, 2*N**2); LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
            CALL HBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
            CALL HBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)+1); LRWORKN = INT(RWORK(1)+1)
               LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)+1); LRWORKV = INT(RWORK(1)+1)
               LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHBEVD_F95
SUBROUTINE CHBEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: HBEVX_F77 => LA_HBEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBEVX / LA_HBEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! band matrix A. Eigenvalues and eigenvectors can be selected by
!! specifying either a range of values or a range of indices for the
!! desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SBEVX / LA_HBEVX( AB, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 Q=q, ABSTOL=abstol, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!            INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!            INTEGER, INTENT(OUT), OPTIONAL :: M
!!            INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL j COMPLEX
!!            <wp> ::= KIND(1.0) j KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!        of subdiagonals or superdiagonals in the band and n is the order
!!        of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U" the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U" : Upper triangle of A is stored;
!!        = "L" : Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        the matrix A corresponding to the selected eigenvalues, with the
!!        i-th column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). If an eigenvector fails to converge, then
!!        that column of Z contains the latest approximation to the
!!        eigenvector, and the index of the eigenvector is returned in
!!        IFAIL.
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in
!!        advance, an upper bound must be used. In all cases M<=n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0<=M<=size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) = n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional (output) REAL or COMPLEX square array, shape(:,:) with
!!        size(Q,1) = n.
!!        The n by n unitary matrix used in the reduction to tridiagonal
!!        form. This is computed only if Z is present.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|, |b|),
!!        where <wp> is the working precision. If ABSTOL<=0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing A to tridiagonal form. Eigenvalues will be computed most
!!        accurately when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, S1Q, S2Q, KD
   INTEGER, TARGET :: ISTAT1(1)
   COMPLEX(WP), TARGET :: LLZ(1,1), LLQ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:), LQ(:,:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1 ) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
         IF( ISTAT == 0 )THEN
            IF( PRESENT(Q) )THEN; LQ => Q
            ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
         END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), RWORK(MAX(1,7*N)), WORK(MAX(1,N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
                 CALL HBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                 LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                 RWORK, IWORK, LIFAIL, LINFO )
            ELSE
                 CALL HBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                 LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                 RWORK, IWORK, LIFAIL, LINFO )
           ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, RWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHBEVX_F95
SUBROUTINE CHBGV_F95( A, B, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBGV_F77 => LA_HBGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HBGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KA, KB, &
              LDA, LDB
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KA = SIZE(A,1)-1; N = SIZE(A,2); LDA = MAX(SIZE(A,1),1)
   ISTAT = 0; KB = SIZE(B,1)-1; LDB = MAX(SIZE(B,1),1)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( KB < 0 .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,N)), RWORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
            CALL HBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, Z, S1Z, &
                        WORK, RWORK, LINFO )
          ELSE
            CALL HBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, LLZ, S1Z, &
                        WORK, RWORK, LINFO )
          ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO,ISTAT)
END SUBROUTINE CHBGV_F95
SUBROUTINE CHBGVD_F95( AB, BB, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP =>  SP                                     !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBGVD_F77 => LA_HBGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KAB, KBB, &
          LDAB, LDBB, LWORK, LIWORK, LRWORK, IWORKMIN(1)
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
  REAL(WP), TARGET :: RWORKMIN(1)
  REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; KAB = SIZE(AB,1)-1; N = SIZE(AB,2); LDAB = MAX(SIZE(AB,1),1)
      ISTAT = 0; KBB = SIZE(BB,1)-1; LDBB = MAX(SIZE(BB,1),1)
      IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
      ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
        IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
          IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
          ELSE IF( KBB < 0 .OR. SIZE(BB,2) /= N ) THEN; LINFO = -2
          ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
          ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
          ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
          ELSE IF( N > 0 )THEN
            LIWORK = -1
            LRWORK = -1
            LWORK = -1
            IF (PRESENT (Z)) THEN
             CALL HBGVD_F77(LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &           LDBB, W, Z, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, &
     &           IWORKMIN, LIWORK, LINFO )
             ELSE
               CALL HBGVD_F77(LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &           LDBB, W, LLZ, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, &
     &           IWORKMIN, LIWORK, LINFO )
             ENDIF
             LWORK = WORKMIN(1)
             LRWORK = RWORKMIN(1)
             LIWORK = IWORKMIN(1)
!! THEN NEXT 3 LINES SHOULD BE REMOVED WHEN THE BUG IS FIXED IN LAPACK77
            LWORK = 2 * LWORK + 1
            LRWORK =2 * LRWORK + 1
            LIWORK =2 * LIWORK + 1

            ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF (PRESENT (Z)) THEN
                CALL HBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB,LDAB, BB, &
     &            LDBB, W, Z, S1Z,  WORK, LWORK, RWORK, LRWORK, IWORK, &
     &            LIWORK, LINFO )
              ELSE
                CALL HBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB,LDAB, BB, &
     &            LDBB, W, LLZ, S1Z,  WORK, LWORK, RWORK, LRWORK, IWORK, &
     &            LIWORK, LINFO )
              ENDIF
            ELSE; LINFO = -100; ENDIF
            DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
          ENDIF
          CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHBGVD_F95
SUBROUTINE CHBGVX_F95( AB, BB,  W, UPLO, Z, VL, VU, IL, IU, &
      &         M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  SP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HBGVX_F77 => LA_HBGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
      COMPLEX(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBGVX and LA_HBGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of the generalized eigenvalue problem
!!                      A*z = lambda*B*z,
!! where A and B are real symmetric in the case of LA_SBGVX and complex
!! Hermitian in the case of LA_HBGVX. In both cases B is positive
!! definite. Matrices A and B are stored in a band format. Eigenvalues
!! and eigenvectors can be selected by specifying either a range of
!! values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_SBGVX / LA_HBGVX( AB, BB, W, UPLO=uplo, Z=z, &
!!                   VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, Q=q, &
!!                   ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!        of subdiagonals or superdiagonals in the band of A and n is
!!        the order of A and B.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of A in band storage. The ka + 1 diagonals of A are
!!        stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                   1<=j<=n.
!!        On exit, the contents of AB are destroyed.
!! BB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!        of subdiagonals or superdiagonals in the band of B.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix B in band storage. The kb + 1 diagonals of
!!        B are stored in the rows of BB so that the j-th column of B
!!        is stored in the j-th column of BB as follows:
!!        if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                   1<=j<=n.
!!        On exit, the factor S from the split Cholesky factorization
!!                     B = S^H*S.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangles of A and B are stored;
!!            = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!        with size(Z,1) = n.
!!        The first M columns of Z contain the orthonormal eigenvectors
!!        corresponding to the selected eigenvalues, with the i-th
!!        column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). The eigenvectors are normalized so that
!!        Z^H*B*Z = I . If an eigenvector fails to converge, then that
!!        column of Z contains the latest approximation to the
!!        eigenvector and the index of the eigenvector is returned in
!!        IFAIL.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL)=n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional, (Output) REAL or COMPLEX square array, shape(:,:)
!!        with size(Q,1) = n.
!!        If Z is present, the matrix used in the reduction of
!!        A*z = lambda*B*z to tridiagonal form.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An
!!        approximate eigenvalue is accepted as converged when it is
!!        determined to lie in an interval [a,b] of width less than or
!!        equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal
!!        form. Eigenvalues will be computed most accurately when ABSTOL
!!        is set to twice the underflow threshold
!!                   2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i,
!!             then i eigenvectors failed to converge. Their indices
!!             are stored in array IFAIL.
!!           > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!             minor of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!        If INFO is not present and an error occurs, then the program
!!        is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBGVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDAB, LDBB, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, S1Q, S2Q, KAB, KBB
      INTEGER, TARGET :: ISTAT1(1)
      COMPLEX(WP), TARGET :: LLZ(1,1), LLQ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:), LQ(:,:)
      REAL(WP), POINTER :: RWORK (:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KAB = SIZE(AB,1)-1; KBB = SIZE(BB,1)-1
   N = SIZE(AB,2); LDAB = MAX(1,SIZE(AB,1))
   LDBB = MAX(1, SIZE(BB,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
      ELSE; LRANGE = "A" ; END IF

      IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE  IF (KBB < 0) THEN; LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
      ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
      ELSE IF( LVU < LVL )THEN; LINFO = -6
      ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &    (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
      ELSE IF( LRANGE == "I" .AND. ( LIU.LT.MIN( N, LIL ) .OR. LIU.GT.N)) THEN; LINFO = -8
      ELSE IF( N < LIU )THEN; LINFO = -9
      ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
      ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
      ELSE IF( N > 0 )THEN
          IF( PRESENT(Z) ) THEN; LJOBZ = "V"
            IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
            ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
            IF( ISTAT == 0 )THEN
              IF( PRESENT(Q) )THEN; LQ => Q
              ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
            END IF
          ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!! .. DETERMINE THE WORKSPACE
          IF( ISTAT == 0 ) THEN
            ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,N)), RWORK(MAX(1,7*N)), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
              ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
              IF (PRESENT (Z))  THEN
                CALL HBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z,&
     &            S1Z, WORK, RWORK, IWORK, LIFAIL, LINFO )
              ELSE
                 CALL HBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, LLZ,&
     &            S1Z, WORK, RWORK, IWORK, LIFAIL, LINFO )
              ENDIF
                  IF( PRESENT(M) ) M = LM
                ELSE; LINFO = -100; END IF
                END IF
        IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
        IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
        DEALLOCATE(IWORK, WORK, RWORK,  STAT=ISTAT1(1))
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHBGVX_F95


SUBROUTINE CHEEV_F95( A, W, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEV_F77 => LA_HEEV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEEV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LWORK, NB
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; ISTAT = 0; LD = MAX(1,N)
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
     LWORK = (1+NB)*N
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         LWORK = 2*N-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( ISTAT == 0 ) ALLOCATE( RWORK(MAX(1,3*N-2)), STAT=ISTAT )
!
      IF( LINFO == 0 )THEN
         CALL HEEV_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, RWORK, LINFO )
      ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHEEV_F95
SUBROUTINE CHEEVD_F95( A, W, JOBZ, UPLO, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEVD_F77 => LA_HEEVD                              !!((07-B-INT_LAPACK1.f90))
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LIWORK, LMWORK, LWORK, LRWORK
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), TARGET :: WORKMIN(1)
   REAL(WP), TARGET :: RWORKMIN(1)
   INTEGER, TARGET :: IWORKMIN(1)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
       LWORK = -1
       LRWORK = -1
       LIWORK = -1
       CALL HEEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORKMIN, LWORK, &
     &  RWORKMIN, LRWORK, IWORKMIN, LIWORK,  LINFO )
       LWORK = WORKMIN(1)
       LRWORK = RWORKMIN(1)
       LIWORK = IWORKMIN(1)
      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         IF( LSAME(LJOBZ,"V") )THEN
           LMWORK = 1+6*N+2*N**2
         ELSE
           LMWORK = 2*N+1
         END IF
         DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
         LWORK = LMWORK
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK,  LINFO )
      ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHEEVD_F95
SUBROUTINE CHEEVR_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, M, ISUPPZ,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: HEEVR_F77 => LA_HEEVR                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_SYEVR / LA_HEEVR compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!       LA_SYEVR and LA_HEEVR use a relatively robust representation
!! (RRR) algorithm. It is usually the fastest algorithm of all and uses
!! the least workspace.
!!
!! ========
!!
!!        SUBROUTINE LA SYEVR / LA HEEVR( A, W, JOBZ=jobz, &
!!                 UPLO=uplo, VL=vl, VU=vu, IL=il, IU=iu, M=m, &
!!                 ISUPPZ= isuppz, ABSTOL=abstol, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!           INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!           INTEGER, INTENT(OUT), OPTIONAL :: M
!!           INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A.
!!         On exit:
!!         If JOBZ = "V", then the first M columns of A contain the
!!         orthonormal eigenvectors of the matrix A corresponding to the
!!         selected eigenvalues, with the i-th column of A containing the
!!         eigenvector associated with the eigenvalue in W(i).
!!         If JOBZ = "N", the upper triangle (if UPLO = "U") or the lower
!!         triangle (if UPLO = "L") of A, including the diagonal, is
!!         destroyed.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The first M elements contain the selected eigenvalues in
!!         ascending order.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!         = "N": Computes eigenvalues only;
!!         = "V": Computes eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! VL,VU   Optional (input) REAL.
!!         The lower and upper bounds of the interval to be searched for
!!         eigenvalues. VL < VU.
!!         Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0).
!!         Note: Neither VL nor VU may be present if IL and/or IU is
!!         present.
!! IL,IU   Optional (input) INTEGER.
!!         The indices of the smallest and largest eigenvalues to be
!!         returned. The IL-th through IU-th eigenvalues will be found.
!!            1 <= IL <= IU <= size(A,1).
!!         Default values: IL = 1 and IU = size(A,1).
!!         Note: Neither IL nor IU may be present if VL and/or VU is
!!         present.
!!         Note: All eigenvalues are calculated if none of the arguments
!!         VL, VU, IL and IU are present.
!! M       Optional (output) INTEGER.
!!         The total number of eigenvalues found. 0 <= M <= size(A,1).
!!         Note: If IL and IU are present then M = IU-IL+1.
!! ISUPPZ  Optional (output) INTEGER array, shape (:) with
!!         size(ISUPPZ) = 2*max(1,M).
!!         The support of the eigenvectors in A, i.e., the indices
!!         indicating the nonzero elements. The i-th eigenvector is
!!         nonzero only in elements ISUPPZ(2i-1) through ISUPPZ(2i) .
!!         Note: ISUPPZ must be absent if JOBZ = "N".
!! ABSTOL  Optional (input) REAL.
!!         The absolute error tolerance for the eigenvalues. An
!!         approximate eigenvalue is accepted as converged when it is
!!         determined to lie in an interval [a, b] of width less than or
!!         equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!         where <wp> is the working precision. If ABSTOL <= 0, then
!!         EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!         ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!         reducing A to tridiagonal form.
!!         Default value: 0.0_<wp>.
!!         Note: Eigenvalues are computed most accurately if ABSTOL is set
!!         to LA_LAMCH(1.0_<wp>,"Safe minimum"), not zero.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
     &  LIWORK, SISUPPZ, NN, LRWORK
      INTEGER:: IWORKMIN(1)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
      REAL(WP) :: RWORKMIN(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
      N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
      NN=2*MAX(1,N)
      IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
      IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
      IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U";  END IF
      IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL);  ENDIF
      IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
      IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
      IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS ..
        IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
        ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
        ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN; LINFO = -3
        ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
        ELSE IF( LVU < LVL )THEN; LINFO = -5
        ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. (PRESENT(IL) .OR. PRESENT(IU)) )THEN
          LINFO = -6
        ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0)THEN; LINFO = -7
        ELSE IF( N < LIU )THEN; LINFO = -8
        ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND.LSAME(LJOBZ,"N"))THEN; LINFO = -10
        ELSE IF( N > 0 )THEN
          IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
            LRANGE = "V"; LM = N
          ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
            LRANGE = "I"; LM = LIU-LIL+1
          ELSE
            LRANGE = "A"; LM = N
          END IF
          IF ( LSAME(LJOBZ,"V") ) THEN
              LDZ=N; LZ=LM
          ELSE
              LDZ=1; LZ=1
          ENDIF
          ALLOCATE (Z(LDZ,LZ), STAT=ISTAT)
!!  .. QUERING THE SIZE OF WORKSPACE ..
             LWORK = -1
             LRWORK = -1
             LIWORK = -1
                CALL HEEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &             LIL, LIU, LABSTOL, LM, W, Z, LDZ, IWORKMIN, &
     &             WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, LIWORK, LINFO )
!! THE NEXT  LINE SHOULD BE
!!           LWORK = WORKMIN(1) WHEN  THE LAPACK IS FIXED
            LWORK = 10*WORKMIN(1)+10000
            LRWORK = RWORKMIN(1)
            LIWORK = IWORKMIN(1)
            DEALLOCATE(Z)

            ALLOCATE(IWORK(LIWORK), RWORK(LRWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 100; ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 200; ENDIF

            ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
            IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

            ALLOCATE(Z(LDZ, LZ), STAT = ISTAT)
            IF(ISTAT /= 0) THEN; LINFO = -100; GOTO 400; ENDIF

            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL; ELSE
!!              LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
              LABSTOL = 0.0_WP;  ENDIF
!! .. CALL LAPACK77 ROUTINE ..
              CALL HEEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &          LIL, LIU, LABSTOL, LM, W, Z, LDZ, LISUPPZ, &
     &          WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, LINFO )
              IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
              IF( PRESENT(M) ) M = LM
              IF(PRESENT(ISUPPZ)) ISUPPZ = LISUPPZ

              DEALLOCATE(Z)
400           DEALLOCATE(LISUPPZ)
300           DEALLOCATE(WORK)
200           DEALLOCATE(IWORK, RWORK)
         ENDIF
100         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHEEVR_F95
SUBROUTINE CHEEVX_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEVX_F77 => LA_HEEVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEVX / LA_HEEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!         SUBROUTINE LA_SYEVX / LA_HEEVX ( A, W, JOBZ=jobz, UPLO=uplo, &
!!                        VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                        ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the first M columns of A contain the
!!        orthonormal eigenvectors of the matrix A corresponding to the
!!        selected eigenvalues, with the i-th column of A containing the
!!        eigenvector associated with the eigenvalue in W(i) . If an
!!        eigenvector fails to converge, then that column of A contains the
!!        latest approximation to the eigenvector and the index of the
!!        eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU-IL+1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: IFAIL must be absent if JOBZ = "N".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL<= 0, then
!!        EPSILON(1.0_<wp>)*||T||1 will be used in its place, where ||T||1
!!        is the l1 norm of the tridiagonal matrix obtained by reducing A
!!        to tridiagonal form. Eigenvalues will be computed most accurately
!!        when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
              SIFAIL
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
   IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(M)) M=0
   IF( PRESENT(IFAIL) )THEN
      SIFAIL = SIZE(IFAIL)
   ELSE
      SIFAIL = N
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
   IF( PRESENT(VL) )THEN
      LVL = VL
   ELSE
      LVL = -HUGE(LVL)
   ENDIF
   IF( PRESENT(VU) )THEN
      LVU = VU
   ELSE
      LVU = HUGE(LVU)
   ENDIF
   IF( PRESENT(IL) )THEN
      LIL = IL
   ELSE
      LIL = 1
   ENDIF
   IF( PRESENT(IU) )THEN
      LIU = IU
   ELSE
      LIU = N
   ENDIF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( LVU < LVL )THEN
      LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN
      LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0  )THEN
      LINFO = -7
   ELSE IF( N < LIU )THEN
      LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND.LSAME(LJOBZ,"N") )THEN
          LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
         LRANGE = "V"
         LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
         LRANGE = "I"
         LM = LIU-LIL+1
      ELSE
         LRANGE = "A"
         LM = N
      END IF
      IF ( LSAME(LJOBZ,"V") ) THEN
         LDZ = N
         LZ = LM
      ELSE
         LDZ = 1
         LZ = 1
      ENDIF
      IF( PRESENT(IFAIL) )THEN;
         LIFAIL => IFAIL
      ELSE
         LIFAIL => ISTAT1
      ENDIF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)
      ALLOCATE(IWORK(5*N),RWORK(7*N),Z(LDZ,LM), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, RWORK, Z, STAT=ISTAT1(1))
         ALLOCATE(IWORK(5*N), RWORK(7*N), Z(LDZ,LM), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
       LWORK = -1
       CALL HEEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORKMIN, &
     &         LWORK, RWORK, IWORK, LIFAIL, LINFO )
       LWORK = WORKMIN(1)
       ALLOCATE (WORK(LWORK), STAT = ISTAT)
       IF  (ISTAT == 0) THEN
         IF( PRESENT(ABSTOL) )THEN
            LABSTOL = ABSTOL
         ELSE
            LABSTOL = 0.0_WP
         ENDIF
!!     .. CALL LAPACK77 ROUTINE
         CALL HEEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
                         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                         LWORK, RWORK, IWORK, LIFAIL, LINFO )
         IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
         IF( PRESENT(M) ) M = LM
         W(LM+1:N) = 0.0_WP
      END IF
      ENDIF
      DEALLOCATE(IWORK, Z, RWORK, STAT=ISTAT1(1))
      DEALLOCATE (WORK)
   END IF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE CHEEVX_F95
SUBROUTINE CHEGST_F95( A, B, ITYPE, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEGST_F77 => LA_HEGST                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(IN) :: B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYGST / LA_HEGST reduces a real symmetric-definite or complex
!! Hermitian-definite generalized eigenproblem to standard form.
!
!! If ITYPE = 1, the problem is A*x = lambda*B*x,
!! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
!
!! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
!! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
!
!! B must have been previously factorized as U**H*U or L*L**H
!! by LA_POTRF.
!
!! =======
!
!!    SUBROUTINE LA_SYGST / LA_HEGST( A, B, ITYPE, UPLO, INFO )
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       <type(<wp>), INTENT(IN) :: B(:,:)
!!       <type(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!       <type> ::= REAL | COMPLEX
!
!! Defaults
!! ========
!
!! 1. If ITYPE is not present then ITYPE = 1 is assumed.
!!
!! 2. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the transformed matrix, stored in the
!!            same format as A.
!
!! B       (input) either REAL or COMPLEX square array,
!!         shape (:,:), size(B,1) == size(A,1).
!!         The triangular factor from the Cholesky factorization of B,
!!         as returned by LA_POTRF.
!
!! ITYPE   Optional, (input) INTEGER
!!         If ITYPE is present then:
!!            = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
!!            = 2 or 3: compute U*A*U**H or L**H*A*L.
!!         otherwise ITYPE = 1 is assumed.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored and B is factored as
!!                    U**H*U;
!!            = "L":  Lower triangle of A is stored and B is factored as
!!                    L*L**H.
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SHEST"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LITYPE
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N )THEN; LINFO = -2
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. CALL LAPACK77 ROUTINE
      CALL HEGST_F77( LITYPE, LUPLO, N, A, LD, B, LD, LINFO )
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO)
END SUBROUTINE CHEGST_F95
SUBROUTINE CHEGV_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEGV_F77 => LA_HEGV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEGV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, LD, LITYPE, LRWORK,LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(ITYPE) )THEN
      LITYPE = ITYPE
   ELSE
      LITYPE = 1
   END IF
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
      LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
      LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -6
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      ENDIF
      LWORK = N*(1+NB)
      LRWORK = MAX(1,3*N-2)
      ALLOCATE(RWORK(LRWORK), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(RWORK, WORK, STAT=ISTAT1)
         LWORK = N*2-1
         ALLOCATE(RWORK(LRWORK), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( LINFO == 0 .OR. LINFO <= -200 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEGV_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
                        WORK, LWORK, RWORK, LINFO )
      END IF
      DEALLOCATE(RWORK, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE CHEGV_F95
SUBROUTINE CHEGVD_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: HEGVD_F77 => LA_HEGVD                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
      INTEGER, INTENT(IN), OPTIONAL :: ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEGV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, LD, LITYPE, LWORK, ISTAT, ISTAT1, LIWORK, &
     &         LRWORK
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
       REAL(WP), POINTER :: RWORK(:)
       REAL(WP) :: RWORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
      IF( PRESENT(ITYPE) )THEN
        LITYPE = ITYPE
      ELSE
        LITYPE = 1
      END IF
      IF( PRESENT(JOBZ) ) THEN
        LJOBZ = JOBZ
      ELSE
        LJOBZ = "N"
      END IF
      IF( PRESENT(UPLO) ) THEN
        LUPLO = UPLO
      ELSE
        LUPLO = "U"
      END IF
!!  .. TEST THE ARGUMENTS ..
      IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
        LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
        LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN
        LINFO = -3
      ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
        LINFO = -4
      ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
        LINFO = -5
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
        LINFO = -6
      ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE ..
!!  .. QUERING THE SIZE OF WORKSPACE ..
         LIWORK = -1
         LRWORK = -1
         LWORK = -1

         CALL HEGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, LIWORK, LINFO )

         LWORK = WORKMIN(1)
         LRWORK = RWORKMIN(1)
         LIWORK = IWORKMIN(1)

         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF (ISTAT == 0) THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
           LINFO = -100
         END IF
         DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
      ENDIF
      CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE CHEGVD_F95
SUBROUTINE CHEGVX_F95( A, B, W, ITYPE, JOBZ, UPLO, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HEGVX_F77 => LA_HEGVX, ILAENV_F77 => ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYGVX and LA_HEGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!      A*z = lambda*B*z, A*B*z = lambda*z,  and  B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SYGVX and complex
!! Hermitian in the case of LA_HEGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SYGVX / LA_HEGVX (A, B, W, ITYPE= itype, &
!!             JOBZ= jobz, UPLO= uplo, VL= vl, VU= vu, IL= il, &
!!             IU= iu, M= m, IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the
!!        upper triangular part of matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of
!!        matrix A.
!!        On exit, if JOBZ = "V", the first M columns of A contain the
!!        orthonormal eigenvectors corresponding to the selected
!!        eigenvalues, with the i-th column of A holding the eigenvector
!!        associated with the eigenvalue in W(i).
!!        The eigenvectors are normalized as follows:
!!          if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!          if ITYPE = 3: Z^H * B^-1 * Z = I .
!!        If an eigenvector fails to converge, then that column of A
!!        contains the latest approximation to the eigenvector and the
!!        index of the eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! B      (input/output) REAL or COMPLEX square array, shape (:,:) with
!!        size(B,1) = size(A,1).
!!        On entry, the matrix B.
!!        If UPLO = "U", the upper triangular part of B contains the
!!        upper triangular part of matrix B. If UPLO = "L", the lower
!!        triangular part of B contains the lower triangular part of
!!        matrix B.
!!        On exit, the part of B containing the matrix is overwritten by
!!        the triangular factor U or L of the Cholesky factorization
!!              B = U^H*U or B = L*L^H.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! ITYPE  Optional (input) INTEGER.
!!        Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!        Default value: 1.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!           = "N": Computes eigenvalues only;
!!           = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: IFAIL should be present if JOBZ = "V".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!             ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal form.
!!        Eigenvalues will be computed most accurately when ABSTOL is set
!!        to twice the underflow threshold 2 * LA_LAMCH(1.0_<wp>, "S"),
!!        not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: the algorithm failed to converge or matrix B is not
!!        positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i, then i
!!             eigenvectors failed to converge. Their indices are stored
!!             in array IFAIL.
!!           > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!             of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!         n is the order of A.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
       CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEGVX"
       CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDA, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
      &     SIFAIL, LDB, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
      REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LDA = MAX(1,N); LDB=MAX(1,SIZE(B,1)); LINFO = 0; ISTAT = 0
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL);ELSE; SIFAIL = N; END IF
   IF( PRESENT(JOBZ ) )THEN; LJOBZ=JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN;  LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN ; LRANGE = "V"; LM=N
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN ; LRANGE = "I"; LM=LIU-LIL+1
   ELSE ; LRANGE = "A"; LM=N; END IF
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF (SIZE (B, 2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN;  LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"V") .AND. .NOT.LSAME(LJOBZ,"N") )THEN; LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN ; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE, "I") .AND. ( LIU < MIN( N, LIL ) .OR. LIU>N))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN

    IF(LSAME(LJOBZ, "V")) THEN
       LDZ = MAX(1,N); LZ=LM
    ELSE
       LDZ = 1; LZ=1
    ENDIF
    IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
    ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)

      ALLOCATE(Z(LDZ, LZ), STAT=ISTAT)
      IF (ISTAT /= 0) LINFO = -100

      ALLOCATE(IWORK(10*5*N), WORK(10*LWORK), RWORK(7*N), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
         LWORK = N*8*10
         ALLOCATE(IWORK(10*5*N), WORK(LWORK), RWORK(7 *N), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
         IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
         ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
!!     .. CALL LAPACK77 ROUTINE
            CALL HEGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
     &         LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
     &         LWORK, RWORK, IWORK, LIFAIL, LINFO )

         IF( PRESENT(M) ) M = LM
         IF (LSAME(LJOBZ,"V"))  A(1:LDZ, 1:LM)=Z(1:LDZ, 1:LM)
      END IF
      DEALLOCATE(IWORK, WORK, RWORK, STAT=ISTAT1(1))
      DEALLOCATE(Z, STAT=ISTAT)
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHEGVX_F95
 SUBROUTINE CHESV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HESV_F77 => LA_HESV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HESV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL HESV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CHESV1_F95
 SUBROUTINE CHESV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HESV_F77 => LA_HESV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HESV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL HESV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CHESV_F95
SUBROUTINE CHESVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HESVX_F77 => LA_HESVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HESVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,2*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HESVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CHESVX1_F95
SUBROUTINE CHESVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HESVX_F77 => LA_HESVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HESVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HESVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CHESVX_F95
SUBROUTINE CHETRD_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HETRD_F77 => LA_HETRD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: TAU(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HETRD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CHETRD"
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYTRD / LA_HETRD reduces a real symmetric or complex Hermitian
!! matrix A to real symmetric tridiagonal form T by an orthogonal
!! or unitary similarity transformation:
!! Q**H * A * Q = T.
!
!! =======
!
!!    SUBROUTINE LA_HETRD / LA_SYTRD|( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       <type>(<wp>), INTENT(OUT) :: TAU(:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A.
!!         On exit:
!!            If UPLO = "U", the diagonal and first superdiagonal
!!               of A are overwritten by the corresponding elements of the
!!               tridiagonal matrix T, and the elements above the first
!!               superdiagonal, with the array TAU, represent the unitary
!!               matrix Q as a product of elementary reflectors.
!!            If UPLO = "L", the diagonal and first subdiagonal of A are
!!               overwritten by the corresponding elements of the tridiagonal
!!               matrix T, and the elements below the first subdiagonal, with
!!               the array TAU, represent the unitary matrix Q as a product
!!               of elementary reflectors.
!!            See Further Details.
!
!! TAU     (output) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         The scalar factors of the elementary reflectors.
!!         See Further Details.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! Further Details
!! ===============
!
!! If UPLO = "U", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(n-1) . . . H(2) H(1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!! A(1:i-1,i+1), and tau in TAU(i).
!
!! If UPLO = "L", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(1) H(2) . . . H(n-1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!! and tau in TAU(i).
!
!! The contents of A on exit are illustrated by the following examples
!! with n = 5:
!
!! if UPLO = "U":                       if UPLO = "L":
!
!!   (  d   e   v2  v3  v4 )              (  d                  )
!!   (      d   e   v3  v4 )              (  e   d              )
!!   (          d   e   v4 )              (  v1  e   d          )
!!   (              d   e  )              (  v1  v2  e   d      )
!!   (                  d  )              (  v1  v2  v3  e   d  )
!
!! where d and e denote diagonal and off-diagonal elements of T, and vi
!! denotes an element of the vector defining H(i).
!
!! --------------------------------------
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: D(:), E(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB > 1 .AND. NB < N )THEN; LWORK = N*NB; ELSE; LWORK = 1; ENDIF
      ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(D, E, WORK, STAT=ISTAT1)
         LWORK = 1; ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HETRD_F77( LUPLO, N, A, LD, D, E, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(D, E, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHETRD_F95
SUBROUTINE CHPEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPEV_F77 => LA_HPEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,2*N-1)), RWORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
          CALL HPEV_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, RWORK, LINFO )
         ELSE
          CALL HPEV_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, RWORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPEV_F95
SUBROUTINE CHPEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPEVD_F77 => LA_HPEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LRWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0, &
                    LRWORKN = 0, LRWORKV = 0
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
         LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
         IF( LSAME(LJOBZ,"N") )THEN
            LWORK = MAX( 1, N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
            LRWORK = MAX( 1, N, LRWORKN )
         ELSE
            LWORK = MAX( 1, 2*N, LWORKV )
            LRWORK = MAX( 1+ 5*N+2*N**2, LWORKV )
            LIWORK = MAX( 3+5*N, LIWORKV )
         END IF

      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 ) THEN
         DEALLOCATE( WORK, RWORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N )
            LRWORK = MAX(1, 2*N ); LIWORK = 1
         ELSE; LWORK = MAX( 1, 2*N ); LIWORK = 2+5*N
            LWORK = 1+ 4*N+2*N*LGN+3*N**2; END IF
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(Z) )THEN
           CALL HPEVD_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
           CALL HPEVD_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ENDIF

         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN; LWORKN = INT(WORK(1)+1)
               LRWORKN = INT(RWORK(1)+1); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LRWORKV = INT(RWORK(1)+1);
               LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPEVD_F95
SUBROUTINE CHPEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: HPEVX_F77 => LA_HPEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SPEVX / LA_HPEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex hermitian
!! matrix A in packed storage. Eigenvalues and eigenvectors can be
!! selected by specifying either a range of values or a range of indices
!! for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SPEVX / LA_HPEVX( AP, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 ABSTOL=abstol, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!!  AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n+1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!          On exit, AP is overwritten by values generated during the
!!          reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!          diagonal and first superdiagonal of T overwrite the correspond-
!!          ing diagonals of A. If UPLO = "L", the diagonal and first
!!          subdiagonal of T overwrite the corresponding diagonals of A.
!!  W       (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!!  UPLO    Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors of
!!          the matrix A corresponding to the selected eigenvalues, with the
!!          i-th column of Z containing the eigenvector associated with
!!          the eigenvalue in W(i) . If an eigenvector fails to converge,
!!          then that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are supplied
!!          in the array Z. When the exact value of M is not known in
!!          advance, an upper bound must be used. In all cases M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th
!!          eigenvalues will be found. 1<=IL<=IU<=size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0<=M<=size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL+EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL<=0, then
!!          EPSILON(1.0_<wp>)*||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing A to tridiagonal form. Eigenvalues will be computed
!!          most accurately when ABSTOL is set to twice the underflow
!!          threshold 2*LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2*LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!          indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPEVX"
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, NN
   INTEGER, TARGET :: ISTAT1(1)
   COMPLEX(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &      (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N > 0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), RWORK(MAX(1,7*N)), WORK(MAX(1,2*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
                CALL HPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                       LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                       RWORK, IWORK, LIFAIL, LINFO )
            ELSE
               CALL HPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                       LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                       RWORK, IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, RWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPEVX_F95
SUBROUTINE CHPGV_F95( A, B, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPGV_F77 => LA_HPGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WW
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= SIZE(A)  )THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,2*N-1)), RWORK(MAX(1, 3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
           CALL HPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, Z, S1Z, &
                         WORK, RWORK, LINFO )
        ELSE
           CALL HPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, LLZ, S1Z, &
                        WORK, RWORK, LINFO )
        ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPGV_F95
SUBROUTINE CHPGVD_F95( AP, BP, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPGVD_F77 => LA_HPGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: AP(:), BP(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) ::  LJOBZ, LUPLO
      INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, S1Z, S2Z
      INTEGER :: LWORK, LIWORK, LRWORK
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
      REAL(WP):: RWORKMIN(1)
      INTEGER :: IWORKMIN(1)
      COMPLEX(WP) :: WW
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; NN = SIZE(AP)
      WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
      IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
        IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
        ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
          IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
            IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
            ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
            ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
            ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
            ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
            ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
            ELSE IF( N > 0 )THEN
!!  QUERING THE SIZE OF WORKSPACE ...
                LWORK = -1
                LRWORK = -1
                LIWORK = -1
                IF (PRESENT (Z)) THEN
                  CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &               Z, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, &
     &               LIWORK, LINFO )
                ELSE
                  CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &               LLZ, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, &
     &               LIWORK, LINFO )
                ENDIF

                LWORK = WORKMIN(1)
                LRWORK = RWORKMIN(1)
                LIWORK= IWORKMIN(1)

                ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
                IF( ISTAT == 0 )THEN
                 IF (PRESENT(Z)) THEN
                    CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                Z, S1Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &
     &                LINFO )
                 ELSE
                     CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                LLZ, S1Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &
     &                LINFO )
                 ENDIF
                ELSE; LINFO = -100; ENDIF
                ENDIF
                DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT)
                CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPGVD_F95


SUBROUTINE CHPGVX_F95( AP, BP, W, ITYPE, UPLO, Z, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HPGVX_F77 => LA_HPGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      COMPLEX(WP), INTENT(INOUT) :: AP(:), BP(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPGVX and LA_HPGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!       A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SPGVX and complex
!! Hermitian in the case of LA_HPGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues. Matrices A and B are stored in a packed format.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGVX / LA_HPGVX( AP, BP, W, ITYPE= itype, &
!!             UPLO= uplo, Z= z, VL= vl, VU= vu, IL= il, IU= iu, M= m, &
!!             IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!         <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!         REAL(<wp>), INTENT(OUT) :: W(:)
!!         INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!         INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!         INTEGER, INTENT(OUT), OPTIONAL :: M
!!         INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^T*U or B = L*L^T, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX rectangular array, shape
!!          (:,:) with size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          corresponding to the selected eigenvalues, with the i-th
!!          column of Z holding the eigenvector associated with the
!!          eigenvalue in W(i). The eigenvectors are normalized as
!!          follows:
!!            if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!            if ITYPE = 3: Z^H * B^-1 * Z = I .
!!          If an eigenvector fails to converge, then that column of Z
!!          contains the latest approximation to the eigenvector and the
!!          index of the eigenvector is returned in IFAIL.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!          size(A,1).
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing the generalized eigenvalue problem to tridiagonal
!!          form. Eigenvalues will be computed most accurately when
!!          ABSTOL is set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with 0 < INFO <= n, then some
!!          eigenvectors did not converge.
!!          Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!          > 0: the algorithm failed to converge or matrix B is not
!!            positive definite:
!!             <= n: the algorithm failed to converge; if INFO = i, then
!!              i eigenvectors failed to converge. Their indices are
!!              stored in array IFAIL.
!!             > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!              minor of order i of B is not positive definite. The
!!              factorization of B could not be completed and no
!!                eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPGVX"
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
      INTEGER :: N, LINFO, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, NN, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      COMPLEX(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
      COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(AP)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
   ELSE ; LRANGE = "A"; END IF

   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF (LITYPE <1 .OR. LITYPE >3) THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &  (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE,"I") .AND. ( LIU < MIN(N, LIL) .OR. LIU > N ))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
        IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
        ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
        ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
       IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), RWORK(MAX(1,7*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
           IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
           ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
             IF (PRESENT (Z)) THEN
                  CALL HPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &                   LVU, LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, RWORK, IWORK, LIFAIL, &
     &                   LINFO )
             ELSE
                  CALL HPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &                   LVU, LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, RWORK, IWORK, LIFAIL, &
     &                   LINFO )
             ENDIF
             IF( PRESENT(M) ) M = LM
           ELSE; LINFO = -100; END IF
           END IF
           IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
           DEALLOCATE(IWORK, WORK, RWORK, STAT=ISTAT1(1))
         END IF
         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CHPGVX_F95
 SUBROUTINE CHPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HPSV_F77 => LA_HPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL HPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CHPSV1_F95
 SUBROUTINE CHPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HPSV_F77 => LA_HPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL HPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CHPSV_F95
SUBROUTINE CHPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPSVX_F77 => LA_HPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CHPSVX1_F95
SUBROUTINE CHPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPSVX_F77 => LA_HPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,2*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CHPSVX_F95
      SUBROUTINE CLAGGE_F95( A, KL, KU, D, ISEED, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAGGE_F77 => LA_LAGGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(IN), OPTIONAL :: KL, KU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: ISEED(4)
      REAL(WP), INTENT(IN), OPTIONAL, TARGET :: D(:)
      COMPLEX(WP), INTENT(OUT) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LAGGE generates a real general m by n matrix A, by pre- and post-
!!  multiplying a real diagonal matrix D with random orthogonal matrices:
!!  A = U*D*V. The lower and upper bandwidths may then be reduced to
!!  kl and ku by additional orthogonal transformations.
!
!!  Arguments
!!  =========
!
!!  SUBROUTINE LA_LAGGE( A, KL, KU, D, ISEED, INFO )
!!     <type>(<wp>), INTENT(OUT) :: A(:,:)
!!     INTEGER, INTENT(IN), OPTIONAL :: KL, KU
!!     REAL(<wp>), INTENT(IN), OPTIONAL, TARGET :: D(:)
!!     INTEGER, INTENT(INOUT), OPTIONAL :: ISEED(4)
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!!  =====================
!
!!  A       (output) REAL array, shape (:,:), SIZE(A,1) == m,
!!          SIZE(A,2) == n.
!!          The generated m by n matrix A.
!
!!  KL      (input) INTEGER
!!          The number of nonzero subdiagonals within the band of A.
!!          0 <= KL <= M-1.
!
!!  KU      (input) INTEGER
!!          The number of nonzero superdiagonals within the band of A.
!!          0 <= KU <= N-1.
!
!!  D       (input) REAL array, dimension (min(M,N))
!!          The diagonal elements of the diagonal matrix D.
!
!!  ISEED   Optional (input/output) INTEGER array, shape (:),
!!          SIZE(ISEED) == 4.
!!          On entry, the seed of the random number generator; the array
!!          elements must be between 0 and 4095, and ISEED(4) must be
!!          odd.
!!          On exit, the seed is updated.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LAGGE"
!!     .. "LOCAL Scalars" ..
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, LKL, LKU, M, MN, N, SD, SISEED
!!     .. "Local Arrays" ..
      INTEGER :: LISEED(4)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: LD(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX, MIN
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      MN = MIN(M,N); ISTAT = 0
      IF( PRESENT(KL) )THEN; LKL = KL; ELSE; LKL = M-1; ENDIF
      IF( PRESENT(KU) )THEN; LKU = KU; ELSE; LKU = M-1; ENDIF
      IF( PRESENT(D) )THEN; SD = SIZE(D); ELSE; SD = MN; ENDIF
      IF( PRESENT(ISEED) )THEN; SISEED = SIZE(ISEED); LISEED = ISEED
      ELSE; SISEED = 4
            LISEED(1) = 15; LISEED(2) = 1926
            LISEED(3) = 16; LISEED(4) = 1931; ENDIF
!!     .. "Test the arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( LKL < 0 .OR. LKL > M-1 )THEN; LINFO = -2
      ELSE IF( LKU < 0 .OR. LKU > N-1 )THEN; LINFO = -3
      ELSE IF( SD /= MN )THEN; LINFO = -4
      ELSE IF( SISEED /= 4 .OR. PRESENT(ISEED) .AND. (                  &
     &   ( LISEED(1) < 0 .OR. LISEED(1) > 4095 ) .OR.                   &
     &   ( LISEED(2) < 0 .OR. LISEED(2) > 4095 ) .OR.                   &
     &   ( LISEED(3) < 0 .OR. LISEED(3) > 4095 ) .OR.                   &
     &   ( LISEED(4) < 0 .OR. LISEED(4) > 4095 ) .OR.                   &
     &   ( MOD( LISEED(4), 2 ) == 0 ) ) )THEN; LINFO = -5
      ELSE
         IF( PRESENT(D) )THEN; LD => D
         ELSE; ALLOCATE( LD( MN ), STAT=ISTAT); ENDIF
         IF( ISTAT == 0 )THEN
            ALLOCATE( WORK( M + N ), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               IF( .NOT. PRESENT(D) )THEN
                  LD(1:MN-1) = 1.0_WP; LD(MN) = 0.5_WP; ENDIF
               CALL LAGGE_F77( M, N, LKL, LKU, LD, A, LDA, LISEED, WORK, LINFO )
               IF( PRESENT(ISEED) )ISEED = LISEED
            ELSE; LINFO = -100; END IF
            DEALLOCATE( WORK, STAT=ISTAT1 )
         ENDIF
         IF( .NOT. PRESENT(D) )DEALLOCATE( LD, STAT=ISTAT1)
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE CLAGGE_F95
      FUNCTION CLANGE1_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: CLANGE1_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      COMPLEX(WP), INTENT(IN) :: A(:)
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET :: LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A); N = 1; LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           CLANGE1_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION CLANGE1_F95
      FUNCTION CLANGE_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: CLANGE_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      COMPLEX(WP), INTENT(IN) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LANGE  returns the value of the one norm,  or the Frobenius norm,
!!  or the  infinity norm,  or the  element of  largest absolute value
!!  of a complex matrix A.
!
!!  Description
!!  ===========
!
!!  LA_LANGE returns the value
!
!!     LA_LANGE = ( max(abs(A(i,j))), NORM = "M" or "m"
!!              (
!!              ( norm1(A),         NORM = "1", "O" or "o"
!!              (
!!              ( normI(A),         NORM = "I" or "i"
!!              (
!!              ( normF(A),         NORM = "F", "f", "E" or "e"
!
!!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!!  =========
!
!!  FUNCTION LA_ANGE( A, NORM, INFO )
!!     REAL(<wp>) :: LA_ANGE
!!     <type>(<wp>), INTENT(IN) :: <a>
!!     CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!     <a>    ::= A(:,:) | A(:)
!
!!  Arguments
!!  =========
!
!!  A       (input) COMPLEX array, shape either (:,:) or (:).
!!          If shape is (:,:) then SIZE(A,1) == m, SIZE(A,2) == n.
!!          If shape is (:) then SIZE(A) == n.
!!          If either m or n == 0 LA_LANGE is set to zero.
!!          The m by n matrix A.
!
!!  NORM    (input) CHARACTER*1
!!          Specifies the value to be returned in LA_LANGE as described
!!          above.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET ::LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           CLANGE_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION CLANGE_F95
 SUBROUTINE CPBSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, 1, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPBSV1_F95
 SUBROUTINE CPBSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSV computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. The Cholesky decomposition is used to
!! factor A as A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular band matrix and L is a lower triangular
!! band matrix, each with the same number of superdiagonals or subdiagonals
!! as A. The factored form of A is then used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_PBSV( AB, B, UPLO=uplo, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!         of superdiagonals or subdiagonals in the band and n is the
!!         order of A.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The (kd + 1) diagonals of
!!         A are stored in the rows of AB so that the j-th column of A is
!!         stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                  1<=j<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U = L*L^H in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1)
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, NRHS, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPBSV_F95
SUBROUTINE CPBSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                            S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, KD
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, 1, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPBSVX1_F95
SUBROUTINE CPBSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                           S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSVX computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B
!! are rectangular matrices or vectors.
!!     LA_PBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PBSVX( AB, B, X, UPLO=uplo, AFB=afb, FACT=fact, &
!!                             EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                             RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             <type>(<wp>), INTENT(OUT) :: <sol>
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!             CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!             REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!             <sol>  ::= X(:,:) | X(:)
!!             <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!          of superdiagonals or subdiagonals and n is the order of A.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!          triangle of matrix A, or its equilibration, in band storage.
!!          The (kd + 1) diagonals of A are stored in the rows of AB so
!!          that the j-th column of A is stored in the j-th column of AB
!!          as follows:
!!          if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!          if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in AB; otherwise, AB is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!          and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFB      Optional (input or output) REAL or COMPLEX array, shape (:)
!!          with the same size as AB.
!!          If FACT = "F" then AFB is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_PBSVX.
!!          If FACT /= "F" then AFB is an output argument that contains
!!          the factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is supplied
!!          on entry, and if not, whether A should be equilibrated before
!!          it is factored.
!!            = "N": The matrix A will be copied to AFB and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to
!!                 AFB and factored.
!!            = "F": AFB contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)
!!          = size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!                is not positive definite, so the factorization could
!!                not be completed and the solution and error bounds
!!                could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!                machine precision, so the matrix is singular to
!!                working precision. Nevertheless, the solution and
!!                error bounds are computed because the computed solution
!!                can be more accurate than the value of RCOND would
!!                suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, SFERR, SBERR, KD
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A,1) < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, NRHS, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPBSVX_F95
 SUBROUTINE CPOSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, 1, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPOSV1_F95
 SUBROUTINE CPOSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_POSV computes the solution to a linear system of equations
!! A*X=B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices
!! or vectors. The Cholesky decomposition is used to factor A as
!! A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!         SUBROUTINE LA_POSV( A, B, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX square array, shape (:,:).
!!       On entry, the matrix A.
!!       If UPLO = "U", the upper triangular part of A contains the upper
!!       triangular part of the matrix A, and the strictly lower triangular
!!       part of A is not referenced. If UPLO = "L", the lower triangular
!!       part of A contains the lower triangular part of the matrix A, and
!!       the strictly upper triangular part of A is not referenced.
!!       On exit, the factor U or L from the Cholesky factorization
!!       A = U^H*U = L*L^H.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!       On entry, the matrix B.
!!       On exit, the solution matrix X.
!! UPLO  Optional (input) CHARACTER(LEN=1)
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!       Default value: "U".
!! INFO  Optional (output) INTEGER
!!       = 0: sauccessful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!          completed and the solution could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, NRHS, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPOSV_F95
SUBROUTINE CPOSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPOSVX1_F95
SUBROUTINE CPOSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!   LA_POSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors.
!!   LA_POSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_POSVX( A, B, X, UPLO=uplo, AF=af, FACT=fact, &
!!                          EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                          RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!            REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A or its equilibration:
!!          If UPLO = "U", then the upper triangular part of A contains
!!          the upper triangular part of (the equilibrated) A, and the
!!          strictly lower triangular part of A is not referenced.
!!          If UPLO = "L", then the lower triangular part of A contains
!!          the lower triangular part of (the equilibrated) A, and the
!!          strictly upper triangular part of A is not referenced.
!!          If FACT = "F" and EQUED = "Y", then A has been equilibrated
!!          by the scaling factors in S during a previous call to
!!          LA_POSVX.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in A; otherwise, A is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = size(A,1) or shape (:) with size(B) =
!!          size(A,1).
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!          size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!          = size(A,1).
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AF       Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as A.
!!          If FACT = "F" then AF is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_POSVX
!!          If FACT /= "F" then AF is an output argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is
!!          supplied on entry, and, if not, whether A should be
!!          equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored
!!                 (no equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)=
!!          size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j), FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the leading minor of order i of (the equilibrated)
!!                  A is not positive definite, so the factorization
!!                  could not be completed and the solution and error
!!                  bounds could not be computed. RCOND= 0 is returned.
!!              = n+1: U or L is nonsingular, but RCOND is less than
!!                  machine precision, so the matrix is singular to
!!                  working precision. Nevertheless, the solution and
!!                  error bounds are computed because the computed
!!                  solution can be more accurate than the value of
!!                    RCOND would suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPOSVX_F95
SUBROUTINE CPOTRF_F95( A, UPLO, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POTRF_F77 => LA_POTRF, LANSY_F77 => LA_LANSY, &    !!((07-B-INT_LAPACK1.f90))
                                  POCON_F77 => LA_POCON
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL  :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_POTRF computes the Cholesky factorization of a real symmetric or
!! complex Hermitian positive definite matrix A.
!
!! The factorization has the form
!!    A = U**H * U,  if UPLO = "U", or
!!    A = L * L**H,  if UPLO = "L",
!! where U is an upper triangular matrix and L is lower triangular.
!
!! This is the block version of the algorithm, calling Level 3 BLAS.
!
!! LA_POTRF optionally estimates the reciprocal of the condition number
!! (in the 1-norm) of a real symmetric or complex Hermitian positive
!! definite matrix A.
!! An estimate is obtained for norm(inv(A)), and the reciprocal of the
!! condition number is computed as RCOND = 1 / (norm(A) * norm(inv(A))).
!
!! =======
!
!!    SUBROUTINE LA_POTRF( A, UPLO, RCOND, NORM, INFO )
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the factor U or L from the Cholesky
!!            factorization A = U**H*U or A = L*L**H.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored;
!!            = "L":  Lower triangle of A is stored.
!!         otherwise UPLO = "U" is assumed.
!
!! RCOND   Optional (output) REAL
!!         The reciprocal of the condition number of the matrix A
!!         computed as RCOND = 1/(norm(A) * norm(inv(A))).
!! NORM    Optional (input) CHARACTER*1
!!         Specifies whether the 1-norm condition number or the
!!         infinity-norm condition number is required:
!!           If NORM is present then:
!!              = "1", "O" or "o": 1-norm;
!!              = "I" or "i": infinity-norm.
!!           otherwise NORM = "1" is used.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!            > 0: if INFO = i, the leading minor of order i is not
!!               positive definite, and the factorization could not be
!!               completed.
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! --------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LNORM, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, LD
   REAL(WP) :: ANORM
!!  .. LOCAL POINTERS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .AND. N < 0 )THEN; LINFO = -1
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -2
   ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
            ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
              .AND. LNORM /= "1" ) ) THEN; LINFO = -4
   ELSE IF(  N > 0 )THEN
      IF( PRESENT(RCOND) ) THEN
!!     .. COMPUTE THE NORM OF THE MATRIX A
         ALLOCATE(RWORK(N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN; ANORM = LANSY_F77( LNORM, LUPLO, LD, A, N, RWORK )
         ELSE; LINFO = -100; END IF
         DEALLOCATE(RWORK, STAT=ISTAT1)
      END IF
!
      IF( LINFO == 0 ) THEN
!!     .. COMPUTE THE CHOLESKY FACTORS OF THE MATRIX A
         CALL POTRF_F77( LUPLO, N, A, LD, LINFO )
!
         IF( PRESENT(RCOND) .AND. LINFO == 0 ) THEN
!!        .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
            IF( ANORM == 0.0_WP )THEN; RCOND = 0.0_WP
            ELSE; ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT)
               IF( ISTAT == 0 )THEN
                  CALL POCON_F77( LUPLO, N, A, LD, ANORM, RCOND, &
                                  WORK, RWORK, LINFO )
               ELSE; LINFO = -100; END IF
               DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            END IF
         END IF
      END IF
   ELSE IF( PRESENT(RCOND) ) THEN; RCOND = 1.0_WP; ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE CPOTRF_F95
 SUBROUTINE CPPSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, 1, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPPSV1_F95
 SUBROUTINE CPPSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PPSV computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format. The Cholesky decomposition is
!! used to factor A as
!!      A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSV( AP, B, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)
!!         = n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U or A = L*L^H , in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! UPLO    Optional, (input) CHARACTER(LEN=1)
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, NRHS, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPPSV_F95
SUBROUTINE CPPSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SAF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPPSVX1_F95
SUBROUTINE CPPSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PPSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format.
!!     LA_PPSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                  FACT=fact, EQUED=equed, S=s, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!           CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!           REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX square array, shape (:) with
!!         size(AP) = n*(n + 1)=2, where n is a rank of the matrix A.
!!         On entry, the upper or lower triangle of matrix A, or its
!!         equilibration, in packed storage. The elements are stored
!!         columnwise as follows:
!!         if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, if FACT = "E", then the equilibrated version of A is
!!         stored in AP; otherwise, AP is unchanged.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the scaled version of B if the system has been
!!         equilibrated; otherwise, B is unchanged.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AFP     Optional (input or output) REAL or COMPLEX array, shape (:)
!!         with the same size as AP.
!!         If FACT = "F" then AFP is an input argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A, in the same storage format as A, returned by
!!         a previous call to LA_PPSVX.
!!         If FACT 6= "F" then AFP is an output argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A in the same storage format as A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A is supplied
!!         on entry, and, if not, whether A should be equilibrated before
!!         it is factored.
!!           = "N": The matrix A will be copied to AFP and factored
!!                (no equilibration).
!!           = "E": The matrix A will be equilibrated, then copied to AFP
!!                and factored.
!!           = "F": AFP contains the factored form of (the equilibrated) A.
!!         Default value: "N".
!! EQUED   Optional (input or output) CHARACTER(LEN=1).
!!         Specifies the form of equilibration that was done.
!!         EQUED is an input argument if FACT = "F", otherwise it is an
!!         output argument:
!!           = "N": No equilibration (always true if FACT = "N").
!!           = "Y": Equilibration, i.e., A has been premultiplied and
!!                postmultiplied by diag(S).
!!         Default value: "N".
!! S       Optional (input or output) REAL array, shape (:) with size(S)
!!         = size(A,1).
!!         The scaling factors for A.
!!         S is an input argument if FACT = "F" and EQUED = "Y".
!!         S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR    Optional (output) REAL array of shape (:), with size(FERR) =
!!         size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j) , FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of (the
!!         equilibrated) A. If RCOND is less than the machine precision,
!!         the matrix is singular to working precision. This condition is
!!         indicated by a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!               is not positive definite, so the factorization could
!!               not be completed and the solution and error bounds
!!               could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!               machine precision, so the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!               error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SAF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPPSVX_F95
 SUBROUTINE CPTSV1_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    COMPLEX(WP), INTENT(INOUT) :: E(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, 1, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPTSV1_F95
 SUBROUTINE CPTSV_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    COMPLEX(WP), INTENT(INOUT) :: E(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSV computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. A is factored as A = L*D*L^H, where L
!! is a unit lower bidiagonal matrix and D is a diagonal matrix. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!        SUBROUTINE LA_PTSV( D, E, B, INFO=info )
!!            REAL(<wp>), INTENT(INOUT) :: D(:)
!!            <type>(<wp>), INTENT(INOUT) :: E(:), <rhs>
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal of A.
!!        On exit, the diagonal of D.
!! E      (input/output) REAL or COMPLEX array, shape (:), with
!!        size(E) = n-1.
!!        On entry, the subdiagonal of A.
!!        On exit, the subdiagonal of L.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, the leading minor of order i of A is not
!!             positive definite, and the solution has not been computed.
!!           The factorization has not been completed unless i = n.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, NRHS, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE CPTSV_F95
SUBROUTINE CPTSVX1_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   COMPLEX(WP), INTENT(IN) :: E(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SDF, SEF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LDF(:)
   COMPLEX(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -3
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, 1, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPTSVX1_F95
SUBROUTINE CPTSVX_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   COMPLEX(WP), INTENT(IN) :: E(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSVX computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors.
!!    LA_PTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_PTSVX( D, E, B, X, DF=df, EF=ef, FACT=fact, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, INFO=info )
!!          REAL(<wp>), INTENT(IN) :: D(:)
!!          <type>(<wp>), INTENT(IN) :: E(:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: DF(:)
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: EF(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! D       (input) REAL array, shape (:) with size(D) = n, where n is the
!!         order of A.
!!         The diagonal of A.
!! E       (input) REAL or COMPLEX array, shape (:) with size(E) = n-1.
!!         The subdiagonal of A.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) = n
!!         or shape (:) with size(B) = n.
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! DF      Optional (input or output) REAL array, shape (:) with the same
!!         size as D.
!!         If FACT = "F", then DF is an input argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!!         If FACT = "N", then DF is an output argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!! EF      Optional (input or output) REAL or COMPLEX array, shape (:) with
!!         the same size as E.
!!         If FACT = "F", then EF is an input argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!!         If FACT = "N", then EF is an output argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of A has been supplied on
!!         entry.
!!           = "N": The matrix A will be copied to DF and EF and factored.
!!           = "F": DF and EF contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j), FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element in
!!         X(j).
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL.
!!         The estimate of the reciprocal condition number of the matrix
!!         A. If RCOND is less than the machine precision, the matrix is
!!         singular to working precision. This condition is indicated by
!!         a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of A is not positive
!!                definite, so the factorization could not be completed
!!                unless i = n, and the solution and error bounds could
!!                not be computed. RCOND = 0 is returned.
!!             = n+1: L is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error
!!                  bounds are computed because the computed solution can
!!                  be more accurate than the value of RCOND would suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SDF, SEF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LDF(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -3
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, NRHS, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CPTSVX_F95
 SUBROUTINE CSPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CSPSV1_F95
 SUBROUTINE CSPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CSPSV_F95
SUBROUTINE CSPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CSPSVX1_F95
SUBROUTINE CSPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,2*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CSPSVX_F95

SUBROUTINE CSYSV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "CSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CSYSV1_F95
 SUBROUTINE CSYSV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "CSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE CSYSV_F95
SUBROUTINE CSYSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,2*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CSYSVX1_F95
SUBROUTINE CSYSVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "CSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE CSYSVX_F95

SUBROUTINE CUNGTR_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: UNGTR_F77 => LA_UNGTR, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: TAU(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_ORGTR / LA_UNGTR generates a real orthogonal / complex unitary
!! matrix Q which is defined as the product of elementary reflectors,
!! as returned by LA_SYTRD / LA_HETRD:
!!
!! if UPLO = "U", Q = H(n-1) . . . H(2) H(1),
!
!! if UPLO = "L", Q = H(1) H(2) . . . H(n-1).
!
!! =======
!
!!    SUBROUTINE LA_ORGTR / LA_UNGTR( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(IN) :: TAU(:)
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the vectors which define the elementary
!!            reflectors, as returned by LA_SYTRD or LA_HETRD.
!!         On exit the orthogonal or unitary matrix Q.
!
!! TAU     (input) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         TAU(i) must contain the scalar factor of the elementary
!!         reflector H(i), as returned by LA_SYTRD or LA_HETRD.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! ----------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_UNGTR"
   CHARACTER(LEN=5), PARAMETER :: BSNAM  = "CUNGQ"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   CHARACTER(LEN=6) :: BSNAME
   INTEGER :: LINFO, LWORK, NB, ISTAT, ISTAT1, N, LD
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      IF( LSAME(LUPLO,"U") )THEN; BSNAME = BSNAM // "L"
      ELSE; BSNAME = BSNAM // "R"; ENDIF
      NB = ILAENV_F77( 1, BSNAME, " ", N-1, N-1, N-1, -1 )
      IF( NB < 1 .OR. NB >= N ) NB = 1
      LWORK = MAX( 1, (N-1)*NB ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT)
         LWORK = MAX( 1, N-1 ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!     .. CALL LAPACK77 ROUTINE
         CALL UNGTR_F77( LUPLO, N, A, LD, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE CUNGTR_F95
 SUBROUTINE DGBSV1_F95( A, B, K, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: K
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, LK, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LK -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LK -1
          CALL GBSV_F77( N, LK, KU, 1, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGBSV1_F95
 SUBROUTINE DGBSV_F95( A, B, KL, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: KL
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GBSV computes the solution to a real or complex linear system
!! of equations A*X = B, where A is a square band matrix and X and B are
!! rectangular matrices or vectors. The LU decomposition with row
!! interchanges is used to factor A as A = L*U , where L is a product of
!! permutation and unit lower triangular matrices with kl subdiagonals,
!! and U is upper triangular with kl + ku superdiagonals. The factored
!! form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSV( AB, B, KL=kl, IPIV=ipiv, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             INTEGER, INTENT(IN), OPTIONAL :: KL
!!             INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!         with size(AB,1) = 2*kl+ku+1 and size(AB,2) = n, where kl and ku
!!         are, respectively, the numbers of subdiagonals and
!!         superdiagonals in the band of A, and n is the order of A.
!!         On entry, the matrix A in band storage. The (kl + ku + 1)
!!         diagonals of A are stored in rows (kl + 1) to (2*kl + ku + 1)
!!         of AB, so that the j-th column of A is stored in the j-th
!!         column of AB as follows:
!!         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                        1<=j<=n
!!         The remaining elements in AB need not be set.
!!         On exit, details of the factorization. U is an upper triangular
!!         band matrix with (kl + ku + 1) diagonals. These are stored in
!!         the first (kl + ku + 1) rows of AB. The multipliers that arise
!!         during the factorization are stored in the remaining rows.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! KL      Optional (input) INTEGER.
!!         The number of subdiagonals in the band of A (KL = kl).
!!         The number of superdiagonals in the band is given by
!!         ku = size(AB,1) - 2 * kl - 1.
!!         Default value: (size(AB,1)-1)/3.
!! IPIV    Optional (output) INTEGER array, shape (:) with size(IPIV) = n.
!!         The pivot indices that define the row interchanges; row i of the
!!         matrix was interchanged with row IPIV(i).
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, U(i,i) = 0. The factorization has been
!!         completed, but the factor U is singular, so the solution could
!!         not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, NRHS, LKL, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LKL -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LKL -1 < 0 .OR. LKL < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LKL -1
          CALL GBSV_F77( N, LKL, KU, NRHS, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGBSV_F95
SUBROUTINE DGBSVX1_F95(A, B, X, KL, AF, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, &
              SC, SR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LC(:), LR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = 2*LKL+LKU+1; S2AF = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA - LKL -LKU -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AF /= 2*LKL+LKU+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, 1, A, LDA, LAF, S1AF, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGBSVX1_F95
SUBROUTINE DGBSVX_F95(A, B, X, KL, AFB, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFB(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GBSVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square band matrix and X and B are rectangular matrices or vectors.
!!    LA_GBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSVX( AB, B, X, KL=kl, AFB=afb, IPIV=ipiv, &
!!                  FACT=fact, TRANS=trans, EQUED=equed, R=r, C=c, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, &
!!                  RPVGRW=rpvgrw, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          INTEGER, INTENT(IN), OPTIONAL :: KL
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: C(:), R(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB        (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!           with size(AB,1) = kl + ku + 1 and size(AB,2) = n, where kl
!!           and ku are, respectively, the numbers of subdiagonals and
!!           superdiagonals in the band of A, and n is the order of A.
!!           On entry, the matrix A or its equilibration in band storage.
!!           The (kl + ku + 1) diagonals of A are stored in rows 1 to
!!           (kl + ku + 1) of AB, so that the j-th column of A is
!!           stored in the j-th column of AB as follows:
!!           AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                     1<=j<=n.
!!           The remaining elements in AB need not be set.
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during the previous call
!!           to LA GBSVX.
!!           On exit, if FACT = "E", the equilibrated version of A is
!!           stored in AB; otherwise, AB is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = n or shape (:) with size(B) = n.
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!           and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!           The solution matrix X .
!! KL        Optional (input) INTEGER.
!!           The number of subdiagonals in the band of A (KL = kl).
!!           The number of superdiagonals in the band is given by
!!           ku =  size(AB,1) - kl - 1.
!!           Default value: (size(AB,1) - 1) / 2.
!! AFB       Optional (input or output) REAL or COMPLEX rectangular array,
!!           shape (:,:) with size(AFB,1) = 2*kl+ku+1 and size(AFB,2)=n
!!           If FACT = "F" then AFB is an input argument that contains the
!!           details of the factorization of (the equilibrated) A returned
!!           by a previous call to LA_GBSVX.
!!           If FACT /= "F" then AFB is an output argument that contains
!!           the details of the factorization of (the equilibrated) A. U is
!!           an upper triangular band matrix with (kl + ku + 1) diagonals.
!!           These are stored in the first (kl + ku + 1) rows of AFB. The
!!           multipliers that arise during the factorization are stored in
!!           the remaining rows.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = n.
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A, returned by a previous call to LA_GBSVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!             = "N": The matrix A will be copied to AFB and factored (no
!!                  equilibration).
!!             = "E": The matrix A will be equilibrated, then copied to
!!                  AFB and factored.
!!             = "F": AFB and IPIV contain the factored form of (the
!!                  equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!             = "N": A*X = B (No transpose)
!!             = "T": A^T*X = B (Transpose)
!!             = "C": A^H*X = B (Conjugate transpose)
!!           Default value: "N".
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!             = "N": No equilibration (always true if FACT = "N").
!!             = "R": Row equilibration, i.e., A has been premultiplied
!!                  by diag(R).
!!             = "C": Column equilibration, i.e., A has been postmultiplied
!!                  by diag(C).
!!             = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with
!!           size(R) = size(A,1).
!!           The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with
!!           size(C) = size(A,1).
!!           The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j), FERR(j) is an
!!           estimated upper bound for the magnitude of the largest element
!!           in (X(j)-XTRUE) divided by the magnitude of the largest
!!           element in X(j). The estimate is as reliable as the estimate
!!           for RCOND and is almost always a slight overestimate of the
!!           true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any element
!!           of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition is
!!           indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!             <= n: U(i,i) = 0. The factorization has been completed,
!!                 but the factor U is singular, so the solution could
!!                 not be computed.
!!             = n+1: U is nonsingular, but RCOND is less than machine
!!                 precision, so the matrix is singular to working
!!                 precision. Nevertheless, the solution and error
!!                 bounds are computed because the computed solution can
!!                 be more accurate than the value of RCOND would suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, S1AFB, S2AFB, &
              SC, SR, SFERR, SBERR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAFB(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); NRHS = SIZE(B, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFB) )THEN; S1AFB = SIZE(AFB,1); S2AFB = SIZE(AFB,2)
   ELSE; S1AFB = 2*LKL+LKU+1; S2AFB = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AFB /= 2*LKL+LKU+1 .OR. S2AFB /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -12
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -13
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFB) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFB) ) THEN; ALLOCATE( LAFB(S1AFB,N), STAT=ISTAT )
      ELSE; LAFB => AFB; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, NRHS, A, LDA, LAFB, S1AFB, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AFB) ) DEALLOCATE( LAFB, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGBSVX_F95
      SUBROUTINE DGBTRF_F95( A, K, M, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GBTRF_F77 => LA_GBTRF, LANGB_F77 => LA_LANGB, & !!((07-B-INT_LAPACK1.f90))
                                          GBCON_F77 => LA_GBCON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(IN), OPTIONAL :: K, M
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      REAL(WP), INTENT( INOUT ) :: A( :, : )
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBTRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV, &
                 LK, KU, LM
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:), IWORK(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      LD = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0
      IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LD-1)/3; ENDIF
      IF( PRESENT(M) ) THEN; LM = M; ELSE; LM = N; ENDIF; MINMN = MIN(LM,N)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( N < 0 .OR. LD < 0 )THEN; LINFO = -1
      ELSE IF( LD - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -2
      ELSE IF( LM < 0 )THEN; LINFO = -3
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -4
      ELSE IF( PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -5
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -6
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( WORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGB_F77( LNORM, MINMN, LK, KU, A, LD, WORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(WORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GBTRF_F77( LM, N, LK, KU, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(3*MINMN), IWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GBCON_F77( LNORM, MINMN, LK, KU, A, LD, LIPIV, &
                                     LANORM, RCOND, WORK, IWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE DGBTRF_F95
SUBROUTINE DGEEQU_F95( A, R, C, ROWCND, COLCND, AMAX, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEQU_F77 => LA_GEEQU                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT( OUT ), OPTIONAL :: AMAX, COLCND, ROWCND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT( IN ) :: A( :, : )
   REAL(WP), INTENT( OUT ) :: C( : ), R( : )
!---------------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GEEQU computes row and column scalings intended to equilibrate a
!! rectangle matrix A and reduce its condition number.  R returns the
!! row scale factors and C the column scale factors, chosen to try to
!! make the largest entry in each row and column of the matrix B with
!! elements B(i,j) = R(i) A(i,j) C(j) have absolute value 1.
!
!! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
!! number and BIGNUM = largest safe number. Use of these scaling
!! factors is not guaranteed to reduce the condition number of A but
!! works well in practice.
!
!! Arguments
!! =========
!
!! SUBROUTINE LA_GEEQU ( A, R, C, ROWCND, COLCND, AMAX, INFO )
!!    <type>(<wp>), INTENT(IN) :: A(:,:)
!!    REAL(<wp>), INTENT( OUT ) :: R(:), C(:)
!!    REAL(<wp>), INTENT( OUT ), OPTIONAL :: ROWCND, COLCND, AMAX
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! ====================
!
!! A       (input) either REAL or COMPLEX array, shape (:,:).
!!         The matrix A, whose equilibration factors are to be computed.
!
!! R       (output) REAL array, shape (:), size(R) == size(A,1).
!!         If INFO = 0 or INFO > size(A,1), R contains the row
!!         scale factors for A.
!
!! C       (output) REAL array, shape (:), size(C) == size(A,2).
!!         If INFO = 0, C contains the column scale factors for A.
!
!! ROWCND  Optional (output) REAL.
!!         If INFO = 0 or INFO > size(A,1), ROWCND contains the ratio
!!         of the smallest R(i) to the largest R(i).  If ROWCND >= 0.1
!!         and AMAX is neither too large nor too small, it is not worth
!!         scaling by R.
!
!! COLCND  Optional (output) REAL.
!!         If INFO = 0, COLCND contains the ratio of the smallest
!!         C(i) to the largest C(i).  If COLCND >= 0.1, it is not
!!         worth scaling by C.
!
!! AMAX    Optional (output) REAL.
!!         Absolute value of largest matrix element.  If AMAX is very
!!         close to overflow or very close to underflow, the matrix
!!         should be scaled.
!
!! INFO    Optional (output) INTEGER
!!         If INFO is present
!!            = 0:  successful exit
!!            < 0:  if INFO = -k, the k-th argument had an illegal value
!!            > 0:  if INFO = k,  and k is
!!                  <= M:  the k-th row of A is exactly zero
!!                  >  M:  the (k-M)-th column of A is exactly zero
!!                         where M = size(A,1)
!!         If INFO is not present and an error occurs, then the program is
!!            terminated with an error message.
!
!-------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEQU"
!!  .. LOCAL SCALARS ..
   INTEGER :: LINFO, M, N
   REAL(WP) :: LAMAX, LCOLCND, LROWCND
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; M = SIZE(A, 1); N = SIZE(A, 2)
!!  .. TEST THE ARGUMENTS
   IF ( SIZE(R) /= M ) THEN; LINFO = -2
   ELSE IF ( SIZE(C) /= N ) THEN; LINFO = -3
   ELSE
!!     .. CALL LAPACK77 ROUTINE
      CALL GEEQU_F77( M, N, A, MAX(1,M), R, C, LROWCND, LCOLCND, LAMAX, LINFO )
      IF( PRESENT( ROWCND ) ) ROWCND = LROWCND
      IF( PRESENT( COLCND ) ) COLCND = LCOLCND
      IF( PRESENT( AMAX ) ) AMAX = LAMAX
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE DGEEQU_F95
    SUBROUTINE DGEES_F95( A, WR, WI, VS, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEES_F77 => LA_GEES                                !!((07-B-INT_LAPACK1.f90))
!!  use LA_EXTERNAL, ONLY: SELECT
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
   INTERFACE
      LOGICAL FUNCTION SELECT(WR, WI)
         use KND_LA_PRECISION, ONLY: WP => DP                                !!((05-B-KND_LA_PRECISION.f90))
         REAL(WP), INTENT(IN) :: WR, WI
      END FUNCTION SELECT
   END INTERFACE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GEES computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! Schur factorization
!!                        A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left. The leading
!! columns of Z then form an orthonormal basis for the invariant subspace
!! corresponding to the selected eigenvalues.
!!      A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks are
!! standardized in the form
!!                       [ a  b ]
!!                       [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!! A complex matrix is in complex-Schur form if it is upper triangular.
!!
!! =========
!!
!!        SUBROUTINE LA_GEES( A, <w>, VS=vs, SELECT=select, &
!!                                   SDIM=sdim, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           <type>(<wp>), INTENT(OUT) :: <w(:)>
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!           INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!           END INTERFACE
!!           OPTIONAL :: SELECT
!!           INTEGER, INTENT(OUT), OPTIONAL :: SDIM, INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <w>    ::= WR, WI | W
!!           <w(:)> ::= WR(:), WI(:) | W(:)
!!           <w(j)> ::= WR(j) , WI(j) |  W(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the Schur form T.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues in the order in which they appear on
!!          the diagonal of the Schur form T.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VS       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VS,1) = size(A,1).
!!          The matrix Z of Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION.
!!          LOGICAL FUNCTION SELECT( <w(j)> )
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!          where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j) , WI(j) | W(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!             interface in the calling (sub)program.
!!          2. SELECT is called by LA_GEES for every computed eigenvalue
!!           w(j) (but only once for a complex conjugate pair when A is
!!           real). It is used to select the eigenvalues that will be
!!             ordered to the top left of the Schur form. The eigenvalue
!!           w(j) is selected if SELECT(w(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!           SELECT(w(j)) = .TRUE. after ordering, since ordering may
!!           change the value of complex eigenvalues (especially if the
!!           eigenvalue is ill-conditioned). In this case INFO is set to
!!           size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which
!!          SELECT=.TRUE. (If A is real, complex conjugate pairs for which
!!          SELECT=.TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of w contain
!!                    those eigenvalues which have converged. VS contains
!!                    the matrix which reduces A to its partially converged
!!                    Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                  problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                  in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!-------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEES"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
!!  .. LOCAL ARRAYS ..
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   REAL(WP), TARGET :: LLVS(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LSDIM = 0
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(SDIM) .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      IF( ISTAT == 0 ) THEN
         LWORK = MAX( 1, 3*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 3*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VS) )THEN
          IF( PRESENT(SDIM) )THEN
             ALLOCATE(BWORK(N),STAT=ISTAT)
             CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        VS, S1VS, WORK, LWORK, BWORK, LINFO )
            ELSE
             CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        VS, S1VS, WORK, LWORK, LLBWORK, LINFO )
            ENDIF
          ELSE
           IF( PRESENT(SDIM) )THEN
              ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        LLVS, S1VS, WORK, LWORK, BWORK, LINFO )
           ELSE
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        LLVS, S1VS, WORK, LWORK, LLBWORK, LINFO )
          ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
!!      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   IF( PRESENT(SDIM) ) SDIM = LSDIM
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGEES_F95
 SUBROUTINE DGEESX_F95( A, WR, WI, VS, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEESX_F77 => LA_GEESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
   REAL(WP), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
      INTERFACE
         FUNCTION SELECT(WR, WI)
           use KND_LA_PRECISION, ONLY: WP => DP                              !!((05-B-KND_LA_PRECISION.f90))
           REAL(WP), INTENT(IN) :: WR, WI
            LOGICAL :: SELECT
         END FUNCTION SELECT
      END INTERFACE
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GEESX computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! factorization
!!                     A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left, computes a
!! reciprocal condition number for the average of the selected eigenvalues
!! and computes a reciprocal condition number for the right invariant
!! subspace corresponding to the selected eigenvalues. The leading columns
!! of Z form an orthonormal basis for this invariant subspace.
!! A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks
!! are standardized in the form
!!                        [ a  b ]
!!                        [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!!
!! =========
!!
!!       SUBROUTINE LA_GEESX( A, <w>, VS=vs, SELECT=select, SDIM=sdim, &
!!                              RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!            INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!            END INTERFACE
!!            OPTIONAL :: SELECT
!!            INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the Schur form T .
!! <w>     (output) REAL or COMPLEX array, shape (:) with size(w) =
!!         size(A,1).
!!         The computed eigenvalues in the order in which they appear on
!!         the diagonal of the Schur form T.
!!         <w(:)> ::= WR(:), WI(:) | W(:),
!!         where
!!         WR(:), WI(:) are of REAL type (for the real and imaginary
!!         parts) and W(:) is of COMPLEX type.
!!         Note: If A is real, then a complex-conjugate pair appear
!!         consecutively, with the eigenvalue having the positive
!!         imaginary part appearing first.
!! VS      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VS,1) = size(A,1).
!!         The matrix Z of Schur vectors.
!! SELECT  Optional (input) LOGICAL FUNCTION
!!         LOGICAL FUNCTION SELECT( <w(j)>)
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp> ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!         1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!         2. SELECT is called by LA_GEES for every computed eigenvalue
!!          <w(j)> (but only once for a complex conjugate pair when A
!!          is real). It is used to select the eigenvalues that will be
!!          ordered to the top left of the Schur form. The eigenvalue
!!          <w(j)> is selected if SELECT(<w(j)>) has the value .TRUE.
!!         3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<w(j)>) = .TRUE. after ordering, since ordering may
!!          change the value of complex eigenvalues (especially if the
!!          eigenvalue is ill-conditioned). In this case INFO is set to
!!          size(A,1) + 2 (see INFO below).
!!         Note: Select must be present if SDIM, RCONDE and RCONDF are
!!         desired.
!! SDIM    Optional (output) INTEGER.
!!         The number of eigenvalues (after sorting) for which
!!         SELECT = .TRUE. (If A is real, complex conjugate pairs for which
!!         SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE  Optional (output) REAL.
!!         The reciprocal condition number for the average of the selected
!!         eigenvalues.
!! RCONDV  Optional (output) REAL.
!!         The reciprocal condition number for the selected right
!!         invariant subspace.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of <w>
!!                    contain those eigenvalues which have converged.
!!                    VS contains the matrix which reduces A to its
!!                    partially converged Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                    problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                    in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0, LIWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
   REAL(WP) :: LRCONDE, LRCONDV
!!  .. LOCAL ARRAYS ..
   INTEGER, TARGET :: LLIWORK(1)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   REAL(WP), TARGET :: LLVS(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -4
   ELSE IF( LSAME(LSORT,"S") .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      IF( LSAME(LSORT,"S") )THEN; ALLOCATE(BWORK(N),STAT=ISTAT)
      ELSE; BWORK => LLBWORK; END IF
      IF( ISTAT == 0 )THEN
         IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN
            IWORK => LLIWORK; LIWORK = 1
          ELSE; LIWORK = MAX( 1, N*N/4, LIWORK )
            ALLOCATE( IWORK(LIWORK), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( LSAME(LSENSE,"N") ) THEN; LWORK = MAX( 1, 3*N, LWORK)
         ELSE; LWORK = MAX(1, 3*N, N+N*N/2, LWORK); ENDIF

!! NEXT LINE SHOULD BE REMOVED BUT CURRENTLY THERE IS BUG IN
!! DGEESX/DGEHRD SO WE NEED BIGGER BUFFER
         LWORK = MAX(1, 3*N, N+N*N/2)
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            IF( LSAME(LSENSE,"N") ) THEN; LWORK = MAX( 1, 3*N)
            ELSE; LWORK = MAX(1, 3*N, N+N*N/2); ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
       IF (PRESENT (VS)) THEN
         CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, WR, WI, &
     &                   VS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &                   IWORK, LIWORK,  BWORK, LINFO )
       ELSE
           CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, WR, WI, &
     &                   LLVS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &                   IWORK, LIWORK,  BWORK, LINFO )
       ENDIF
      IF( LINFO == 0 )THEN; LWORK = INT(WORK(1)+1); LIWORK = LSDIM*(N-LSDIM); ENDIF
      ELSE; LINFO = -100; ENDIF
      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( PRESENT(RCONDE) ) RCONDE = LRCONDE
      IF( PRESENT(RCONDV) ) RCONDV = LRCONDV
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      IF( LSAME(LSENSE,"V").OR.LSAME(LSENSE,"B") ) DEALLOCATE(IWORK,STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGEESX_F95
SUBROUTINE DGEEV_F95( A, WR, WI, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEV_F77 => LA_GEEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEV computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors. A
!! right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j).
!!
!! =========
!!
!!       SUBROUTINE LA_GEEV( A, <w>, VL=vl, VR=vr, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors were computed. Elements
!!          i+1 : n of <w> contain eigenvalues which have converged.
!!          n is the order of A
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      NN = 3; IF( LSAME(LJOBVL,"V").OR.LSAME(LJOBVR,"V") ) NN = NN + 1
      LWORK = MAX( 1, NN*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, NN*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VL) )THEN
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
              CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGEEV_F95
SUBROUTINE DGEEVX_F95( A, WR, WI, VL, VR, BALANC, ILO, IHI, &
                       SCALE, ABNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEVX_F77 => LA_GEEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, ILO, IHI
   REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: SCALE(:), RCONDE(:), RCONDV(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEVX computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors.
!! Optionally, it also balances A and computes reciprocal condition
!! numbers for the  eigenvalues and right eigenvectors.
!! A right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j). The computed
!! eigenvectors are normalized to have Euclidean norm equal to 1 and
!! largest component real.
!!        Balancing A involves permuting its rows and columns to make
!! it more nearly upper triangular and then scaling rows and columns by
!! a diagonal similarity transformation to reduce the condition numbers
!! of the eigenvalues and eigenvectors.
!!        Computed reciprocal condition numbers pertain to the matrix
!! after balancing. Permuting does not change condition numbers (in
!! exact arithmetic), but scaling does.
!
!! =========
!!
!!    SUBROUTINE LA_GEEVX( A, <w>, VL=vl, VR=vr, BALANC=balanc, ILO=ilo, &
!!                     IHI=ihi, SCALE=scale, ABNRM=abnrm, RCONDE=rconde, &
!!                     RCONDV=rcondv, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <w(:)>
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!         INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: SCALE(:), ABNRM, &
!!               RCONDE(:), RCONDV(:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!         <w>    ::= WR, WI | W
!!         <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC   Optional (input) CHARACTER(LEN=1).
!!          Indicates whether the input matrix should be permuted and/or
!!          diagonally scaled.
!!             = "N": Do not permute or scale;
!!             = "P": Permute but do not scale;
!!             = "S": Scale but do not permute;
!!             = "B": Both permute and scale.
!!           Default value: "N".
!! ILO,IHI  Optional (output) INTEGER.
!!          ILO and IHI are determined when A is balanced. The balanced
!!          A(i,j) = 0 if i > j and j = 1, ..., ILO-1 or
!!          i = IHI+1, ... , size(A,1).
!! SCALE    Optional (output) REAL array, shape (:) with size(SCALE) =
!!          size(A,1).
!!          Details of the permutations and scaling factors applied when
!!          balancing A. If P(j) is the index of the row and column
!!          interchanged with row and column j, and D(j) is the
!!          scaling factor applied to row and column j, then
!!          P(j) = SCALE(j), j = 1, ..., ILO-1 and j =IHI+1, ...,  n
!!          D(j) = SCALE(j), j = ILO, ... , IHI.
!! ABNRM    Optional (output) REAL.
!!          The l1 norm of the balanced matrix (the maximum of the sum
!!          of absolute values of elements of any column).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE) =
!!          size(A,1). RCONDE(j) is the reciprocal condition number of
!!          the j-th eigenvalue.
!! RCONDV   Optional (output) REAL array, shape (:), size(RCONDV) =
!!          size(A,1). RCONDV(j) is the reciprocal condition number of
!!          the j-th right eigenvector.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors or condition numbers were
!!          computed; elements 1:ILO-1 and i+1:n of <w> contain
!!          eigenvalues which have converged.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LBALANC, LJOBVL, LJOBVR, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, NN, &
              LILO, LIHI, SSCALE, SRCONDE, SRCONDV
   REAL(WP) :: LABNRM
!!  .. LOCAL ARRAYS ..
   INTEGER, TARGET :: LLIWORK(1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP) :: WORKMIN(1)
   REAL(WP), POINTER :: LSCALE(:), LRCONDE(:), LRCONDV(:)
   REAL(WP), POINTER :: LLVL(:,:), LLVR(:,:)
   REAL(WP), POINTER :: WORK(:)

!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = N; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = N; LJOBVR = "N"; END IF
   IF( PRESENT(SCALE) )THEN; SSCALE = SIZE(SCALE); ELSE; SSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
                   LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -6
   ELSE IF( SSCALE /= N )THEN; LINFO = -9
   ELSE IF( SRCONDE /= N )THEN; LINFO = -11
   ELSE IF( SRCONDV /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
      IF( PRESENT(SCALE) )THEN; LSCALE => SCALE
      ELSE; ALLOCATE( LSCALE(N), STAT=ISTAT ); ENDIF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
         ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
         ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN; IWORK => LLIWORK
         ELSE; ALLOCATE( IWORK(MAX( 1, 2*N-2 )), STAT=ISTAT ); ENDIF
      END IF

      IF (LSAME (LSENSE,"E") .OR. LSAME(LSENSE,"B") ) THEN
        LJOBVL = "V"; LJOBVR = "V"; S1VR=N; S1VL=N
      ENDIF

      IF (PRESENT (VL)) THEN; LLVL => VL
      ELSE; ALLOCATE (LLVL(N,N), STAT = ISTAT); ENDIF
      IF (PRESENT (VR)) THEN; LLVR => VR
      ELSE; ALLOCATE (LLVR(N,N), STAT = ISTAT); ENDIF

      IF( ISTAT == 0 ) THEN
!! QUERY FOR THE SIZE OF WORK
         LWORK = -1
         IF (PRESENT (VL)) THEN
           IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ENDIF
          ENDIF
         LWORK = WORKMIN(1)

         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
            NN = MAX(1, 3*N, N*(N+6))
            LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF (PRESENT (VL)) THEN
          IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ENDIF
        ELSE
          IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ENDIF
        ENDIF
        IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
        ELSE; LINFO = -100; ENDIF
      IF( PRESENT(ILO) ) ILO = LILO; IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( .NOT. PRESENT(SCALE) ) DEALLOCATE( LSCALE, STAT=ISTAT1 )
      IF( .NOT. PRESENT(RCONDE) ) DEALLOCATE( LRCONDE, STAT=ISTAT1 )
      IF( .NOT. PRESENT(RCONDV) ) DEALLOCATE( LRCONDV, STAT=ISTAT1 )
      IF( LSAME(LSENSE,"V").OR.LSAME(LSENSE,"B") ) DEALLOCATE(IWORK,STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
      IF (.NOT.PRESENT (VL)) DEALLOCATE(LLVL)
      IF (.NOT.PRESENT (VR)) DEALLOCATE(LLVR)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)

END SUBROUTINE DGEEVX_F95
    SUBROUTINE DGEGS_F95( A, B, ALPHAR, ALPHAI, BETA, VSL, VSR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGS_F77 => LA_GEGS                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGS computes for a pair of n-by-n real nonsymmetric matrices
!!  A, B: the generalized eigenvalues (alphar alpha, beta),
!!  the Schur form (A, B), and optionally left and/or right
!!  Schur vectors (VSL and VSR).
!
!!  (If only the generalized eigenvalues are needed, use the driver SGEGV
!!  instead.)
!
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!
!!  The (generalized) Schur form of a pair of matrices is the result of
!!  multiplying both matrices on the left by one orthogonal matrix and
!!  both on the right by another orthogonal matrix, these two orthogonal
!!  matrices being chosen so as to bring the pair of matrices into
!!  (real) Schur form.
!
!!  A pair of matrices A, B is in generalized real Schur form if B is
!!  upper triangular with non-negative diagonal and A is block upper
!!  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
!!  to real generalized eigenvalues, while 2-by-2 blocks of A will be
!!  "standardized" by making the corresponding elements of B have the
!!  form:
!!          [  a  0  ]
!!          [  0  b  ]
!
!!  and the pair of corresponding 2-by-2 blocks in A and B will
!!  have a complex conjugate pair of generalized eigenvalues.
!
!!  The left and right Schur vectors are the columns of VSL and VSR,
!!  respectively, where VSL and VSR are the orthogonal matrices
!!  which reduce A and B to Schur form:
!
!!  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
!
!! =========
!
!!   SUBROUTINE LA_GEGS( A, B, <alpha>, BETA, VSL, VSR, INFO )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose generalized
!!      eigenvalues and (optionally) Schur vectors are to be
!!      computed.
!!      On exit, the generalized Schur form of A.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      A should be less than the overflow threshold.
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) Schur vectors are
!!      to be computed.
!!      On exit, the generalized Schur form of B.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      B should be less than the overflow threshold.
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
!!      j=1,...,n  and  BETA(j),j=1,...,n  are the diagonals of the
!!      complex Schur form (A,B) that would result if the 2-by-2
!!      diagonal blocks of the real Schur form of (A,B) were further
!!      reduced to triangular form using 2-by-2 complex unitary
!!      transformations.  If ALPHAI(j) is zero, then the j-th
!!      eigenvalue is real; if positive, then the j-th and (j+1)-st
!!      eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
!!      negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VSL  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSL will contain the left Schur vectors. (See "Purpose", above.)
!
!! VSR  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSR will contain the right Schur vectors. (See "Purpose", above.)
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  (A,B) are not in Schur
!!            form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
!!            be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_GGBAK (computing VSL)
!!            =n+8: error return from LA_GGBAK (computing VSR)
!!            =n+9: error return from LA_LASCL (various places)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VSL, S2VSL, S1VSR, S2VSR, &
              SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), POINTER :: WORK(:), &
     &                   LALPHAR(:), LALPHAI(:), LBETA(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHAR) )THEN; SALPHAR = SIZE(ALPHAR); ELSE; SALPHAR = N; ENDIF
   IF( PRESENT(ALPHAI) )THEN; SALPHAI = SIZE(ALPHAI); ELSE; SALPHAI = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHAR) )THEN; LALPHAR => ALPHAR
      ELSE; ALLOCATE(LALPHAR(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(ALPHAI) )THEN; LALPHAI => ALPHAI
         ELSE; ALLOCATE(LALPHAI(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 4*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 4*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VSL, S1VSL, VSR, S1VSR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVSL, S1VSL, VSR, S1VSR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGEGS_F95
    SUBROUTINE DGEGV_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGV_F77 => LA_GEGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGV computes for a pair of N-by-N complex nonsymmetric
!!  matrices A and B, the generalized eigenvalues (alpha, beta),
!!  and optionally, the left and/or right generalized eigenvectors
!!  (VL and VR).
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!!  A right generalized eigenvector corresponding to a generalized
!!  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
!!  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
!!  l such that l**H * (A - w B) = 0, where l**H is the
!!  conjugate-transpose of l.
!!  Note: this routine performs "full balancing" on A and B -- see
!!  "Further Details", below.
!
!! =========
!
!!   SUBROUTINE LA_GEGV( A, B, <alpha>, BETA, VL, VR, INFO )
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of A on exit, see "Further
!!      Details", below.)
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of B on exit, see "Further
!!      Details", below.)
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  If ALPHAI(j) is zero, then
!!      the j-th eigenvalue is real; if positive, then the j-th and
!!      (j+1)-st eigenvalues are a complex conjugate pair, with
!!      ALPHAI(j+1) negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VL   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VL,1) == SIZE(VL,2) == n.
!!      The left generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! VR   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VR,1) == SIZE(VR,2) == n.
!!      The right generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  No eigenvectors have been
!!            calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
!!            should be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_TGEVC
!!            =n+8: error return from LA_GGBAK (computing VL)
!!            =n+9: error return from LA_GGBAK (computing VR)
!!            =n+10: error return from LA_LASCL (various calls)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!! Further Details
!! ===============
!
!! Balancing
!! ---------
!
!! This driver calls SGGBAL to both permute and scale rows and columns
!! of A and B.  The permutations PL and PR are chosen so that PL*A*PR
!! and PL*B*R will be upper triangular except for the diagonal blocks
!! A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
!! possible.  The diagonal scaling matrices DL and DR are chosen so
!! that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
!! one (except for the elements that start out zero.)
!
!! After the eigenvalues and eigenvectors of the balanced matrices
!! have been computed, SGGBAK transforms the eigenvectors back to what
!! they would have been (in perfect arithmetic) if they had not been
!! balanced.
!
!! Contents of A and B on Exit
!! -------- -- - --- - -- ----
!
!! If any eigenvectors are computed (either VL or VR or both), then on
!! exit the arrays A and B will contain the real Schur form[*] of the
!! "balanced" versions of A and B. If no eigenvectors are computed,
!! then only the diagonal blocks will be correct.
!
!! [*] See LA_HGEQZ, LA_GEGS, or read the book "Matrix Computations",
!!     by Golub & van Loan, pub. by Johns Hopkins U. Press.
!--------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, &
              SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   REAL(WP), POINTER :: WORK(:), LALPHAR(:), &
                        LALPHAI(:), LBETA(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHAR) )THEN; SALPHAR = SIZE(ALPHAR); ELSE; SALPHAR = N; ENDIF
   IF( PRESENT(ALPHAI) )THEN; SALPHAI = SIZE(ALPHAI); ELSE; SALPHAI = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHAR) )THEN; LALPHAR => ALPHAR
      ELSE; ALLOCATE(LALPHAR(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(ALPHAI) )THEN; LALPHAI => ALPHAI
         ELSE; ALLOCATE(LALPHAI(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 8*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 8*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VL) )THEN
          IF( PRESENT(VR) )THEN
            CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
             CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
          ELSE
           IF( PRESENT(VR) )THEN
             CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
          ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGEGV_F95
 SUBROUTINE DGELS1_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "D"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"T") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, 1, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGELS1_F95
 SUBROUTINE DGELS_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GELS computes the minimum-norm least squares solution to one
!! or more real or complex linear systems of the form A*x = b, A^T*x = b
!! or A^H*x = b using a QR or LQ factorization of A. Matrix A is
!! rectangular assumed to be of full rank. The vectors b and correspon-
!! ding solution vectors x are the columns of matrices denoted B and X,
!! respectively.
!!
!! ==========
!!
!!       SUBROUTINE LA_GELS( A, B, TRANS=trans, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX rectangular array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, if size(A,1) >= size(A,2), A is overwritten by
!!          details of its QR factorization. If size(A,1) < size(A,2), A
!!          is overwritten by details of its LQ factorization.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!          size(B) = max(size(A,1); size(A,2)).
!!          On entry, the matrix B.
!!          On exit, the solution matrix X. There are four cases:
!!          1. If TRANS = "N" and size(A,1) >= size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the least squares
!!             solution vector(s); the residual sum of squares for the
!!             solution vector in a column of B is given by the sum of
!!             squares of elements in rows size(A,2)+1 to size(A,1) of
!!             that column.
!!          2. If TRANS = "N" and size(A,1) < size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the minimum norm
!!             solution vector(s).
!!          3. If TRANS = "T" or TRANS = "C", and size(A,1)>=size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             minimum norm solution vector(s).
!!          4. If TRANS = "T" or TRANS = "C", and size(A,1) < size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             least squares solution vector(s); the residual sum of
!!             squares for the solution vector in a column of B is given
!!             by the sum of squares of elements in rows size(A,1)+1 to
!!             size(A,2) of that column.
!! TRANS    Optional (input) CHARACTER(LEN=1).
!!          Specifies the form of the system of equations:
!!          = "N": Ax = b (No transpose)
!!          = "T": A^T*x = b (Transpose)
!!          = "C": A^H*x = b (Conjugate transpose)
!!          Default value: "N".
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!---------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "D"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, NRHS
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"T") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, NRHS, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N,NRHS)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGELS_F95
SUBROUTINE DGELSD1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT,  LWORK, N, M, MN, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      REAL(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    SMLSIZ = ILAENV_F77( 9, "DGELSD", " ", 0, 0, 0, 0 )
    NLVL = INT( LOG( DBLE( MAX(1,MN) ) / DBLE( SMLSIZ+1 ) ) / LOG( TWO ) )
      LIWORK = 3*MAX(M,N)*(3 * NLVL + 11 )
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
      LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N)) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
      IF( PRESENT(S) )THEN; LS => S
      ELSE; ALLOCATE( LS(MN), STAT = ISTAT );
        IF (ISTAT /= 0) THEN
          LINFO = -100
          GOTO 100
        ENDIF
      END IF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
&       LS, LRCOND, LRANK, WORKMIN, LWORK, IWORKMIN,  LINFO )
      LWORK = WORKMIN(1)

      ALLOCATE( WORK(LWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 200
      ENDIF
      ALLOCATE( IWORK(LIWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 250
      ENDIF
      CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, SIZE(B,1), &
&       LS, LRCOND, LRANK, WORK, LWORK, IWORK, LINFO )
      IF( PRESENT(RANK) ) RANK = LRANK

300     DEALLOCATE(IWORK)
250     DEALLOCATE(WORK)
200     IF (.NOT. PRESENT(S)) DEALLOCATE(LS)
ENDIF
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGELSD1_F95
SUBROUTINE DGELSD_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, NRHS, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      REAL(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    SMLSIZ = ILAENV_F77( 9, "DGELSD", " ", 0, 0, 0, 0 )
    NLVL = INT( LOG( DBLE( MAX(1,MN) ) / DBLE( SMLSIZ+1 ) ) / LOG( TWO ) )
      LIWORK = 3*MAX(M,N)*(3 * NLVL + 11 )
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
      LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
      IF( PRESENT(S) )THEN; LS => S
      ELSE; ALLOCATE( LS(MN), STAT = ISTAT );
        IF (ISTAT /= 0) THEN
          LINFO = -100
          GOTO 100
        ENDIF
      END IF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
&       LS, LRCOND, LRANK, WORKMIN, LWORK, IWORKMIN,  LINFO )
      LWORK = WORKMIN(1)

      ALLOCATE( WORK(LWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 200
      ENDIF
      ALLOCATE( IWORK(LIWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 250
      ENDIF
      CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, SIZE(B,1), &
&       LS, LRCOND, LRANK, WORK, LWORK, IWORK, LINFO )
      IF( PRESENT(RANK) ) RANK = LRANK

300     DEALLOCATE(IWORK)
250     DEALLOCATE(WORK)
200     IF (.NOT. PRESENT(S)) DEALLOCATE(LS)
ENDIF
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGELSD_F95
 SUBROUTINE DGELSS1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "D"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:), LS(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = 1; MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 3*MIN(M,N) + MAX( 2*MIN(M,N), MAX(M,N), NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGELSS1_F95
 SUBROUTINE DGELSS_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "D"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:), LS(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 3*MIN(M,N) + MAX( 2*MIN(M,N), MAX(M,N), NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGELSS_F95
 SUBROUTINE DGELSX1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF
       IF( ISTAT == 0 ) THEN
          LWORK = MAX( 1, MIN(M,N) + 3*N, 2*MIN(M,N) + 1 )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSX_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         LJPVT, LRCOND, LRANK, WORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGELSX1_F95
 SUBROUTINE DGELSX_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GELSX computes the minimum-norm solution to a real linear least
!! squares problem:
!!     minimize || A * X - B ||
!! using a complete orthogonal factorization of A.  A is an m-by-n
!! matrix which may be rank-deficient.
!! Several right hand side vectors b and solution vectors x can be
!! handled in a single call; they are stored as the columns of the
!! M-by-NRHS right hand side matrix B and the n-by-nrhs solution
!! matrix X.
!! The routine first computes a QR factorization with column pivoting:
!!     A * P = Q * [ R11 R12 ]
!!                 [  0  R22 ]
!! with R11 defined as the largest leading submatrix whose estimated
!! condition number is less than 1/RCOND.  The order of R11, RANK,
!! is the effective rank of A.
!! Then, R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal transformations from the right, arriving at the
!! complete orthogonal factorization:
!!    A * P = Q * [ T11 0 ] * Z
!!                [  0  0 ]
!! The minimum-norm solution is then
!!    X = P * Z" [ inv(T11)*Q1"*B ]
!!               [        0       ]
!! where Q1 consists of the first RANK columns of Q.
!
!
!! Arguments
!! =========
!
!!  SUBROUTINE LA_GELSX( A, B, RANK, JPVT, RCOND, INFO )
!!    <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!    INTEGER, INTENT(IN), OPTIONAL :: RANK
!!    INTEGER, INTENT(OUT), OPTIONAL :: JPVT(:)
!!    REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A    (input/output) Deither REAL or COMPLEX array, shape (:,:),
!!      SIZE(A,1) == m, SIZE(A,2) == n.
!!      On entry, the m-by-n matrix A.
!!      On exit, A has been overwritten by details of its
!!      complete orthogonal factorization.
!!      INFO = -1 if SIZE(A,1) < 0 or SIZE(A,2) < 0
!
!! B    Optional (input/output) either REAL or COMPLEX array, shape either
!!      (:,:) or (:), size(B,1) or size(B) == size(A,1). SIZE(B,2) == nrhs.
!!      On entry, the m-by-nrhs right hand side matrix B.
!!      On exit, the n-by-nrhs solution matrix X.
!!      If m >= n and RANK = n, the residual sum-of-squares for
!!      the solution in the i-th column is given by the sum of
!!      squares of elements n+1:m in that column.
!!      INFO = -2 if SIZE(B,1) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                    and if shape of B is (:,:) or
!!                if SIZE(B) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                   and if shape of B is (:)
!
!! RANK Optional (output) INTEGER
!!      The effective rank of A, i.e., the order of the submatrix
!!      R11.  This is the same as the order of the submatrix T11
!!      in the complete orthogonal factorization of A.
!
!! JPVT Optional (input/output) INTEGER array, shape (:), SIZE(JPVT) == n
!!      On entry, if JPVT(i) .ne. 0, the i-th column of A is an
!!      initial column, otherwise it is a free column.  Before
!!      the QR factorization of A, all initial columns are
!!      permuted to the leading positions; only the remaining
!!      free columns are moved as a result of column pivoting
!!      during the factorization.
!!      On exit, if JPVT(i) = k, then the i-th column of A*P
!!      was the k-th column of A.
!!      INFO = -4 if SIZE(S) /= SIZE(A,2)
!
!! RCOND Optional (input) REAL
!!      RCOND is used to determine the effective rank of A, which
!!      is defined as the order of the largest leading triangular
!!      submatrix R11 in the QR factorization with pivoting of A,
!!      whose estimated condition number < 1/RCOND.
!
!! INFO    (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!--------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
       LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF
       IF( ISTAT == 0 ) THEN
          LWORK = MAX( 1, MIN(M,N) + 3*N, 2*MIN(M,N) + NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSX_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LJPVT, LRCOND, LRANK, WORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGELSX_F95
      SUBROUTINE DGELSY1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      REAL(WP), POINTER :: WORK(:)
      REAL(WP) :: WORKMIN(1)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
         LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= MAX(1,M,N)) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE DGELSY1_F95
      SUBROUTINE DGELSY_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GELSY computes the minimum-norm least squares solution to one
!! or more real or complex linear systems A*x = b using a complete
!! orthogonal factorization of A. Matrix A is rectangular and may be
!! rankdeficient. The vectors b and corresponding solution vectors x are
!! the columns of matrices denoted B and X, respectively.
!!     The routine computes a QR factorization of A with column pivoting:
!!           A * P = Q * [ R11 R12 ]
!!                       [  0  R22 ]
!! where R11 is the largest leading submatrix whose estimated condition
!! number is less than 1/RCOND. The order of R11, RANK, is the effective
!! rank of A. R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal (unitary) transformations from the right, yielding the
!! complete orthogonal (unitary) factorization
!!           A * P = Q * [ T11  0  ] * Z
!!                     [  0   0  ]
!! The minimum-norm least squares solution is then
!!           x = P * Z^H [ T11^-1 * Q1^H * b ]
!!                     [        0          ]
!! where Q1 consists of the first RANK columns of Q.
!!
!! =========
!!
!!          SUBROUTINE LA_GELSY( A, B, RANK=rank, &
!!                     JPVT= jpvt, RCOND= rcond, INFO= info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!              INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!              INTEGER, INTENT(INOUT), OPTIONAL :: JPVT(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been overwritten by details of its complete
!!         orthogonal factorization.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1),size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, rows 1 to size(A,2) contain the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution vector in a column of B is
!!         given by the sum of squares of elements in rows size(A,2)+1 :
!!         size(A,1) of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the order of the submatrix R11.
!!         This is the same as the order of the submatrix T11 in the
!!         complete orthogonal factorization of A.
!! JPVT    Optional (input/output) INTEGER array, shape (:) with
!!         size(JPVT) = size(A,2).
!!         On entry, if JPVT(i) /= 0, the i-th column of A is an initial
!!         column, otherwise it is a free column.
!!         Before the QR factorization of A, all initial columns are
!!         permuted to the leading positions; only the remaining free
!!         columns are moved as a result of column pivoting during the
!!         factorization.
!!         On exit, if JPVT(i) = k, then the i-th column of the matrix
!!         product A*P was the k-th column of A.
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A. This is
!!         defined as the order of the largest leading triangular
!!         submatrix R11 in the QR factorization of A, with pivoting,
!!         whose estimated condition number < 1/RCOND.
!!         Default value: 10*max(size(A,1),size(A,2))*BEPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      REAL(WP), POINTER :: WORK(:)
      REAL(WP) :: WORKMIN(1)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
          LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE DGELSY_F95
SUBROUTINE DGERFS1_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(IN) :: A(:,:), AF(:,:)
   REAL(WP), INTENT(IN) :: B(:)
   REAL(WP), INTENT(INOUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: N, LINFO, ISTAT, ISTAT1, LD
   REAL(WP) :: LFERR, LBERR
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); ISTAT = 0; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N ) THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, 1, A, LD, AF, LD, IPIV, &
                    B, LD, X, LD, LFERR, LBERR, WORK, IWORK, LINFO )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGERFS1_F95
SUBROUTINE DGERFS_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN), TARGET :: IPIV(:)
   REAL(WP), INTENT(IN) :: A(:,:), AF(:,:), B(:,:)
   REAL(WP), INTENT(INOUT) :: X(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GERFS improves the computed solution X of a system of linear
!! equations   A X = B  or  A^T X = B
!! and provides error bounds and backward error estimates for
!! the solution. LA_GERFS uses the LU factors computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GERFS (A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:), AF(:,:), <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    <type>(<wp>), INTENT(INOUT) :: <sol>
!!    REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!!    <sol>  ::= X(:,:) | X(:)
!!    <err>  ::= FERR(:), BERR(:) | FERR, BERR
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The original matrix A.
!
!! AF    (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(AF,1) == size(AF,2) == size(A,1).
!!       The factors L and U from the factorization A = PLU
!!       as computed by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       The right hand side vector(s) of matrix B for
!!       the system of equations AX = B.
!
!! X     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(X,1) or size(X) == size(A,1).
!!       On entry, the solution matrix X, as computed by LA_GETRS.
!!       On exit, the improved solution matrix X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!       of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! FERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(FERR) == size(X,2).
!!       The estimated forward error bound for each solution vector
!!       X(j) (the j-th column of the solution matrix X).
!!       If XTRUE is the true solution corresponding to X(j), FERR(j)
!!       is an estimated upper bound for the magnitude of the largest
!!       element in (X(j) - XTRUE) divided by the magnitude of the
!!       largest element in X(j).  The estimate is as reliable as
!!       the estimate for RCOND, and is almost always a slight
!!       overestimate of the true error.
!
!! BERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(BERR) == size(X,2).
!!       The componentwise relative backward error of each solution
!!       vector X(j) (i.e., the smallest relative change in
!!       any element of A or B that makes X(j) an exact solution).
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!
!! Internal Parameters
!! ===================
!
!! ITMAX is the maximum number of steps of iterative refinement.
!! It is set to 5 in the LAPACK77 subroutines
!! -----------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SFERR, SBERR
!!  .. LOCAL ARRAYS, POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: LFERR(:), LBERR(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF ( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF ( SIZE(B, 1) /= N ) THEN; LINFO = -4
   ELSE IF ( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -7
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -8
   ELSE IF ( N > 0 ) THEN
      IF( .NOT.PRESENT(FERR) ) THEN
         ALLOCATE( LFERR(NRHS), STAT=ISTAT )
      ELSE; LFERR => FERR; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) ) THEN
            ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN; ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT ); END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, NRHS, A, MAX(1,N), AF, MAX(1,N), &
                         IPIV, B, MAX(1,N), X, MAX(1,N), LFERR, &
                         LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGERFS_F95
SUBROUTINE DGESDD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESDD_F77 => LA_GESDD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESDD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, JOBZ
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, S1U, S2U, S1VT, S2VT, &
&             MN, SMLSIZ
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLVT(1,1)
   REAL(WP), POINTER :: WORK(:), W1(:,:), W2(:,:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)

   IF( PRESENT(JOB) )THEN; LJOBZ = JOB; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF(.NOT. (LSAME(LJOBZ, "N") .OR. LSAME(LJOBZ,"U") .OR. LSAME(LJOBZ, "V"))) THEN ; LINFO = -6
   ELSE

        SMLSIZ = ILAENV_F77( 9, "DGESDD", " ", 0, 0, 0, 0 )
        LWORK = MAX(MAX(14*MIN(M,N)+4, 10*MIN(M,N)+2+SMLSIZ*(SMLSIZ+8)) + MAX(M,N), &
&         5*MIN(M,N)*MIN(M,N) + MAX(M,N) + 9*MIN(M,N))

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF( ISTAT == 0 ) THEN
          ALLOCATE(IWORK(8*MIN(M,N)), STAT=ISTAT)
          IF( ISTAT == 0 ) THEN
            IF (.NOT.PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
              ALLOCATE(W1(M,M), W2(N,N), STAT=ISTAT)
              IF (ISTAT == 0) THEN
                IF (.NOT. LSAME(LJOBZ, "N")) THEN
                  JOBZ = "S"
                ELSE
                  JOBZ = "N"
                ENDIF
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
                SELECT CASE(LJOBZ)
                  CASE ("U")
                    A(1:MN, 1:MN) = W1(1:MN, 1:MN)
                  CASE ("V")
                    A(1:MN, 1:MN) = W2(1:MN, 1:MN)
                END SELECT
                DEALLOCATE(W1, W2)
              ELSE
                LINFO = -100
              END IF
            ELSE IF (.NOT. PRESENT(U) .AND. PRESENT(VT)) THEN
              JOBZ = "A"
              ALLOCATE(W1(M,M), STAT=ISTAT)
              IF (ISTAT == 0) THEN
               IF (PRESENT (VT)) THEN
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 VT, MAX(1, S1VT), WORK, LWORK, IWORK, LINFO )
               ELSE
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 LLVT, MAX(1, S1VT), WORK, LWORK, IWORK, LINFO )
               ENDIF
                IF (LSAME(LJOBZ, "U")) A(1:M, 1:MN) = W1(1:M, 1:MN)
                DEALLOCATE(W1)
              ELSE
                LINFO = -100
              END IF
            ELSE IF (PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
              JOBZ = "A"
              ALLOCATE(W2(N,N), STAT=ISTAT)
              IF (ISTAT == 0) THEN
               IF (PRESENT (U)) THEN
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
               ELSE
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
               ENDIF
                IF (LSAME(LJOBZ, "V")) A(1:MN, 1:N) = W2(1:MN, 1:N)
                DEALLOCATE(W2)
              ELSE
                LINFO = -100
              END IF
            ELSE
              JOBZ = "A"
              IF (PRESENT (VT)) THEN
                IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                   VT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                   VT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ENDIF
              ELSE
                IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                   LLVT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                   LLVT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ENDIF
              ENDIF
              IF (PRESENT(WW)) WW = WORK(1)
            ENDIF
          ELSE
            LINFO = -100
          END IF
          DEALLOCATE(WORK)
        ELSE
          LINFO = -100
        END IF
      ENDIF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
    END SUBROUTINE DGESDD_F95
      SUBROUTINE DGESV1_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!     .. PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= SIZE(A,1) ) THEN; LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN; LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN; LPIV => IPIV
         ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
         IF ( ISTAT == 0 ) THEN
!!        .. CALL LAPACK77 ROUTINE ..
            CALL GESV_F77( SIZE(A,1), 1, A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)),         &
                           LINFO )
         ELSE; LINFO = -100; END IF
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE(LPIV, STAT = ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE DGESV1_F95
      SUBROUTINE DGESV_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. "Local Pointers" ..
      INTEGER, POINTER :: LPIV(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. "Test the arguments" ..
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN
         LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= SIZE(A,1) .OR. SIZE(B,2) < 0 ) THEN
         LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN
            LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN
            LPIV => IPIV
         ELSE
            ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT )
         END IF
         IF ( ISTAT == 0 ) THEN
!!        .. "Call LAPACK77 routine" ..
            CALL GESV_F77( SIZE(A,1), SIZE(B,2), A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)), &
                           LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            DEALLOCATE(LPIV, STAT = ISTAT1 )
         END IF
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE DGESV_F95
SUBROUTINE DGESVD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESVD_F77 => LA_GESVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOB
   CHARACTER(LEN=1) :: LJOBU, LJOBVT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, ISTAT1, S1U, S2U, S1VT, S2VT, &
              NN, MN, SWW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLVT(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)
   IF( PRESENT(JOB) )THEN; LJOB = JOB; ELSE; LJOB = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
   IF( PRESENT(WW) )THEN; SWW = SIZE(WW); ELSE; SWW = MN-1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF( SWW /= MN-1 .AND. MN > 0 ) THEN; LINFO = -5
   ELSE IF( PRESENT(JOB) .AND. ( .NOT. ( LSAME(LJOB,"U") .OR. &
            LSAME(LJOB,"V") .OR. LSAME(LJOB,"N") ) .OR. &
            LSAME(LJOB,"U") .AND. PRESENT(U) .OR. &
            LSAME(LJOB,"V") .AND. PRESENT(VT)) )THEN; LINFO = -6
   ELSE
      IF( PRESENT(U) )THEN
         IF( S2U == M )THEN; LJOBU = "A"; ELSE; LJOBU = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"U") ) THEN; LJOBU = "O"
         ELSE; LJOBU = "N"; ENDIF
      ENDIF
      IF( PRESENT(VT) )THEN
         IF( S1VT == N )THEN; LJOBVT = "A"; ELSE; LJOBVT = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"V") )THEN; LJOBVT = "O"
         ELSE; LJOBVT = "N"; ENDIF
      ENDIF
      IF( ISTAT == 0 )THEN
         NN = MAX( 5, 3*MN + MAX(M,N), 5*MN )
         LWORK = MAX( 1, NN, LWORK ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
          LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
          IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
       END IF
       IF( ISTAT == 0 ) THEN
          IF( PRESENT(U) ) THEN
            IF ( PRESENT(VT) )THEN
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
             VT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             VT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = INT(WORK(1)+1)
         IF( LINFO > 0 .AND. PRESENT(WW) ) WW(1:MN-1) = WORK(2:MN)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGESVD_F95
      SUBROUTINE DGESVX1_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,    &
                              RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT) :: X(:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SC, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: IWORK(:), LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:)
      REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
      ELSE; LEQUED="N"; END IF
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
      IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE; S1AF = N; S2AF = N; END IF
      IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
      ELSE; MVC = TINY(1.0_WP); END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B) /= N )THEN
         LINFO = -2
      ELSE IF( SIZE(X) /= N )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE
            LPIV => IPIV
         END IF
         IF( .NOT.PRESENT(R) )THEN
            ALLOCATE( LR(N), STAT=ISTAT )
         ELSE
            LR => R
         END IF
         IF( .NOT.PRESENT(C) )THEN
            ALLOCATE( LC(N), STAT=ISTAT )
         ELSE
            LC => C
         END IF
            ALLOCATE(WORK(4*N), IWORK(N), STAT=ISTAT )
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE DGESVX1_F95
      SUBROUTINE DGESVX_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,     &
                             RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: X(:,:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square matrix and X and B are rectangular matrices or vectors.
!!    LA_GESVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_GESVX ( A, B, X, AF=af, IPIV=ipiv, FACT=fact, &
!!                  TRANS=trans, EQUED=equed, R=r, C=c, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, RPVGRW=rpvgrw, &
!!                  INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, &
!!                                       TRANS
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: R(:), C(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A         (input/output) REAL or COMPLEX square array, shape (:,:).
!!           On entry, the matrix A or its equilibration:
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during a previous call
!!           to LA_GESVX.
!!           On exit, if FACT = "E", then the equilibrated version of A
!!           is stored in A; otherwise, A is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!           size(A,1) and size(X,2) = size(B,2), or shape (:) with
!!           size(X) = size(A,1).
!!           The solution matrix X .
!! AF        Optional (input or output) REAL or COMPLEX square array,
!!           shape (:,:) with the same size as A.
!!           If FACT = "F" then AF is an input argument that contains the
!!           factors L and U of (the equilibrated) A returned by a
!!           previous call to LA_GESVX.
!!           If FACT /= "F" then AF is an output argument that contains
!!           the factors L and U of (the equilibrated) A.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = size(A,1).
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A, returned by a previous call to LA_GESVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF and IPIV contain the factored form of (the
!!                 equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "R": Row equilibration, i.e., A has been premultiplied by
!!                 diag(R).
!!            = "C": Column equilibration, i.e., A has been postmultiplied
!!                 by diag(C).
!!            = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with size(R)
!!           = size(A,1). The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with size(C)
!!           = size(A,1). The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j) , FERR(j) is an
!!           estimated upper bound for the magnitude of the largest
!!           element in (X(j)-XTRUE) divided by the magnitude of the
!!           largest element in X(j). The estimate is as reliable as the
!!           estimate for RCOND and is almost always a slight
!!           overestimate of the true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any
!!           element of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition
!!           is indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!               <= n: U(i,i) = 0. The factorization has been completed,
!!                    but the factor U is singular, so the solution could
!!                  not be computed.
!!               = n+1: U is nonsingular, but RCOND is less than machine
!!                  precision, so the matrix is singular to working
!!                  precision. Nevertheless, the solution and error
!!                    bounds are computed because the computed solution
!!                  can be more accurate than the value of RCOND would
!!                  suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SBERR, SC, SFERR, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: IWORK(:), LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:)
      REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
      LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN
         LFACT = FACT
      ELSE
         LFACT="N"
      END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN
         LEQUED = EQUED
      ELSE
         LEQUED="N"
      END IF
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = N
      END IF
      IF( PRESENT(AF) )THEN
         S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE
         S1AF = N; S2AF = N
      END IF
      IF( ( PRESENT(C) ) )THEN
         SC = SIZE(C)
      ELSE
         SC = N
      END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN
         MVC = MINVAL(C)
      ELSE
         MVC = TINY(1.0_WP)
      END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF( PRESENT(FERR) )THEN
         SFERR = SIZE(FERR)
      ELSE
         SFERR = NRHS
      END IF
      IF( PRESENT(BERR) )THEN
         SBERR = SIZE(BERR)
      ELSE
         SBERR = NRHS
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN
         LINFO = -2
      ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( SFERR /= NRHS )THEN
         LINFO = -11
      ELSE IF( SBERR /= NRHS )THEN
         LINFO = -12
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(IPIV) )THEN
               ALLOCATE( LPIV(N), STAT=ISTAT )
            ELSE
               LPIV => IPIV
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(R) )THEN
               ALLOCATE( LR(N), STAT=ISTAT )
            ELSE
               LR => R
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(C) )THEN
               ALLOCATE( LC(N), STAT=ISTAT )
            ELSE
               LC => C
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(FERR) )THEN
               ALLOCATE( LFERR(NRHS), STAT=ISTAT )
            ELSE
               LFERR => FERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(BERR) )THEN
               ALLOCATE( LBERR(NRHS), STAT=ISTAT )
            ELSE
               LBERR => BERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            ALLOCATE(WORK(4*N), IWORK(N), STAT=ISTAT )
         END IF
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
         IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE DGESVX_F95
      SUBROUTINE DGETRF_F95( A, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GETRF_F77 => LA_GETRF, LANGE_F77 => LA_LANGE, & !!((07-B-INT_LAPACK1.f90))
                                          GECON_F77 => LA_GECON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      REAL(WP), INTENT( INOUT ) :: A( :, : )
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, M, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:), IWORK(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MAX, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      M = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0; MINMN = MIN(M,N)
      LD = MAX(1,M)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 .OR. PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -1
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -2
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -4
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( WORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGE_F77( LNORM, MINMN, MINMN, A, LD, WORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(WORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GETRF_F77( M, N, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(4*MINMN), IWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GECON_F77( LNORM, MINMN, A, LD, LANORM, &
                                     RCOND, WORK, IWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE DGETRF_F95
SUBROUTINE DGETRI_F95( A, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRI_F77 => LA_GETRI, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRI computes the inverse of a matrix using the LU factorization
!! computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRI (A, IPIV, INFO)
!!    <type>(<wp>), INTENT(INOUT)  :: A(:,:)
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! =====================
!
!! A      (input/output) either REAL or COMPLEX square array, shape (:,:),
!!        size(A,1) == size(A,2).
!!        On entry contains the factors L and U from the factorization
!!           A = PLU as computed by LA_GETRF.
!!        On exit, if INFO = 0, the inverse of the original matrix A.
!
!! IPIV   (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!        The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i of
!!        the matrix was interchanged with row IPIV(i).
!
!! INFO   Optional (output) INTEGER.
!!        If INFO is present
!!           = 0: successful exit
!!           < 0: if INFO = -k, the k-th argument had an illegal value
!!           > 0: if INFO = k, U(k,k) is exactly zero.  The matrix is
!!               singular and its inverse could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!           terminated with an error message.
!-----------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRI"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DGETRI"
!!  .. LOCAL SCALARS ..
   INTEGER    :: LINFO, N, LD, LWORK, ISTAT, ISTAT1, NB
!!  .. LOCAL ARRAY ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LINFO = 0; LD = MAX(1,N); ISTAT = 0
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N )THEN; LINFO = -2
   ELSE IF( N > 0 )THEN
!!     DETERMINE THE WORK SPACE.
      NB = ILAENV_F77( 1, BSNAME, " ", N, -1, -1, -1 )
      IF( NB < 1 .OR. NB >= N )THEN; NB = 1; END IF
      LWORK = MAX( N*NB, 1 )
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = MAX(1,N); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( LINFO == 0 )THEN
         CALL GETRI_F77( N, A, LD, IPIV, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGETRI_F95
SUBROUTINE DGETRS1_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE DGETRS1_F95
SUBROUTINE DGETRS_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRS solves a system of linear equations
!!    A X = B, A^T X = B or  A^H X = B
!! with a general square matrix A using the LU factorization computed
!! by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRS (A, IPIV, B, TRANS, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:)
!!    <type>(<wp>), INTENT(INOUT) :: <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The factors L and U from the factorization A = PLU as computed
!!       by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       On entry, the right hand side vector(s) of matrix B for
!!          the system of equations AX = B.
!!       On exit, if there is no error, the matrix of solution
!!          vector(s) X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!          of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!---------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = SIZE(B,2); LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B, 1 ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE DGETRS_F95
      SUBROUTINE DGGES_F95( A, B, ALPHAR, ALPHAI, BETA, VSL, VSR, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  DP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGES_F77 => LA_GGES                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!!  .. FUNCTIONAL ARGUMENTS ..
     INTERFACE
      LOGICAL FUNCTION SELECT(ALPHAR, ALPHAI, BETA)
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      REAL(WP), INTENT(IN) :: ALPHAR, ALPHAI, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGES computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!
!! =========
!!
!!           SUBROUTINE LA_GGES( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGES for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGES"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHAR, SALPHAI, SBETA
      INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      LOGICAL, POINTER :: BWORK(:)
      LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   IF (PRESENT (SELECT)) THEN
      LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
      ELSE IF( SALPHAR /= N )THEN; LINFO = -3
      ELSE IF( SALPHAI /= N )THEN; LINFO = -4
      ELSE IF( SBETA /= N )THEN; LINFO = -5
      ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
      ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7
   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 500; ENDIF
      ELSE; BWORK => LLBWORK; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
        LWORK = -1
        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ELSE
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ELSE
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
        LWORK = WORKMIN(1)

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 400; ENDIF

        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
          IF (PRESENT(SDIM)) SDIM = LSDIM

          DEALLOCATE(WORK)
400       IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK)
        ENDIF
500     CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGGES_F95
SUBROUTINE DGGESX_F95( A, B,  ALPHAR, ALPHAI, &
&   BETA, VSL, VSR, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGESX_F77 => LA_GGESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: RCONDE(2), RCONDV(2)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT(ALPHAR, ALPHAI, BETA)
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      REAL(WP), INTENT(IN) :: ALPHAR, ALPHAI, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGESX computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       LA_GGESX also computes two reciprocal condition numbers for the
!! average of the selected eigenvalues and reciprocal condition numbers
!! for the right and left deflating subspaces corresponding to the
!! selected eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_GGESX( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim,
!!                      RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE(2), RCONDV(2)
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGESX for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE)=2.
!!          The reciprocal condition numbers for the average of the
!!          selected eigenvalues.
!! RCONDV   Optional (output) REAL array, shape (:) with size(RCONDV)=2.
!!          The reciprocal condition numbers for the left and right
!!          deflating subspaces corresponding to the selected
!!          eigenvalues.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHAR, SALPHAI, SBETA, LIWORK
   INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), TARGET :: LLRCONDE(2), LLRCONDV(2)
   REAL(WP), POINTER :: WORK(:)
   LOGICAL, POINTER :: BWORK(:)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   IF  (PRESENT (SELECT)) THEN
     LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
      ELSE IF( SALPHAR /= N )THEN; LINFO = -3
      ELSE IF( SALPHAI /= N )THEN; LINFO = -4
      ELSE IF( SBETA /= N )THEN; LINFO = -5
      ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
      ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7

   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-101; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      IF (LSAME (LSENSE, "N")) THEN
        LWORK =   8 * (N+1)+16
      ELSE
        LWORK = MAX( 8*(N+1)+16, N*N/2+1 )
      ENDIF
      ALLOCATE (WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-105; GOTO 500; ENDIF
      LIWORK = 8*(N+6)+10
      ALLOCATE ( IWORK (LIWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-106; GOTO 600; ENDIF

      IF (PRESENT (RCONDV)) THEN
        IF (PRESENT (RCONDE)) THEN
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ENDIF
      ELSE
        IF (PRESENT (RCONDE)) THEN
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ENDIF
      ENDIF

      IF (PRESENT(SDIM)) SDIM = LSDIM

      DEALLOCATE(WORK, STAT=ISTAT)
600   DEALLOCATE(IWORK, STAT=ISTAT)
500   IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK, STAT=ISTAT)

    ENDIF
100   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGGESX_F95
      SUBROUTINE DGGEV_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEV_F77 => LA_GGEV                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
       REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!! LA_GGEV computes for a pair of n by n real or complex matrices (A,B)
!! the generalized eigenvalues in the form of scalar pairs (alpha, beta)
!! and, optionally, the left and/or right generalized eigenvectors.
!!       A generalized eigenvalue of the pair (A,B) is, roughly
!! speaking, a scalar of the form  lambda=alpha/beta such that the matrix
!! A-lambda*B is singular. It is usually represented as the pair
!! (alpha; beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector v such that (A-lambda*B)*v=0. A left
!! generalized eigenvector is a vector u such that u^H*(A-lambda*B)=0,
!! where u^H is the conjugate-transpose of u.
!!       The computation is based on the (generalized) real or complex
!! Schur form of (A,B). (See LA_GGES for details of this form.)
!!
!! =========
!!
!!     SUBROUTINE LA_GGEV( A, B, <alpha>, BETA, VL=vl, &
!!                 VR=vr, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!         <type>     ::= REAL | COMPLEX
!!         <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!         <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!         <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B.
!!         On exit, B has been destroyed.
!! <alpha> (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!         size(A,1).
!!         The values of alpha.
!!         alpha(:) ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!         where
!!         ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!         imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA    (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!         size(A,1).
!!         The values of beta.
!!         Note: The generalized eigenvalues of the pair (A,B) are the
!!         scalars lambda(j)=alpha(j)/beta(j). These quotients may easily
!!         over- or underflow, and beta(j) may even be zero. Thus, the
!!         USEr should avoid computing them naively.
!!         Note: If A and B are real then complex eigenvalues occur in
!!         complex conjugate pairs. Each pair is stored consecutively.
!!         Thus a complex conjugate pair is given by
!!             lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!             lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!         where
!!             ALPHAI(j)/BETA(j) = -(ALPHAI(j+1)/BETA(j+1))
!! VL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VL,1) = size(A,1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag:part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!            <= n: The QZ iteration failed. No eigenvectors have been
!!                  calculated, but (alpha(j), BETA(j)) should be
!!                  correct for j = INFO+1, ..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: a failure occurred during the computation of the
!!                  generalized eigenvectors.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------

!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGEV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   SBETA = SIZE(BETA)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, VL, S1VL, VR, S1VR, WORKMIN, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, VL, S1VL, LLVR, S1VR, WORKMIN, LWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, LLVL, S1VL, VR, S1VR, WORKMIN, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, LLVL, S1VL, LLVR, S1VR, WORKMIN, LWORK, LINFO )
        ENDIF
       ENDIF
      LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
        ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      DEALLOCATE(WORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGGEV_F95
      SUBROUTINE DGGEVX_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, &
     &  BALANC, ILO, IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEVX_F77 => LA_GGEVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: ILO,IHI
      REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!  .. ARRAY ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: LSCALE(:), RSCALE(:), &
     &  RCONDE(:), RCONDV(:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGEVX computes for a pair of n-by-n real or complex matrices
!! (A, B) the generalized eigenvalues in the form of scalar pairs
!! (alpha; beta) and, optionally, the left and/or right generalized
!! eigenvectors.
!!      A generalized eigenvalue of the pair (A; B) is, roughly speaking,
!! a scalar of the form lambda = alpha / beta such that the matrix
!! A - lambda * B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!      A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector  v  such that ( A - lambda*B)* v = 0.
!! A left generalized eigenvector is a vector u such that
!! u^H*(A-lambda*B) = 0, where u^H is the conjugate-transpose of u.
!!      The computation is based on the (generalized) real or complex
!! Schur form of (A, B). (See LA_GGES for details of this form.)
!!      Optionally, LA_GGEVX also computes a balancing transformation
!! (to improve the conditioning of the eigenvalues and eigenvectors),
!! reciprocal condition numbers for the eigenvalues, and reciprocal
!! condition numbers for the right eigenvectors. The balancing
!! transformation consists of a permutation of rows and columns and/or a
!! scaling of rows and columns.
!!
!! ==========
!!
!!    SUBROUTINE LA_GGEVX( A, B, <alpha>, BETA, VL=vl, &
!!          VR=vr, BALANC=balanc, ILO=ilo, IHI=ihi, &
!!          LSCALE=lscale, RSCALE=rscale, ABNRM=abnrm, &
!!          BBNRM=bbnrm, RCONDE=rconde, RCONDV=rcondv, &
!!          INFO=info )
!!        <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!        <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!        <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!        CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!        INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: LSCALE(:),
!!             RSCALE(:), RCONDE(:), RCONDV(:)
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!        INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!        <type>     ::= REAL | COMPLEX
!!        <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!        <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!        <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:, :).
!!          On entry, the matrix A.
!!          On exit, A has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then A contains
!!          the first part of the real/complex Schur form of the
!!          "balanced" versions of the matrix pair (A, B).
!! B        (input/output) REAL or COMPLEX square array, shape (:, :)
!!          with size(B, 1) = size(A, 1).
!!          On entry, the matrix B.
!!          On exit, B has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then B contains
!!          the second part of the real/complex Schur form of the "bal-
!!          anced" versions of the matrix pair (A, B).
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with
!!          size(<alpha>) = size(A, 1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) |  ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with
!!          size(BETA) = size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A, B) are the
!!          scalars lambda(j) = alpha(j) / beta(j) . These quotients
!!          may easily over- or underflow, and beta(j) may even be zero.
!!          Thus, the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!                 lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!                 lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!              ALPHAI(j)/BETA(j)= - (ALPHAI(j+1)/BETA(j+1))
!! VL       Optional (output) REAL or COMPLEX square array, shape (:, :)
!!          with  size(VL, 1) = size(A, 1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!         | realpart | + | imag.part | = 1,except that for eigenvalues
!!         with alpha = beta = 0, a zero vector is returned as the
!!         corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC  Optional (input) CHARACTER(LEN=1).
!!         Specifies the balance option to be performed.
!!            = "N": do not permute or scale;
!!            = "P": permute only;
!!            = "S": scale only;
!!            = "B": both permute and scale.
!!         Default value: "N".
!!         Note: Computed reciprocal condition numbers will be for the
!!         matrices after balancing. Permuting does not change condition
!!         numbers (in exact arithmetic), but scaling does.
!! ILO,IHI Optional (output) INTEGER.
!!         ILO and IHI are integer values such that on exit A(i,j) = 0
!!         and B(i,j) = 0 if i > j and j =1,...,ILO-1 or
!!         i = IHI+1,...,n.
!!         If BALANC = "N" or "S", then ILO = 1 and IHI = n.
!! LSCALE  Optional (output) REAL array, shape (:) with size(LSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to
!!         the left side of A and B. If PL(j) is the index of the row
!!         interchanged with row j, and DL(j) is the scaling factor
!!         applied to row j, then
!!                 PL(j) = LSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!               DL(j) = LSCALE(j),  j = ILO, ..., IHI
!! RSCALE  Optional (output) REAL array, shape (:), size(RSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to the
!!         right side of A and B. If PR(j) is the index of the column
!!         interchanged with column j, and DR(j) is the scaling factor
!!         applied to column j, then
!!                PR(j) = RSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!                DR(j) = RSCALE(j),  j = ILO, ..., IHI
!! ABNRM   Optional (output) REAL.
!!         The l1 norm of A after balancing.
!! BBNRM   Optional (output) REAL.
!!         The l 1 norm of B after balancing.
!! RCONDE  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The reciprocal condition numbers of the eigenvalues.
!! RCONDV  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The estimated reciprocal condition numbers of the right
!!         eigenvectors. If the eigenvalues cannot be reordered to
!!         compute RCONDV(j) then RCONDV(j) is set to 0. This can only
!!         occur when the true value would be very small.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!           <= n: The QZ iteration failed. No eigenvectors have been
!!                 calculated, but (alpha(j) , BETA(j) ) should be
!!          correct for j = INFO + 1,..., n.
!!             = n+1: another part of the algorithm failed.
!!             = n+2: a failure occurred during the computation of the
!!                 generalized eigenvectors.
!!         If INFO is not present and an error occurs, then the program
!!       is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGEVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR, LBALANC, LSENSE
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHAR, SALPHAI, SBETA, LILO, LIHI, SRCONDE, SRCONDV, SLSCALE, SRSCALE
      REAL(WP) :: LABNRM, LBBNRM
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: LRCONDE(:), LRCONDV(:), LLSCALE(:), LRSCALE(:)
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      LOGICAL, POINTER :: BWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI); SBETA = SIZE(BETA)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(LSCALE) )THEN; SLSCALE = SIZE(LSCALE); ELSE; SLSCALE = N; ENDIF
   IF( PRESENT(RSCALE) )THEN; SRSCALE = SIZE(RSCALE); ELSE; SRSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
     &  LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -8
   ELSE IF( SLSCALE /= N )THEN; LINFO = -11
   ELSE IF( SRSCALE /= N )THEN; LINFO = -12
   ELSE IF( SRCONDE /= N )THEN; LINFO = -15
   ELSE IF( SRCONDV /= N )THEN; LINFO = -16
   ELSE IF( N > 0 )THEN
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF

      ALLOCATE(BWORK(N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1000; ENDIF

      ALLOCATE(IWORK(N+6), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 900; ENDIF

      IF( PRESENT(LSCALE) )THEN; LLSCALE => LSCALE
      ELSE; ALLOCATE( LLSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 800; ENDIF
      END IF

      IF( PRESENT(RSCALE) )THEN; LRSCALE => RSCALE
      ELSE; ALLOCATE( LRSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 700; ENDIF
      END IF

      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 600; ENDIF
      END IF

      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 500; ENDIF
      END IF

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ENDIF
       ENDIF
      LWORK = WORKMIN(1)

      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ELSE
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ELSE
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ENDIF
      ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO; IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( PRESENT(BBNRM) ) BBNRM = LBBNRM

      DEALLOCATE(WORK)
100  IF (.NOT. PRESENT(RCONDE)) DEALLOCATE(LRCONDE)
500  IF (.NOT. PRESENT(RCONDV)) DEALLOCATE(LRCONDV)
600  IF (.NOT. PRESENT(RSCALE)) DEALLOCATE(LRSCALE)
700  IF (.NOT. PRESENT(LSCALE)) DEALLOCATE(LLSCALE)
800  DEALLOCATE (IWORK)
900  DEALLOCATE (BWORK)
     ENDIF
1000  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGGEVX_F95
SUBROUTINE DGGGLM_F95( A, B, D, X, Y, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGGLM_F77 => LA_GGGLM                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:), D(:)
    REAL(WP), INTENT(OUT) :: X(:), Y(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GGGLM solves the general (Gauss-Markov) linear model (GLM)
!! problem:
!!      min ||y||2  subject to d=A*x + B*y
!!       x
!! where A and B are real or complex rectangular matrices and d is a real
!! or complex vector. Further, A is n by m, B is n by p, and d is n by 1,
!! and it is assumed that m <= n <= m+p, rank(A) = m, rank(A, B) = n.
!! These conditions ensure that the GLM problem has unique solution
!! vectors x and y. The problem is solved using the generalized QR
!! factorization of A and B.
!!        If matrix B is square and nonsingular, then the GLM problem is
!! equivalent to the weighted linear least squares problem
!!         min ||B^-1 * (d-A*x)||2
!!          x
!!
!! =========
!!
!!       SUBROUTINE LA_GGGLM( A, B, D, X, Y, INFO=info )
!!           <type>(<wp>), INTENT( INOUT ) :: A( :, : ), B(:,:), D(:)
!!           <type>(<wp>), INTENT( OUT ) :: X(:), Y(:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(A,1) = n and size(A,2) = m.
!!       On entry, the matrix A.
!!       On exit, the contents of A are destroyed.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n and size(B,2) = p.
!!       On entry, the matrix B.
!!       On exit, the contents of B are destroyed.
!! D     (input/output) REAL or COMPLEX array, shape (:) with
!!       size(D) = n.
!!       On entry, the vector d.
!!       On exit, the contents of D are destroyed.
!! X     (output) REAL or COMPLEX array, shape (:) with size(X) = m.
!!       The solution vector x.
!! Y     (output) REAL or COMPLEX array, shape (:) with size(Y) = p.
!!       The solution vector y.
!! INFO  Optional (output) INTEGER.
!!       = 0: successful exit
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGGLM"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); M = SIZE(A,2); P = SIZE(B,2)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < M ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P < N-M .OR. SIZE(B,1) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(D) /= N ) THEN; LINFO = -3
    ELSE IF( SIZE(X) /= M ) THEN; LINFO = -4
    ELSE IF( SIZE(Y) /= P ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGGLM_F77( N, M, P, A, MAX(1,N), B, MAX(1,N), &
                          D, X, Y, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT( WORK(1) )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGGGLM_F95
SUBROUTINE DGGLSE_F95( A, B, C, D, X, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGLSE_F77 => LA_GGLSE                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:), C(:), D(:)
    REAL(WP), INTENT(OUT) :: X(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GGLSE solves the linear equality-constrained least squares
!! (LSE) problem:
!!      min || c - A*x||2 subject to B*x = d,
!! where A and B are real or complex rectangular matrices and c and d are
!! real or complex vectors. Further, A is m by n, B is p by n, c is m by 1
!! and d is p by 1, and it is assumed that
!!       p <= n <=  m + p, rank(B) = p,  rank [ A ] = n.
!!                                            [ B ]
!! These conditions ensure that the LSE problem has a unique solution x.
!! This is obtained using the generalized RQ factorization of the matrices
!! B and A.
!!
!! =========
!!
!!        SUBROUTINE LA_GGLSE( A, B, C, D, X, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A(:,:), B(:,:), C(:), D(:)
!!          <type>(<wp>), INTENT( OUT ) :: X(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(A,1) = m and size(A,2) = n.
!!         On entry, the matrix A.
!!         On exit, the contents of A are destroyed.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = p and size(B,2) = n.
!!         On entry, the matrix B.
!!         On exit, the contents of B are destroyed.
!! C       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(C) = m.
!!         On entry, the vector c.
!!         On exit, the residual sum of squares for the solution is given
!!         by the sum of squares of elements n-p+1 to m.
!! D       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(D) = p.
!!         On entry, The vectors d.
!!         On exit, the contents of D are destroyed.
!! X       (output) REAL or COMPLEX array, shape (:) with size(X) = n.
!!         The solution vector x.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGLSE"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P > N .OR. P < N-M .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(C) /= M ) THEN; LINFO = -3
    ELSE IF( SIZE(D) /= P ) THEN; LINFO = -4
    ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGLSE_F77( M, N, P, A, MAX(1,M), B, MAX(1,P), &
                          C, D, X, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT(WORK(1))
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DGGLSE_F95
SUBROUTINE DGGSVD_F95( A, B, ALPHA, BETA, K, L, U, V, Q, IWORK, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGSVD_F77 => LA_GGSVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, K, L
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), V(:,:), Q(:,:)
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IWORK(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGSVD computes the generalized singular values and, optionally,
!! the transformation matrices from the generalized singular value
!! decomposition (GSVD) of a real or complex matrix pair (A,B), where A
!! is m by n and B is p by n. The GSVD of (A,B) is written
!!       A = U * SIGMA1(0, R)*Q^H , B = V * SIGMA2(0, R)*Q^H
!! where U , V and Q are orthogonal (unitary) matrices of dimensions m by m,
!! p by p and n by n, respectively. Let l be the rank of B and r the rank of
!! the (m + p) * n matrix ( A )
!!                        ( B )
!! , and let k = r-l. Then SIGMA1 and SIGMA2 are m*(k + l) and p * (k + l)
!! "diagonal" matrices, respectively, and R is a (k + l) * (k + l)
!! nonsingular triangular matrix. The detailed structure of SIGMA1 ,SIGMA2
!! and R depends on the sign of (m - k - l) as follows:
!!       The case m-k-l>=0:
!!
!!                               k   l
!!                      k      ( I   0 )
!!        SIGMA1 =      l      ( 0   C )
!!                    m-k-l    ( 0   0 )
!!
!!
!!                           k   l
!!       SIGMA2 =    l   ( 0   S )
!!                 p - l ( 0   S )
!!
!!
!!                          n-k-l   k     l
!!          (0, R) =   k   (  0    R11   R12  )
!!                     l   (  0     0    R22  )
!!
!! where C^2 + S^2 = I . We define
!! alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i=1,2,...,l
!! beta(1) = beta(2) = ... = beta(k) = 0, beta(k+i) = s(i i), i=1,2,...,l
!!
!! The case m-k-l < 0:
!!
!!                                k    m-k    k+l-m
!!            SIGMA1 =    k    (  I     0       0   )
!!                       m-k   (  0     C       0   )
!!
!!
!!                                        k    m-k     k+l-m
!!                        m-k   ( 0     S        0  )
!!            SIGMA2 =   k+l-m  ( 0     0        I  )
!!                            p-l   ( 0     0        0  )
!!
!!
!!                                  n-k-l    k     m-k   k+l-m
!!                                 k      (   0     R11    R12    R13  )
!!              (0,R) =   m-k     (   0      0     R22    R23  )
!!                           k+l-m    (   0      0      0     R33  )
!!
!! where C^2 + S^2 = I . We define
!!  alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i =1,2,...,m-k,
!!  alpha(m+1) = alpha(m+2)=...= alpha(k+l) = 0
!!  beta(1)=beta(2)= ... =beta(k)=0, beta(k+i)=s(i i), i=1,2,...,m-k,
!!  beta(m+1) = beta(m+2) = ... = beta(k+l) = 1
!!
!! In both cases the generalized singular values of the pair (A,B) are the
!! ratios
!!  sigma(i) = alpha(i)/beta(i), i = 1,2, ... ,k+l
!!
!! The first k singular values are infinite. The finite singular values
!! are real and nonnegative.
!!     LA_GGSVD computes the real (nonnegative) scalars alpha(i), beta(i),
!! i=1,2,..., k+l , the matrix R, and, optionally, the transformation
!! matrices U , V and Q.
!!
!! =========
!!
!!      SUBROUTINE LA_GGSVD( A, B, ALPHA, BETA, K=k, L=l, &
!!                       U=u, V=v, Q=q, IWORK=iwork, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: ALPHA(:), BETA(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: K, L
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), V(:,:), Q(:,:)
!!          INTEGER, INTENT(IN), OPTIONAL :: IWORK(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(A,1) = m and size(A,2) = n.
!!        On entry, the matrix A.
!!        On exit, A contains the triangular matrix R, or part of R, as
!!        follows:
!!        If m-k-l >= 0, then R is stored in A(1:k+l,n-k-l+1:n).
!!        If m-k-l < 0, then the matrix
!!                  ( R11     R12    R13 )
!!                (  0      R22    R23 )
!!        is stored in A(1:m,n-k-l+1:n).
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = p and size(B,2) = n.
!!        On entry, the matrix B.
!!        On exit, if m-k-l < 0, then R33 is stored in
!!        B(m-k+1:l,n+m-k-l+1:n).
!! ALPHA  (output) REAL array, shape (:) with size(ALPHA) = n
!!        The real scalars alpha(i) , i = 1, 2,..., k+l.
!! BETA   (output) REAL array, shape (:) with size(BETA) = n.
!!        The real scalars beta(i) , i = 1, 2, ..., k+l.
!!        Note: The generalized singular values of the pair (A,B) are
!!        sigma(i) = ALPHA(i)/BETA(i), i = 1, 2, ...,  k+l.
!!        If k + l < n, then ALPHA(k+l+1:n) = BETA(k+l+1:n) = 0.
!! K, L   Optional (output) INTEGER.
!!        The dimension parameters k and l.
!! U      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(U,1) = m.
!!        The matrix U .
!! V      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(V,1) = p.
!!        The matrix V .
!! Q      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Q,1) = n.
!!        The matrix Q.
!! IWORK  Optional (output) INTEGER array, shape(:) with size(IWORK) = n.
!!        IWORK contains sorting information. More precisely, the loop
!!             for i = k + 1, min(m, k + l)
!!                   swap ALPHA(i) and ALPHA(IWORK(i))
!!             end
!!        will sort ALPHA so that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(n).
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = 1, the algorithm failed to converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGSVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBU, LJOBV, LJOBQ
   INTEGER :: M, N, P, LINFO, ISTAT, ISTAT1, S1U, S2U, S1V, S2V, &
              S1Q, S2Q, LK, LL
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLV(1,1), LLQ(1,1)
   INTEGER, POINTER :: LIWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2); LJOBU = "U"
   ELSE; S1U = 1; S2U = 1; LJOBU = "N"; END IF
   IF( PRESENT(V) )THEN; S1V = SIZE(V,1); S2V = SIZE(V,2); LJOBV = "V"
   ELSE; S1V = 1; S2V = 1; LJOBV = "N"; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2); LJOBQ = "Q"
   ELSE; S1Q = 1; S2Q = 1; LJOBQ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < N )THEN; LINFO = -1
   ELSE IF( SIZE(B,2) /= N .OR. P < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( ALPHA ) /= N )THEN; LINFO = -3
   ELSE IF( SIZE( BETA ) /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(U) .AND. ( S1U /= MAX(1,M) .OR.  S2U /= M ) )THEN; LINFO = -7
   ELSE IF( PRESENT(V) .AND. ( S1V /= MAX(1,P) .OR.  S2V /= P ) )THEN; LINFO = -8
   ELSE IF( PRESENT(Q) .AND. ( S1Q /= MAX(1,N) .OR.  S2Q /= N ) )THEN; LINFO = -9
   ELSE
    IF (PRESENT(IWORK)) THEN
      LIWORK => IWORK
    ELSE
      ALLOCATE( LIWORK(MAX(1,N)), STAT=ISTAT )
    ENDIF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( WORK( MAX(1,MAX(3*N,M,P)+N) ), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(U) )THEN
           IF( PRESENT(V) )THEN
             IF( PRESENT(Q) )THEN
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ELSE
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ENDIF
             ELSE
              IF( PRESENT(Q) )THEN
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ELSE
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ENDIF
            ENDIF
           ELSE
             IF( PRESENT(V) )THEN
               IF( PRESENT(Q) )THEN
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
               ELSE
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ENDIF
              ELSE
               IF( PRESENT(Q) )THEN
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ELSE
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ENDIF
               ENDIF
              ENDIF
         IF( PRESENT(K) ) K = LK
         IF( PRESENT(L) ) L = LL
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
      IF (.NOT. PRESENT(IWORK)) DEALLOCATE(LIWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DGGSVD_F95
 SUBROUTINE DGTSV1_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, 1, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DGTSV1_F95
 SUBROUTINE DGTSV_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GTSV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square tridiagonal matrix and X and B
!! are rectangular matrices or vectors. The LU decomposition is used to
!! factor the matrix A as A = L*U , where L is a product of permutation
!! and unit lower bidiagonal matrices and U is upper triangular with
!! nonzeros in only the main diagonal and first two superdiagonals.
!! The factored form of A is then used to solve the above system.
!!
!! Note: The system A^T*X = B may be solved by interchanging the order of
!! the arguments DU and DL.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSV( DL, D, DU, B, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: DL(:), D(:), DU(:), <rhs>
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs> ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! DL    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1, where n is the order of A.
!!       On entry, the subdiagonal of A.
!!       On exit, the n-2 elements of the second superdiagonal of U in
!!       DL(1),..., DL(n-2).
!! D     (input/output) REAL or COMPLEX array, shape (:) with size(D) = n.
!!       On entry, the diagonal of A.
!!       On exit, the diagonal of U .
!! DU    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1.
!!       On entry, the superdiagonal of A.
!!       On exit, the first superdiagonal of U .
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n or shape (:) with size(B) = n.
!!       On entry, the matrix B.
!!       On exit, the solution matrix X .
!! INFO  Optional (output) INTEGER
!!       = 0: successful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, then U(i,i) = 0. The factorization has not been
!!       completed unless i = n. The factor U is singular, so the solution
!!       could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, NRHS, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DGTSV_F95
SUBROUTINE DGTSVX1_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                            IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0 ) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, 1, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGTSVX1_F95
SUBROUTINE DGTSVX_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                           IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
   REAL(WP), INTENT(OUT) :: X(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GTSVX computes the solution to a real or complex linear system
!! of equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square tridiagonal matrix and X and B are rectangular matrices or
!! vectors.
!!     LA_GTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSVX( DL, D, DU, B, X, DLF=dlf, DF=df, DUF=duf, &
!!               DU2=du2, IPIV=ipiv, FACT=fact, TRANS=trans, FERR=ferr, &
!!               BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(IN) :: DL(:), D(:), DU(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: DLF(:), DF(:), &
!!                                                   DUF(:), DU2(:)
!!           INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, TRANS
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! DL     (input) REAL or COMPLEX array, shape (:) with size(DL) = n-1.
!!        The subdiagonal of A.
!! D      (input) REAL or COMPLEX array, shape (:) with size(D) = n.
!!        The diagonal of A.
!! DU     (input) REAL or COMPLEX array, shape (:) with size(DU) = n-1.
!!        The superdiagonal of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        The matrix B.
!! X      (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!        and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!        The solution matrix X .
!! DLF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DLF)= n-1.
!!        If FACT = "F" then DLF is an input argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!!        If FACT = "N" then DLF is an output argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!! DF     Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DF)= n.
!!        If FACT = "F" then DF is an input argument that contains the
!!        diagonal of the matrix U .
!!        If FACT = "N" then DF is an output argument that contains the
!!        diagonal of the matrix U .
!! DUF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DUF) = n-1.
!!        If FACT = "F" then DUF is an input argument that contains the
!!        first superdiagonal of U.
!!        If FACT = "N" then DUF is an output argument that contains the
!!        first superdiagonal of U.
!! DU2    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DU2) = n-2.
!!        If FACT = "F", then DU2 is an input argument that contains the
!!        second superdiagonal of U.
!!        If FACT = "N", then DU2 is an output argument that contains the
!!        second superdiagonal of U.
!! IPIV   Optional (input or output) INTEGER array, shape (:) with
!!        size(IPIV) = n.
!!        If FACT = "F" then IPIV is an input argument that contains the
!!        pivot indices from the LU factorization of A.
!!        If FACT = "N", then IPIV is an output argument that contains the
!!        pivot indices from the LU factorization of A; row i of the
!!        matrix was interchanged with row IPIV(i). IPIV(i) will always
!!        be either i or i+1; IPIV(i) = i indicates a row interchange was
!!        not required.
!! FACT   Optional (input) CHARACTER(LEN=1).
!!        Specifies whether the factored form of A is supplied on entry.
!!            = "N": The matrix will be copied to DLF, DF and DUF and
!!                 factored.
!!            = "F": DLF, DF, DUF, DU2 and IPIV contain the factored form
!!                 of A.
!!        Default value: "N".
!! TRANS  Optional (input) CHARACTER(LEN=1).
!!        Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!!        Default value: "N".
!! FERR   Optional (output) REAL array of shape (:), with size(FERR) =
!!        size(X,2), or REAL scalar.
!!        The estimated forward error bound for each solution vector X(j)
!!        (the j-th column of the solution matrix X). If XTRUE is the true
!!        solution corresponding to X(j) , FERR(j) is an estimated upper
!!        bound for the magnitude of the largest element in (X(j)-XTRUE)
!!        divided by the magnitude of the largest element in X(j). The
!!        estimate is as reliable as the estimate for RCOND and is almost
!!        always a slight overestimate of the true error.
!! BERR   Optional (output) REAL array of shape (:), with size(BERR) =
!!        size(X,2), or REAL scalar.
!!        The componentwise relative backward error of each solution
!!        vector X(j) (i.e.,the smallest relative change in any element of
!!        A or B that makes X(j) an exact solution).
!! RCOND  Optional (output) REAL.
!!        The estimate of the reciprocal condition number of the matrix A.
!!        If RCOND is less than the machine precision, the matrix is
!!        singular to working precision. This condition is indicated by
!!        a return code of INFO > 0.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, and i is
!!           <= n: U(i,i) = 0. The factorization has not been completed
!!               unless i = n. The factor U is singular, so the solution
!!               could not be computed.
!!           = n+1: U is nonsingular, but RCOND is less than machine
!!               precision, meaning that the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!                 error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2, &
              SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  PRINT *, LINFO, ISTAT, N, NRHS, LFACT, SIPIV, SDLF, SDF, SDUF, SDU2, SFERR, SBERR, LTRANS
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0) THEN; LINFO = -3
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -4
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -13
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -14
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, NRHS, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DGTSVX_F95
      SUBROUTINE DLAGGE_F95( A, KL, KU, D, ISEED, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAGGE_F77 => LA_LAGGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(IN), OPTIONAL :: KL, KU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: ISEED(4)
      REAL(WP), INTENT(IN), OPTIONAL, TARGET :: D(:)
      REAL(WP), INTENT(OUT) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LAGGE generates a real general m by n matrix A, by pre- and post-
!!  multiplying a real diagonal matrix D with random orthogonal matrices:
!!  A = U*D*V. The lower and upper bandwidths may then be reduced to
!!  kl and ku by additional orthogonal transformations.
!
!!  Arguments
!!  =========
!
!!  SUBROUTINE LA_LAGGE( A, KL, KU, D, ISEED, INFO )
!!     <type>(<wp>), INTENT(OUT) :: A(:,:)
!!     INTEGER, INTENT(IN), OPTIONAL :: KL, KU
!!     REAL(<wp>), INTENT(IN), OPTIONAL, TARGET :: D(:)
!!     INTEGER, INTENT(INOUT), OPTIONAL :: ISEED(4)
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!!  =====================
!
!!  A       (output) REAL array, shape (:,:), SIZE(A,1) == m,
!!          SIZE(A,2) == n.
!!          The generated m by n matrix A.
!
!!  KL      (input) INTEGER
!!          The number of nonzero subdiagonals within the band of A.
!!          0 <= KL <= M-1.
!
!!  KU      (input) INTEGER
!!          The number of nonzero superdiagonals within the band of A.
!!          0 <= KU <= N-1.
!
!!  D       (input) REAL array, dimension (min(M,N))
!!          The diagonal elements of the diagonal matrix D.
!
!!  ISEED   Optional (input/output) INTEGER array, shape (:),
!!          SIZE(ISEED) == 4.
!!          On entry, the seed of the random number generator; the array
!!          elements must be between 0 and 4095, and ISEED(4) must be
!!          odd.
!!          On exit, the seed is updated.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LAGGE"
!!     .. "LOCAL Scalars" ..
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, LKL, LKU, M, MN, N, SD, SISEED
!!     .. "Local Arrays" ..
      INTEGER :: LISEED(4)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: LD(:)
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX, MIN
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      MN = MIN(M,N); ISTAT = 0
      IF( PRESENT(KL) )THEN; LKL = KL; ELSE; LKL = M-1; ENDIF
      IF( PRESENT(KU) )THEN; LKU = KU; ELSE; LKU = M-1; ENDIF
      IF( PRESENT(D) )THEN; SD = SIZE(D); ELSE; SD = MN; ENDIF
      IF( PRESENT(ISEED) )THEN; SISEED = SIZE(ISEED); LISEED = ISEED
      ELSE; SISEED = 4
            LISEED(1) = 15; LISEED(2) = 1926
            LISEED(3) = 16; LISEED(4) = 1931; ENDIF
!!     .. "Test the arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( LKL < 0 .OR. LKL > M-1 )THEN; LINFO = -2
      ELSE IF( LKU < 0 .OR. LKU > N-1 )THEN; LINFO = -3
      ELSE IF( SD /= MN )THEN; LINFO = -4
      ELSE IF( SISEED /= 4 .OR. PRESENT(ISEED) .AND. (                  &
     &   ( LISEED(1) < 0 .OR. LISEED(1) > 4095 ) .OR.                   &
     &   ( LISEED(2) < 0 .OR. LISEED(2) > 4095 ) .OR.                   &
     &   ( LISEED(3) < 0 .OR. LISEED(3) > 4095 ) .OR.                   &
     &   ( LISEED(4) < 0 .OR. LISEED(4) > 4095 ) .OR.                   &
     &   ( MOD( LISEED(4), 2 ) == 0 ) ) )THEN; LINFO = -5
      ELSE
         IF( PRESENT(D) )THEN; LD => D
         ELSE; ALLOCATE( LD( MN ), STAT=ISTAT); ENDIF
         IF( ISTAT == 0 )THEN
            ALLOCATE( WORK( M + N ), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               IF( .NOT. PRESENT(D) )THEN
                  LD(1:MN-1) = 1.0_WP; LD(MN) = 0.5_WP; ENDIF
               CALL LAGGE_F77( M, N, LKL, LKU, LD, A, LDA, LISEED, WORK, LINFO )
               IF( PRESENT(ISEED) )ISEED = LISEED
            ELSE; LINFO = -100; END IF
            DEALLOCATE( WORK, STAT=ISTAT1 )
         ENDIF
         IF( .NOT. PRESENT(D) )DEALLOCATE( LD, STAT=ISTAT1)
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE DLAGGE_F95
FUNCTION DLAMCH_F95( PRECISION, CMACH, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. "Use Statements" ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: DLAMCH                                             !!((07-B-INT_LAPACK1.f90))
!!  .. "Implicit Statement" ..
   IMPLICIT NONE
!!  .. "Scalar Arguments" ..
   CHARACTER(LEN=1), INTENT(IN) :: CMACH
   REAL(WP), INTENT(IN) :: PRECISION
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP) :: DLAMCH_F95
!--------------------------------------------------
!! .. "Parameters" ..
   CHARACTER( LEN=10 ), PARAMETER :: CHR="ESBPNRMULO"
   CHARACTER( LEN=10 ), PARAMETER :: SRNAME = "LA_LAMCH"
!! .. "Local Scalars" ..
   INTEGER :: I, LINFO
!!  .. "Executable Statements" ..
   LINFO = 2; DLAMCH_F95 = PRECISION
   DO I = 1, 10
     IF( LSAME(CMACH, CHR(I:I)) ) LINFO = 0
   END DO
   DLAMCH_F95 = DLAMCH(CMACH)
   CALL ERINFO( LINFO, SRNAME, INFO )
END FUNCTION DLAMCH_F95
      FUNCTION DLANGE1_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: DLANGE1_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      REAL(WP), INTENT(IN) :: A(:)
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET :: LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A); N = 1; LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           DLANGE1_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION DLANGE1_F95
      FUNCTION DLANGE_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: DLANGE_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      REAL(WP), INTENT(IN) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LANGE  returns the value of the one norm,  or the Frobenius norm,
!!  or the  infinity norm,  or the  element of  largest absolute value
!!  of a complex matrix A.
!
!!  Description
!!  ===========
!
!!  LA_LANGE returns the value
!
!!     LA_LANGE = ( max(abs(A(i,j))), NORM = "M" or "m"
!!              (
!!              ( norm1(A),         NORM = "1", "O" or "o"
!!              (
!!              ( normI(A),         NORM = "I" or "i"
!!              (
!!              ( normF(A),         NORM = "F", "f", "E" or "e"
!
!!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!!  =========
!
!!  FUNCTION LA_ANGE( A, NORM, INFO )
!!     REAL(<wp>) :: LA_ANGE
!!     <type>(<wp>), INTENT(IN) :: <a>
!!     CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!     <a>    ::= A(:,:) | A(:)
!
!!  Arguments
!!  =========
!
!!  A       (input) COMPLEX array, shape either (:,:) or (:).
!!          If shape is (:,:) then SIZE(A,1) == m, SIZE(A,2) == n.
!!          If shape is (:) then SIZE(A) == n.
!!          If either m or n == 0 LA_LANGE is set to zero.
!!          The m by n matrix A.
!
!!  NORM    (input) CHARACTER*1
!!          Specifies the value to be returned in LA_LANGE as described
!!          above.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET ::LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           DLANGE_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION DLANGE_F95
SUBROUTINE DORGTR_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: ORGTR_F77 => LA_ORGTR, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: TAU(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_ORGTR / LA_UNGTR generates a real orthogonal / complex unitary
!! matrix Q which is defined as the product of elementary reflectors,
!! as returned by LA_SYTRD / LA_HETRD:
!!
!! if UPLO = "U", Q = H(n-1) . . . H(2) H(1),
!
!! if UPLO = "L", Q = H(1) H(2) . . . H(n-1).
!
!! =======
!
!!    SUBROUTINE LA_ORGTR / LA_UNGTR( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(IN) :: TAU(:)
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the vectors which define the elementary
!!            reflectors, as returned by LA_SYTRD or LA_HETRD.
!!         On exit the orthogonal or unitary matrix Q.
!
!! TAU     (input) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         TAU(i) must contain the scalar factor of the elementary
!!         reflector H(i), as returned by LA_SYTRD or LA_HETRD.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! ----------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_ORGTR"
   CHARACTER(LEN=5), PARAMETER :: BSNAM  = "DORGQ"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   CHARACTER(LEN=6) :: BSNAME
   INTEGER :: LINFO, LWORK, NB, ISTAT, ISTAT1, N, LD
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      IF( LSAME(LUPLO,"U") )THEN; BSNAME = BSNAM // "L"
      ELSE; BSNAME = BSNAM // "R"; ENDIF
      NB = ILAENV_F77( 1, BSNAME, " ", N-1, N-1, N-1, -1 )
      IF( NB < 1 .OR. NB >= N ) NB = 1
      LWORK = MAX( 1, (N-1)*NB ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT)
         LWORK = MAX( 1, N-1 ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!     .. CALL LAPACK77 ROUTINE
         CALL ORGTR_F77( LUPLO, N, A, LD, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE DORGTR_F95
 SUBROUTINE DPBSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, 1, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPBSV1_F95
 SUBROUTINE DPBSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSV computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. The Cholesky decomposition is used to
!! factor A as A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular band matrix and L is a lower triangular
!! band matrix, each with the same number of superdiagonals or subdiagonals
!! as A. The factored form of A is then used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_PBSV( AB, B, UPLO=uplo, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!         of superdiagonals or subdiagonals in the band and n is the
!!         order of A.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The (kd + 1) diagonals of
!!         A are stored in the rows of AB so that the j-th column of A is
!!         stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                  1<=j<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U = L*L^H in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1)
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, NRHS, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPBSV_F95
SUBROUTINE DPBSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                            S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, KD
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, 1, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPBSVX1_F95
SUBROUTINE DPBSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                           S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSVX computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B
!! are rectangular matrices or vectors.
!!     LA_PBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PBSVX( AB, B, X, UPLO=uplo, AFB=afb, FACT=fact, &
!!                             EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                             RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             <type>(<wp>), INTENT(OUT) :: <sol>
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!             CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!             REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!             <sol>  ::= X(:,:) | X(:)
!!             <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!          of superdiagonals or subdiagonals and n is the order of A.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!          triangle of matrix A, or its equilibration, in band storage.
!!          The (kd + 1) diagonals of A are stored in the rows of AB so
!!          that the j-th column of A is stored in the j-th column of AB
!!          as follows:
!!          if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!          if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in AB; otherwise, AB is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!          and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFB      Optional (input or output) REAL or COMPLEX array, shape (:)
!!          with the same size as AB.
!!          If FACT = "F" then AFB is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_PBSVX.
!!          If FACT /= "F" then AFB is an output argument that contains
!!          the factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is supplied
!!          on entry, and if not, whether A should be equilibrated before
!!          it is factored.
!!            = "N": The matrix A will be copied to AFB and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to
!!                 AFB and factored.
!!            = "F": AFB contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)
!!          = size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!                is not positive definite, so the factorization could
!!                not be completed and the solution and error bounds
!!                could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!                machine precision, so the matrix is singular to
!!                working precision. Nevertheless, the solution and
!!                error bounds are computed because the computed solution
!!                can be more accurate than the value of RCOND would
!!                suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, SFERR, SBERR, KD
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A,1) < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, NRHS, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPBSVX_F95
 SUBROUTINE DPOSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, 1, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPOSV1_F95
 SUBROUTINE DPOSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_POSV computes the solution to a linear system of equations
!! A*X=B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices
!! or vectors. The Cholesky decomposition is used to factor A as
!! A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!         SUBROUTINE LA_POSV( A, B, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX square array, shape (:,:).
!!       On entry, the matrix A.
!!       If UPLO = "U", the upper triangular part of A contains the upper
!!       triangular part of the matrix A, and the strictly lower triangular
!!       part of A is not referenced. If UPLO = "L", the lower triangular
!!       part of A contains the lower triangular part of the matrix A, and
!!       the strictly upper triangular part of A is not referenced.
!!       On exit, the factor U or L from the Cholesky factorization
!!       A = U^H*U = L*L^H.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!       On entry, the matrix B.
!!       On exit, the solution matrix X.
!! UPLO  Optional (input) CHARACTER(LEN=1)
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!       Default value: "U".
!! INFO  Optional (output) INTEGER
!!       = 0: sauccessful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!          completed and the solution could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, NRHS, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPOSV_F95
SUBROUTINE DPOSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPOSVX1_F95
SUBROUTINE DPOSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!   LA_POSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors.
!!   LA_POSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_POSVX( A, B, X, UPLO=uplo, AF=af, FACT=fact, &
!!                          EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                          RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!            REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A or its equilibration:
!!          If UPLO = "U", then the upper triangular part of A contains
!!          the upper triangular part of (the equilibrated) A, and the
!!          strictly lower triangular part of A is not referenced.
!!          If UPLO = "L", then the lower triangular part of A contains
!!          the lower triangular part of (the equilibrated) A, and the
!!          strictly upper triangular part of A is not referenced.
!!          If FACT = "F" and EQUED = "Y", then A has been equilibrated
!!          by the scaling factors in S during a previous call to
!!          LA_POSVX.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in A; otherwise, A is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = size(A,1) or shape (:) with size(B) =
!!          size(A,1).
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!          size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!          = size(A,1).
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AF       Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as A.
!!          If FACT = "F" then AF is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_POSVX
!!          If FACT /= "F" then AF is an output argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is
!!          supplied on entry, and, if not, whether A should be
!!          equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored
!!                 (no equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)=
!!          size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j), FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the leading minor of order i of (the equilibrated)
!!                  A is not positive definite, so the factorization
!!                  could not be completed and the solution and error
!!                  bounds could not be computed. RCOND= 0 is returned.
!!              = n+1: U or L is nonsingular, but RCOND is less than
!!                  machine precision, so the matrix is singular to
!!                  working precision. Nevertheless, the solution and
!!                  error bounds are computed because the computed
!!                  solution can be more accurate than the value of
!!                    RCOND would suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:), LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPOSVX_F95
SUBROUTINE DPOTRF_F95( A, UPLO, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POTRF_F77 => LA_POTRF, LANSY_F77 => LA_LANSY, &    !!((07-B-INT_LAPACK1.f90))
                                  POCON_F77 => LA_POCON
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL  :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_POTRF computes the Cholesky factorization of a real symmetric or
!! complex Hermitian positive definite matrix A.
!
!! The factorization has the form
!!    A = U**H * U,  if UPLO = "U", or
!!    A = L * L**H,  if UPLO = "L",
!! where U is an upper triangular matrix and L is lower triangular.
!
!! This is the block version of the algorithm, calling Level 3 BLAS.
!
!! LA_POTRF optionally estimates the reciprocal of the condition number
!! (in the 1-norm) of a real symmetric or complex Hermitian positive
!! definite matrix A.
!! An estimate is obtained for norm(inv(A)), and the reciprocal of the
!! condition number is computed as RCOND = 1 / (norm(A) * norm(inv(A))).
!
!! =======
!
!!    SUBROUTINE LA_POTRF( A, UPLO, RCOND, NORM, INFO )
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the factor U or L from the Cholesky
!!            factorization A = U**H*U or A = L*L**H.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored;
!!            = "L":  Lower triangle of A is stored.
!!         otherwise UPLO = "U" is assumed.
!
!! RCOND   Optional (output) REAL
!!         The reciprocal of the condition number of the matrix A
!!         computed as RCOND = 1/(norm(A) * norm(inv(A))).
!! NORM    Optional (input) CHARACTER*1
!!         Specifies whether the 1-norm condition number or the
!!         infinity-norm condition number is required:
!!           If NORM is present then:
!!              = "1", "O" or "o": 1-norm;
!!              = "I" or "i": infinity-norm.
!!           otherwise NORM = "1" is used.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!            > 0: if INFO = i, the leading minor of order i is not
!!               positive definite, and the factorization could not be
!!               completed.
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! --------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LNORM, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, LD
   REAL(WP) :: ANORM
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .AND. N < 0 )THEN; LINFO = -1
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -2
   ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
            ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
              .AND. LNORM /= "1" ) ) THEN; LINFO = -4
   ELSE IF(  N > 0 )THEN
      IF( PRESENT(RCOND) ) THEN
!!     .. COMPUTE THE NORM OF THE MATRIX A
         ALLOCATE(WORK(N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN; ANORM = LANSY_F77( LNORM, LUPLO, LD, A, N, WORK )
         ELSE; LINFO = -100; END IF
         DEALLOCATE(WORK, STAT=ISTAT1)
      END IF
!
      IF( LINFO == 0 ) THEN
!!     .. COMPUTE THE CHOLESKY FACTORS OF THE MATRIX A
         CALL POTRF_F77( LUPLO, N, A, LD, LINFO )
!
         IF( PRESENT(RCOND) .AND. LINFO == 0 ) THEN
!!        .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
            IF( ANORM == 0.0_WP )THEN; RCOND = 0.0_WP
            ELSE; ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT)
               IF( ISTAT == 0 )THEN
                  CALL POCON_F77( LUPLO, N, A, LD, ANORM, RCOND, &
                                  WORK, IWORK, LINFO )
               ELSE; LINFO = -100; END IF
               DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
            END IF
         END IF
      END IF
   ELSE IF( PRESENT(RCOND) ) THEN; RCOND = 1.0_WP; ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DPOTRF_F95
 SUBROUTINE DPPSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, 1, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPPSV1_F95
 SUBROUTINE DPPSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PPSV computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format. The Cholesky decomposition is
!! used to factor A as
!!      A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSV( AP, B, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)
!!         = n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U or A = L*L^H , in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! UPLO    Optional, (input) CHARACTER(LEN=1)
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, NRHS, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPPSV_F95
SUBROUTINE DPPSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SAF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPPSVX1_F95
SUBROUTINE DPPSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PPSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format.
!!     LA_PPSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                  FACT=fact, EQUED=equed, S=s, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!           CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!           REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX square array, shape (:) with
!!         size(AP) = n*(n + 1)=2, where n is a rank of the matrix A.
!!         On entry, the upper or lower triangle of matrix A, or its
!!         equilibration, in packed storage. The elements are stored
!!         columnwise as follows:
!!         if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, if FACT = "E", then the equilibrated version of A is
!!         stored in AP; otherwise, AP is unchanged.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the scaled version of B if the system has been
!!         equilibrated; otherwise, B is unchanged.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AFP     Optional (input or output) REAL or COMPLEX array, shape (:)
!!         with the same size as AP.
!!         If FACT = "F" then AFP is an input argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A, in the same storage format as A, returned by
!!         a previous call to LA_PPSVX.
!!         If FACT 6= "F" then AFP is an output argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A in the same storage format as A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A is supplied
!!         on entry, and, if not, whether A should be equilibrated before
!!         it is factored.
!!           = "N": The matrix A will be copied to AFP and factored
!!                (no equilibration).
!!           = "E": The matrix A will be equilibrated, then copied to AFP
!!                and factored.
!!           = "F": AFP contains the factored form of (the equilibrated) A.
!!         Default value: "N".
!! EQUED   Optional (input or output) CHARACTER(LEN=1).
!!         Specifies the form of equilibration that was done.
!!         EQUED is an input argument if FACT = "F", otherwise it is an
!!         output argument:
!!           = "N": No equilibration (always true if FACT = "N").
!!           = "Y": Equilibration, i.e., A has been premultiplied and
!!                postmultiplied by diag(S).
!!         Default value: "N".
!! S       Optional (input or output) REAL array, shape (:) with size(S)
!!         = size(A,1).
!!         The scaling factors for A.
!!         S is an input argument if FACT = "F" and EQUED = "Y".
!!         S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR    Optional (output) REAL array of shape (:), with size(FERR) =
!!         size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j) , FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of (the
!!         equilibrated) A. If RCOND is less than the machine precision,
!!         the matrix is singular to working precision. This condition is
!!         indicated by a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!               is not positive definite, so the factorization could
!!               not be completed and the solution and error bounds
!!               could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!               machine precision, so the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!               error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SAF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPPSVX_F95
 SUBROUTINE DPTSV1_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    REAL(WP), INTENT(INOUT) :: E(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, 1, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPTSV1_F95
 SUBROUTINE DPTSV_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    REAL(WP), INTENT(INOUT) :: E(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSV computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. A is factored as A = L*D*L^H, where L
!! is a unit lower bidiagonal matrix and D is a diagonal matrix. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!        SUBROUTINE LA_PTSV( D, E, B, INFO=info )
!!            REAL(<wp>), INTENT(INOUT) :: D(:)
!!            <type>(<wp>), INTENT(INOUT) :: E(:), <rhs>
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal of A.
!!        On exit, the diagonal of D.
!! E      (input/output) REAL or COMPLEX array, shape (:), with
!!        size(E) = n-1.
!!        On entry, the subdiagonal of A.
!!        On exit, the subdiagonal of L.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, the leading minor of order i of A is not
!!             positive definite, and the solution has not been computed.
!!           The factorization has not been completed unless i = n.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, NRHS, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE DPTSV_F95
SUBROUTINE DPTSVX1_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   REAL(WP), INTENT(IN) :: E(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SDF, SEF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: LDF(:)
   REAL(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -3
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, 1, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPTSVX1_F95
SUBROUTINE DPTSVX_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   REAL(WP), INTENT(IN) :: E(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSVX computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors.
!!    LA_PTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_PTSVX( D, E, B, X, DF=df, EF=ef, FACT=fact, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, INFO=info )
!!          REAL(<wp>), INTENT(IN) :: D(:)
!!          <type>(<wp>), INTENT(IN) :: E(:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: DF(:)
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: EF(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! D       (input) REAL array, shape (:) with size(D) = n, where n is the
!!         order of A.
!!         The diagonal of A.
!! E       (input) REAL or COMPLEX array, shape (:) with size(E) = n-1.
!!         The subdiagonal of A.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) = n
!!         or shape (:) with size(B) = n.
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! DF      Optional (input or output) REAL array, shape (:) with the same
!!         size as D.
!!         If FACT = "F", then DF is an input argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!!         If FACT = "N", then DF is an output argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!! EF      Optional (input or output) REAL or COMPLEX array, shape (:) with
!!         the same size as E.
!!         If FACT = "F", then EF is an input argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!!         If FACT = "N", then EF is an output argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of A has been supplied on
!!         entry.
!!           = "N": The matrix A will be copied to DF and EF and factored.
!!           = "F": DF and EF contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j), FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element in
!!         X(j).
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL.
!!         The estimate of the reciprocal condition number of the matrix
!!         A. If RCOND is less than the machine precision, the matrix is
!!         singular to working precision. This condition is indicated by
!!         a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of A is not positive
!!                definite, so the factorization could not be completed
!!                unless i = n, and the solution and error bounds could
!!                not be computed. RCOND = 0 is returned.
!!             = n+1: L is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error
!!                  bounds are computed because the computed solution can
!!                  be more accurate than the value of RCOND would suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SDF, SEF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: LDF(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -3
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, NRHS, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DPTSVX_F95
SUBROUTINE DSBEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBEV_F77 => LA_SBEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SBEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
            CALL SBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LINFO )
         ELSE
            CALL SBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBEV_F95
SUBROUTINE DSBEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBEVD_F77 => LA_SBEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1)); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, 2*N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1 + 5*N + 2*N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N ); LIWORK = 1
         ELSE; LWORK = 1 + 5*N + 2*N**2; LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
          CALL SBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
        ELSE
          CALL SBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
        ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBEVD_F95
SUBROUTINE DSBEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: SBEVX_F77 => LA_SBEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBEVX / LA_HBEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! band matrix A. Eigenvalues and eigenvectors can be selected by
!! specifying either a range of values or a range of indices for the
!! desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SBEVX / LA_HBEVX( AB, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 Q=q, ABSTOL=abstol, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!            INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!            INTEGER, INTENT(OUT), OPTIONAL :: M
!!            INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL j COMPLEX
!!            <wp> ::= KIND(1.0) j KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!        of subdiagonals or superdiagonals in the band and n is the order
!!        of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U" the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U" : Upper triangle of A is stored;
!!        = "L" : Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        the matrix A corresponding to the selected eigenvalues, with the
!!        i-th column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). If an eigenvector fails to converge, then
!!        that column of Z contains the latest approximation to the
!!        eigenvector, and the index of the eigenvector is returned in
!!        IFAIL.
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in
!!        advance, an upper bound must be used. In all cases M<=n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0<=M<=size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) = n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional (output) REAL or COMPLEX square array, shape(:,:) with
!!        size(Q,1) = n.
!!        The n by n unitary matrix used in the reduction to tridiagonal
!!        form. This is computed only if Z is present.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|, |b|),
!!        where <wp> is the working precision. If ABSTOL<=0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing A to tridiagonal form. Eigenvalues will be computed most
!!        accurately when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, S1Q, S2Q, KD
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1), LLQ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:), LQ(:,:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1 ) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
         IF( ISTAT == 0 )THEN
            IF( PRESENT(Q) )THEN; LQ => Q
            ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
         END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,7*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
               CALL SBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                IWORK, LIFAIL, LINFO )
            ELSE
               CALL SBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBEVX_F95
SUBROUTINE DSBGV_F95( A, B, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBGV_F77 => LA_SBGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SBGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KA, KB, &
              LDA, LDB
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KA = SIZE(A,1)-1; N = SIZE(A,2); LDA = MAX(SIZE(A,1),1)
   ISTAT = 0; KB = SIZE(B,1)-1; LDB = MAX(SIZE(B,1),1)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( KB < 0 .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
            CALL SBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, Z, S1Z, &
                        WORK, LINFO )
         ELSE
            CALL SBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, LLZ, S1Z, &
                        WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBGV_F95
SUBROUTINE DSBGVD_F95( AB, BB, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP =>  DP                                     !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBGVD_F77 => LA_SBGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KAB, KBB, &
          LDAB, LDBB, LWORK, LIWORK, IWORKMIN(1)
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; KAB = SIZE(AB,1)-1; N = SIZE(AB,2); LDAB = MAX(SIZE(AB,1),1)
      ISTAT = 0; KBB = SIZE(BB,1)-1; LDBB = MAX(SIZE(BB,1),1)
      IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
      ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
        IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
          IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
          ELSE IF( KBB < 0 .OR. SIZE(BB,2) /= N ) THEN; LINFO = -2
          ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
          ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
          ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
          ELSE IF( N > 0 )THEN
            LIWORK = -1
            LWORK = -1
            IF (PRESENT (Z)) THEN
               CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &               LDBB, W, Z, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            ELSE
             CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &               LDBB, W, LLZ, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            ENDIF
            LWORK = WORKMIN(1)
             LIWORK = IWORKMIN(1)
            ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
            IF (PRESENT (Z)) THEN
                CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &            LDBB, W, Z, S1Z,  WORK, LWORK, IWORK, LIWORK, LINFO )
            ELSE
                CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &            LDBB, W, LLZ, S1Z,  WORK, LWORK, IWORK, LIWORK, LINFO )
            ENDIF
              ELSE; LINFO = -100; ENDIF
                DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
              ENDIF
              CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBGVD_F95
SUBROUTINE DSBGVX_F95( AB, BB,  W, UPLO, Z, VL, VU, IL, IU, &
      &         M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  DP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SBGVX_F77 => LA_SBGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
      REAL(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBGVX and LA_HBGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of the generalized eigenvalue problem
!!                      A*z = lambda*B*z,
!! where A and B are real symmetric in the case of LA_SBGVX and complex
!! Hermitian in the case of LA_HBGVX. In both cases B is positive
!! definite. Matrices A and B are stored in a band format. Eigenvalues
!! and eigenvectors can be selected by specifying either a range of
!! values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_SBGVX / LA_HBGVX( AB, BB, W, UPLO=uplo, Z=z, &
!!                   VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, Q=q, &
!!                   ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!        of subdiagonals or superdiagonals in the band of A and n is
!!        the order of A and B.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of A in band storage. The ka + 1 diagonals of A are
!!        stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                   1<=j<=n.
!!        On exit, the contents of AB are destroyed.
!! BB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!        of subdiagonals or superdiagonals in the band of B.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix B in band storage. The kb + 1 diagonals of
!!        B are stored in the rows of BB so that the j-th column of B
!!        is stored in the j-th column of BB as follows:
!!        if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                   1<=j<=n.
!!        On exit, the factor S from the split Cholesky factorization
!!                     B = S^H*S.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangles of A and B are stored;
!!            = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!        with size(Z,1) = n.
!!        The first M columns of Z contain the orthonormal eigenvectors
!!        corresponding to the selected eigenvalues, with the i-th
!!        column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). The eigenvectors are normalized so that
!!        Z^H*B*Z = I . If an eigenvector fails to converge, then that
!!        column of Z contains the latest approximation to the
!!        eigenvector and the index of the eigenvector is returned in
!!        IFAIL.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL)=n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional, (Output) REAL or COMPLEX square array, shape(:,:)
!!        with size(Q,1) = n.
!!        If Z is present, the matrix used in the reduction of
!!        A*z = lambda*B*z to tridiagonal form.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An
!!        approximate eigenvalue is accepted as converged when it is
!!        determined to lie in an interval [a,b] of width less than or
!!        equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal
!!        form. Eigenvalues will be computed most accurately when ABSTOL
!!        is set to twice the underflow threshold
!!                   2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i,
!!             then i eigenvectors failed to converge. Their indices
!!             are stored in array IFAIL.
!!           > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!             minor of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!        If INFO is not present and an error occurs, then the program
!!        is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBGVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDAB, LDBB, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, S1Q, S2Q, KAB, KBB
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP), TARGET :: LLZ(1,1), LLQ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:), LQ(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KAB = SIZE(AB,1)-1; KBB = SIZE(BB,1)-1
   N = SIZE(AB,2); LDAB = MAX(1,SIZE(AB,1))
   LDBB = MAX(1, SIZE(BB,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
      ELSE; LRANGE = "A" ; END IF

      IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE  IF (KBB < 0) THEN; LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
      ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
      ELSE IF( LVU < LVL )THEN; LINFO = -6
      ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &    (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
      ELSE IF( LRANGE == "I" .AND. ( LIU.LT.MIN( N, LIL ) .OR. LIU.GT.N)) THEN; LINFO = -8
      ELSE IF( N < LIU )THEN; LINFO = -9
      ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
      ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
      ELSE IF( N > 0 )THEN
          IF( PRESENT(Z) ) THEN; LJOBZ = "V"
            IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
            ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
            IF( ISTAT == 0 )THEN
              IF( PRESENT(Q) )THEN; LQ => Q
              ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
            END IF
          ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!! .. DETERMINE THE WORKSPACE
          IF( ISTAT == 0 ) THEN
            ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,7*N)), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
              ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
               IF (PRESENT (Z))  THEN
                CALL SBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z,&
     &            S1Z, WORK, IWORK, LIFAIL, LINFO )
               ELSE
                CALL SBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, LLZ,&
     &            S1Z, WORK, IWORK, LIFAIL, LINFO )
               ENDIF
                  IF( PRESENT(M) ) M = LM
                ELSE; LINFO = -100; END IF
                END IF
        IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
        IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
        DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSBGVX_F95


SUBROUTINE DSPEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPEV_F77 => LA_SPEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
          CALL SPEV_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LINFO )
         ELSE
          CALL SPEV_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPEV_F95
SUBROUTINE DSPEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPEVD_F77 => LA_SPEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LIWORK
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, 2*N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1+ 6*N+N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N ); LIWORK = 1
         ELSE
            LWORK = 1+ 6*N+N**2
            LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
           CALL SPEVD_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ELSE
           CALL SPEVD_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPEVD_F95
SUBROUTINE DSPEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: SPEVX_F77 => LA_SPEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SPEVX / LA_HPEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex hermitian
!! matrix A in packed storage. Eigenvalues and eigenvectors can be
!! selected by specifying either a range of values or a range of indices
!! for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SPEVX / LA_HPEVX( AP, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 ABSTOL=abstol, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!!  AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n+1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!          On exit, AP is overwritten by values generated during the
!!          reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!          diagonal and first superdiagonal of T overwrite the correspond-
!!          ing diagonals of A. If UPLO = "L", the diagonal and first
!!          subdiagonal of T overwrite the corresponding diagonals of A.
!!  W       (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!!  UPLO    Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors of
!!          the matrix A corresponding to the selected eigenvalues, with the
!!          i-th column of Z containing the eigenvector associated with
!!          the eigenvalue in W(i) . If an eigenvector fails to converge,
!!          then that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are supplied
!!          in the array Z. When the exact value of M is not known in
!!          advance, an upper bound must be used. In all cases M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th
!!          eigenvalues will be found. 1<=IL<=IU<=size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0<=M<=size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL+EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL<=0, then
!!          EPSILON(1.0_<wp>)*||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing A to tridiagonal form. Eigenvalues will be computed
!!          most accurately when ABSTOL is set to twice the underflow
!!          threshold 2*LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2*LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!          indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPEVX"
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, NN
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &      (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N > 0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
               CALL SPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                  LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                  IWORK, LIFAIL, LINFO )
            ELSE
               CALL SPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                  LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                  IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPEVX_F95
SUBROUTINE DSPGV_F95( A, B, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPGV_F77 => LA_SPGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
   COMPLEX(WP) :: WW
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= SIZE(A)  )THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
           CALL SPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, Z, S1Z, &
                        WORK, LINFO )
         ELSE
           CALL SPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, LLZ, S1Z, &
                        WORK, LINFO )
        ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPGV_F95
SUBROUTINE DSPGVD_F95( AP, BP, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPGVD_F77 => LA_SPGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: AP(:), BP(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) ::  LJOBZ, LUPLO
      INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, S1Z, S2Z
      INTEGER :: LWORK, LIWORK
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      INTEGER :: IWORKMIN(1)
      COMPLEX(WP) :: WW
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; NN = SIZE(AP)
      WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
      IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
        IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
        ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
          IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
            IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
            ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
            ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
            ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
            ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
            ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
            ELSE IF( N > 0 )THEN
!!  QUERING THE SIZE OF WORKSPACE ...
                LWORK = -1
                LIWORK = -1
                IF (PRESENT (Z)) THEN
                   CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                Z, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
                ELSE
                   CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                LLZ, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
                ENDIF
                LWORK = WORKMIN(1)
                LIWORK= IWORKMIN(1)
                ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
                IF( ISTAT == 0 )THEN
                  IF (PRESENT(Z)) THEN
                     CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                    Z, S1Z, WORK, LWORK, IWORK, LIWORK, LINFO )
                  ELSE
                     CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                    LLZ, S1Z, WORK, LWORK, IWORK, LIWORK, LINFO )
                  ENDIF
                ELSE; LINFO = -100; ENDIF
                ENDIF
                DEALLOCATE(WORK, IWORK, STAT=ISTAT)
                CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPGVD_F95


SUBROUTINE DSPGVX_F95( AP, BP, W, ITYPE, UPLO, Z, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SPGVX_F77 => LA_SPGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      REAL(WP), INTENT(INOUT) :: AP(:), BP(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPGVX and LA_HPGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!       A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SPGVX and complex
!! Hermitian in the case of LA_HPGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues. Matrices A and B are stored in a packed format.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGVX / LA_HPGVX( AP, BP, W, ITYPE= itype, &
!!             UPLO= uplo, Z= z, VL= vl, VU= vu, IL= il, IU= iu, M= m, &
!!             IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!         <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!         REAL(<wp>), INTENT(OUT) :: W(:)
!!         INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!         INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!         INTEGER, INTENT(OUT), OPTIONAL :: M
!!         INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^T*U or B = L*L^T, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX rectangular array, shape
!!          (:,:) with size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          corresponding to the selected eigenvalues, with the i-th
!!          column of Z holding the eigenvector associated with the
!!          eigenvalue in W(i). The eigenvectors are normalized as
!!          follows:
!!            if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!            if ITYPE = 3: Z^H * B^-1 * Z = I .
!!          If an eigenvector fails to converge, then that column of Z
!!          contains the latest approximation to the eigenvector and the
!!          index of the eigenvector is returned in IFAIL.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!          size(A,1).
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing the generalized eigenvalue problem to tridiagonal
!!          form. Eigenvalues will be computed most accurately when
!!          ABSTOL is set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with 0 < INFO <= n, then some
!!          eigenvectors did not converge.
!!          Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!          > 0: the algorithm failed to converge or matrix B is not
!!            positive definite:
!!             <= n: the algorithm failed to converge; if INFO = i, then
!!              i eigenvectors failed to converge. Their indices are
!!              stored in array IFAIL.
!!             > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!              minor of order i of B is not positive definite. The
!!              factorization of B could not be completed and no
!!                eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPGVX"
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
      INTEGER :: N, LINFO, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, NN, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
      COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(AP)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
   ELSE ; LRANGE = "A"; END IF

   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF (LITYPE <1 .OR. LITYPE >3) THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &  (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE,"I") .AND. ( LIU < MIN(N, LIL) .OR. LIU > N ))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
        IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
        ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
        ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
       IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
           IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
           ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
             IF (PRESENT (Z)) THEN
                  CALL SPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &              LVU, LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, IWORK, LIFAIL, &
     &              LINFO )
             ELSE
                  CALL SPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &              LVU, LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, IWORK, LIFAIL, &
     &              LINFO )
             ENDIF
             IF( PRESENT(M) ) M = LM
           ELSE; LINFO = -100; END IF
           END IF
           IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
           DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
         END IF
         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSPGVX_F95
 SUBROUTINE DSPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DSPSV1_F95
 SUBROUTINE DSPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DSPSV_F95
SUBROUTINE DSPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), IWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DSPSVX1_F95
SUBROUTINE DSPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), IWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DSPSVX_F95
SUBROUTINE DSTEV_F95( D, E, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEV_F77 => LA_STEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEV and LA_STEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric tridiagonal matrix A.
!!    LA_STEVD uses a divide and conquer algorithm. If eigenvectors are
!! desired, they can be much faster than LA_STEV for large matrices but
!! uses more workspace.
!! =========
!!
!!      SUBROUTINE LA_STEV / LA_STEVD( D, E, Z=z, INFO=info )
!!         REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D    (input/output) REAL array shape (:) with size(D) = n, where n is
!!      the order of A.
!!      On entry, the diagonal elements of the matrix A.
!!      On exit, the eigenvalues in ascending order.
!! E    (input/output) REAL array, shape (:) with size(E) = n.
!!      On entry, the n - 1 subdiagonal elements of A in E(1) to E(n-1).
!!      E(n) need not be set but is used by the routine.
!!      On exit, the contents of E are destroyed.
!! Z    Optional (output) REAL square array, shape(:,:) with size(Z,1)=n.
!!      The columns of Z contain the orthonormal eigenvectors of A in the
!!      order of the eigenvalues.
!! INFO Optional (output) INTEGER.
!!      = 0: successful exit.
!!      < 0: if INFO = -i, the i-th argument had an illegal value.
!!      > 0: if INFO = i, then i elements of E did not converge to zero.
!!      If INFO is not present and an error occurs, then the program is
!!      terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_STEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1), LLWORK(1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N>0 ) THEN; LINFO = -2
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) .AND. N>0)THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
    IF( ISTAT == 0 ) THEN
       IF( PRESENT(Z) )THEN
         ALLOCATE(WORK(MAX(1,2*N-2)), STAT=ISTAT)
         CALL STEV_F77( LJOBZ, N, D, E, Z, S1Z, WORK, LINFO )
       ELSE
         CALL STEV_F77( LJOBZ, N, D, E, LLZ, S1Z, LLWORK, LINFO )
       ENDIF
      ELSE; LINFO = -100; ENDIF
      IF( PRESENT(Z) ) DEALLOCATE(WORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSTEV_F95
SUBROUTINE DSTEVD_F95( D, E, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEVD_F77 => LA_STEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEV and LA_STEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric tridiagonal matrix A.
!!    LA_STEVD uses a divide and conquer algorithm. If eigenvectors are
!! desired, they can be much faster than LA_STEV for large matrices but
!! uses more workspace.
!! =========
!!
!!      SUBROUTINE LA_STEV / LA_STEVD( D, E, Z=z, INFO=info )
!!         REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D    (input/output) REAL array shape (:) with size(D) = n, where n is
!!      the order of A.
!!      On entry, the diagonal elements of the matrix A.
!!      On exit, the eigenvalues in ascending order.
!! E    (input/output) REAL array, shape (:) with size(E) = n.
!!      On entry, the n - 1 subdiagonal elements of A in E(1) to E(n-1).
!!      E(n) need not be set but is used by the routine.
!!      On exit, the contents of E are destroyed.
!! Z    Optional (output) REAL square array, shape(:,:) with size(Z,1)=n.
!!      The columns of Z contain the orthonormal eigenvectors of A in the
!!      order of the eigenvalues.
!! INFO Optional (output) INTEGER.
!!      = 0: successful exit.
!!      < 0: if INFO = -i, the i-th argument had an illegal value.
!!      > 0: if INFO = i, then i elements of E did not converge to zero.
!!      If INFO is not present and an error occurs, then the program is
!!      terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ
   INTEGER :: N, LD, ISTAT1, S1Z, S2Z, LWORK, LIWORK
   INTEGER :: LINFO, ISTAT
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N > 0 )THEN; LINFO = -2
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1+ 4*N + N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = 1; LIWORK = 1
         ELSE
           LWORK = 1+ 4*N + N**2
           LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
            CALL STEVD_F77( LJOBZ, N, D, E, Z, S1Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ELSE
            CALL STEVD_F77( LJOBZ, N, D, E, LLZ, S1Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSTEVD_F95
SUBROUTINE DSTEVR_F95( D, E, W, Z, VL, VU, IL, IU, M, ISUPPZ, &
     &    ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: STEVR_F77 => LA_STEVR, LAMCH_F77 => DLAMCH      !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      REAL(WP), INTENT(INOUT) :: D(:), E(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!       LA_STEVR computes selected eigenvalues and, optionally, the
!! corresponding eigenvectors of a real symmetric tridiagonal matrix A.
!! Eigenvalues and eigenvectors can be selected by specifying either a
!! range of values or a range of indices for the desired eigenvalues.
!!       LA_STEVR uses a relatively robust representation (RRR) algorithm.
!! It is usually the fastest algorithm of all and uses the least
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_STEVR ( D, E, W, Z=z, VL=vl, VU=vu, &
!!                         IL=il, IU=iu, M=m, ISUPPZ=isuppz, &
!!                         ABSTOL=abstol, INFO=info )
!!                 REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!                 REAL(<wp>), INTENT(OUT) :: W(:)
!!                 REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!                 INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!                 REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!                 INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!                 INTEGER, INTENT(OUT), OPTIONAL :: M
!!                 REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!                 INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!                 <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal elements of the matrix A.
!!        On exit, the original contents of D possibly multiplied by a
!!        constant factor to avoid over/underflow in computing the
!!        eigenvalues.
!! E      (input/output) REAL array, shape (:) with size(E) = n.
!!        On entry, the n-1 subdiagonal elements of A in E(1) to E(n-1) .
!!        E(n) need not be set.
!!        On exit, the original contents of E possibly multiplied by a
!!        constant factor to avoid over/underflow in computing the
!!        eigenvalues.
!! W      (output) REAL array with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        A corresponding to the selected eigenvalues, with the i-th column
!!        of Z containing the eigenvector associated with the eigenvalue in
!!        W(i).
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in advance,
!!        an upper bound must be used. In all cases M <= n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= n.
!!        Default values: IL = 1 and IU = n.
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <=  n.
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! ISUPPZ Optional (output) INTEGER array, shape (:) with
!!        size(ISUPPZ) = 2*max(1,M).
!!        The support of the eigenvectors in A, i.e., the indices
!!        indicating the nonzero elements. The i-th eigenvector is nonzero
!!        only in elements ISUPPZ(2*i-1) through ISUPPZ(2*i).
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a, b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)*||A||1 will be used in its place. Eigenvalues
!!        will be computed most accurately if ABSTOL is set to
!!        LA_LAMCH( 1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: an internal error occurred.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LRANGE
      INTEGER :: N, LD, LIL, LIU, LM, SISUPPZ, S1Z, S2Z, NN
      INTEGER :: LINFO, ISTAT, LWORK, LIWORK
      REAL(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER:: IWORKMIN(1), DUMMY(1)
      REAL(WP), TARGET :: WORKMIN(1)
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   NN=2*MAX(1,N)
   IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N/=0)THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= MAX(1,N) ) )THEN; LINFO = -4
   ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND..NOT.PRESENT(Z) )THEN; LINFO = -5
   ELSE IF( LVU < LVL .AND. N>0)THEN; LINFO = -6
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
   ELSE IF (((LIU<LIL) .OR. (LIL<1)) .AND. (N>0))THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( N > 0 )THEN
     IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
     ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
     ELSE; LRANGE = "A"; LM = N; END IF
       IF( PRESENT(Z) ) THEN; LJOBZ = "V"
       ELSE; LJOBZ = "N"
       ENDIF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
       LWORK = -1
       LIWORK = -1
       IF (PRESENT(Z)) THEN
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E,  LVL, LVU, &
     &       LIL, LIU, LABSTOL, LM, W, Z, S1Z, DUMMY, &
     &       WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
       ELSE
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E,  LVL, LVU, &
     &       LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, DUMMY, &
     &       WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
       ENDIF
       LWORK = WORKMIN(1)
       LIWORK = IWORKMIN(1)

       ALLOCATE(IWORK(LIWORK), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 100; ENDIF

       ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 200; ENDIF

       ALLOCATE(WORK(LWORK), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

       IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
       ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF

       IF (PRESENT (Z)) THEN
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
     &     LABSTOL, LM, W, Z, S1Z, LISUPPZ, WORK, LWORK, &
     &     IWORK, LIWORK, LINFO )
       ELSE
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
     &     LABSTOL, LM, W, LLZ, S1Z, LISUPPZ, WORK, LWORK, &
     &     IWORK, LIWORK, LINFO )
       ENDIF

       IF( PRESENT(M) ) M = LM

       DEALLOCATE(WORK)
300    DEALLOCATE(LISUPPZ)
200    DEALLOCATE(IWORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSTEVR_F95
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEVX computes selected eigenvalues and, optionally, the
!! corresponding eigenvectors of a real symmetric tridiagonal matrix A.
!! Eigenvalues and eigenvectors can be selected by specifying either a
!! range of values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_STEVX( D, E, W, Z=z, VL=vl, VU=vu, &
!!                         IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                         ABSTOL=abstol, INFO=info )
!!             REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!             INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!             INTEGER, INTENT(OUT), OPTIONAL :: M
!!             INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D        (input/output) REAL array, shape (:) with size(D) = n, where n
!!          is the order of A.
!!          On entry, the diagonal elements of the matrix A.
!!          On exit, the original contents of D possibly multiplied by a
!!          constant factor to avoid over/underflow in computing the
!!          eigenvalues.
!! E        (input/output) REAL array, shape (:) with size(E) = n.
!!          On entry, the n-1 subdiagonal elements of A in E(1) to E(n-1).
!!          E(n) need not be set.
!!          On exit, the original contents of E possibly multiplied by a
!!          constant factor to avoid over/underflow in computing the
!!          eigenvalues.
!! W        (output) REAL array with size(W) = n.
!!          The first M elements contain the selected eigenvalues in
!!          ascending order.
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          of A corresponding to the selected eigenvalues, with the i-th
!!          column of Z containing the eigenvector associated with the
!!          eigenvalue in W(i) . If an eigenvector fails to converge, then
!!          that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are
!!          supplied in the array Z. When the exact value of M is not
!!          known in advance, an upper bound must be used. In all cases
!!          M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= n.
!!          Default values: IL = 1 and IU = n.
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= n.
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||A||1 will be used in its place.
!!          Eigenvalues will be computed most accurately when ABSTOL is
!!          set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge.
!!             Their indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
SUBROUTINE DSTEVX_F95( D, E, W, Z, VL, VU, IL, IU, M, &
                            IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEVX_F77 => LA_STEVX, LAMCH_F77 => DLAMCH         !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT) :: W(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LRANGE
   INTEGER :: N, LD, LIL, LIU, LM, SIFAIL, S1Z, S2Z
   INTEGER :: LINFO, ISTAT
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(M)) M = 0
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N > 0 )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &         (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"
      LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(5*N), WORK(5*N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT(Z)) THEN
               CALL STEVX_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
                            LABSTOL, LM, W, Z, S1Z, WORK, IWORK, LIFAIL, LINFO )
            ELSE
               CALL STEVX_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
                            LABSTOL, LM, W, LLZ, S1Z, WORK, IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSTEVX_F95
SUBROUTINE DSYEV_F95( A, W, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEV_F77 => LA_SYEV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYEV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LWORK, NB
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; ISTAT = 0; LD = MAX(1,N)
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
     LWORK = (2+NB)*N
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         LWORK = 3*N-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
         CALL SYEV_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, LINFO )
      ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYEV_F95
SUBROUTINE DSYEVD_F95( A, W, JOBZ, UPLO, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEVD_F77 => LA_SYEVD, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LIWORK, LMWORK, LWORK, NB
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"V") )THEN
         LMWORK = 1+6*N+2*N**2
         LIWORK = 3+5*N
      ELSE
         LMWORK = 2*N+1
         LIWORK = 1
      END IF
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
      LWORK = MAX( LMWORK, (NB+2)*N )
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
         LWORK = LMWORK
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, &
                         IWORK, LIWORK,  LINFO )
      ENDIF
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYEVD_F95
SUBROUTINE  DSYEVR_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, M, ISUPPZ, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: SYEVR_F77 => LA_SYEVR                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_SYEVR / LA_HEEVR compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!       LA_SYEVR and LA_HEEVR use a relatively robust representation
!! (RRR) algorithm. It is usually the fastest algorithm of all and uses
!! the least workspace.
!!
!! ========
!!
!!        SUBROUTINE LA SYEVR / LA HEEVR( A, W, JOBZ=jobz, &
!!                 UPLO=uplo, VL=vl, VU=vu, IL=il, IU=iu, M=m, &
!!                 ISUPPZ= isuppz, ABSTOL=abstol, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!           INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!           INTEGER, INTENT(OUT), OPTIONAL :: M
!!           INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A.
!!         On exit:
!!         If JOBZ = "V", then the first M columns of A contain the
!!         orthonormal eigenvectors of the matrix A corresponding to the
!!         selected eigenvalues, with the i-th column of A containing the
!!         eigenvector associated with the eigenvalue in W(i).
!!         If JOBZ = "N", the upper triangle (if UPLO = "U") or the lower
!!         triangle (if UPLO = "L") of A, including the diagonal, is
!!         destroyed.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The first M elements contain the selected eigenvalues in
!!         ascending order.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!         = "N": Computes eigenvalues only;
!!         = "V": Computes eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! VL,VU   Optional (input) REAL.
!!         The lower and upper bounds of the interval to be searched for
!!         eigenvalues. VL < VU.
!!         Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0).
!!         Note: Neither VL nor VU may be present if IL and/or IU is
!!         present.
!! IL,IU   Optional (input) INTEGER.
!!         The indices of the smallest and largest eigenvalues to be
!!         returned. The IL-th through IU-th eigenvalues will be found.
!!            1 <= IL <= IU <= size(A,1).
!!         Default values: IL = 1 and IU = size(A,1).
!!         Note: Neither IL nor IU may be present if VL and/or VU is
!!         present.
!!         Note: All eigenvalues are calculated if none of the arguments
!!         VL, VU, IL and IU are present.
!! M       Optional (output) INTEGER.
!!         The total number of eigenvalues found. 0 <= M <= size(A,1).
!!         Note: If IL and IU are present then M = IU-IL+1.
!! ISUPPZ  Optional (output) INTEGER array, shape (:) with
!!         size(ISUPPZ) = 2*max(1,M).
!!         The support of the eigenvectors in A, i.e., the indices
!!         indicating the nonzero elements. The i-th eigenvector is
!!         nonzero only in elements ISUPPZ(2i-1) through ISUPPZ(2i) .
!!         Note: ISUPPZ must be absent if JOBZ = "N".
!! ABSTOL  Optional (input) REAL.
!!         The absolute error tolerance for the eigenvalues. An
!!         approximate eigenvalue is accepted as converged when it is
!!         determined to lie in an interval [a, b] of width less than or
!!         equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!         where <wp> is the working precision. If ABSTOL <= 0, then
!!         EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!         ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!         reducing A to tridiagonal form.
!!         Default value: 0.0_<wp>.
!!         Note: Eigenvalues are computed most accurately if ABSTOL is set
!!         to LA_LAMCH(1.0_<wp>,"Safe minimum"), not zero.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
     &  LIWORK, SISUPPZ, NN
      INTEGER:: IWORKMIN(1)
      REAL(WP) :: WORKMIN(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      REAL(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
      N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
      NN=2*MAX(1,N)
      IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
      IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
      IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U";  END IF
      IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL);  ENDIF
      IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
      IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
      IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS ..
        IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
        ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
        ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN; LINFO = -3
        ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
        ELSE IF( LVU < LVL )THEN; LINFO = -5
        ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. (PRESENT(IL) .OR. PRESENT(IU)) )THEN
          LINFO = -6
        ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0)THEN; LINFO = -7
        ELSE IF( N < LIU )THEN; LINFO = -8
        ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND.LSAME(LJOBZ,"N"))THEN; LINFO = -10
        ELSE IF( N > 0 )THEN
          IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
            LRANGE = "V"; LM = N
          ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
            LRANGE = "I"; LM = LIU-LIL+1
          ELSE
            LRANGE = "A"; LM = N
          END IF
          IF ( LSAME(LJOBZ,"V") ) THEN
              LDZ=N; LZ=LM
          ELSE
              LDZ=1; LZ=1
          ENDIF
          ALLOCATE (Z(LDZ,LZ), STAT=ISTAT)
!!  .. QUERING THE SIZE OF WORKSPACE ..
            LWORK = -1
            LIWORK = -1
              CALL SYEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &            LIL, LIU, LABSTOL, LM, W, Z, LDZ, IWORKMIN, &
     &            WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            LWORK = WORKMIN(1)
            LIWORK = IWORKMIN(1)
            DEALLOCATE(Z)

            ALLOCATE(IWORK(LIWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 100; ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 200; ENDIF

            ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
            IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

            ALLOCATE(Z(LDZ, LZ), STAT = ISTAT)
            IF(ISTAT /= 0) THEN; LINFO = -100; GOTO 400; ENDIF

            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL; ELSE
!!              LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
              LABSTOL = 0.0_WP;  ENDIF
!! .. CALL LAPACK77 ROUTINE ..
              CALL SYEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &          LIL, LIU, LABSTOL, LM, W, Z, LDZ, LISUPPZ, &
     &          WORK, LWORK, IWORK, LIWORK, LINFO )

              IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
              IF( PRESENT(M) ) M = LM
              IF(PRESENT(ISUPPZ)) ISUPPZ = LISUPPZ

              DEALLOCATE(Z)
400           DEALLOCATE(LISUPPZ)
300           DEALLOCATE(WORK)
200           DEALLOCATE(IWORK)
         ENDIF
100         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYEVR_F95
SUBROUTINE DSYEVX_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEVX_F77 => LA_SYEVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEVX / LA_HEEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!         SUBROUTINE LA_SYEVX / LA_HEEVX ( A, W, JOBZ=jobz, UPLO=uplo, &
!!                        VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                        ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the first M columns of A contain the
!!        orthonormal eigenvectors of the matrix A corresponding to the
!!        selected eigenvalues, with the i-th column of A containing the
!!        eigenvector associated with the eigenvalue in W(i) . If an
!!        eigenvector fails to converge, then that column of A contains the
!!        latest approximation to the eigenvector and the index of the
!!        eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU-IL+1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: IFAIL must be absent if JOBZ = "N".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL<= 0, then
!!        EPSILON(1.0_<wp>)*||T||1 will be used in its place, where ||T||1
!!        is the l1 norm of the tridiagonal matrix obtained by reducing A
!!        to tridiagonal form. Eigenvalues will be computed most accurately
!!        when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
              SIFAIL
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
   IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(M)) M=0
   IF( PRESENT(IFAIL) )THEN
      SIFAIL = SIZE(IFAIL)
   ELSE
      SIFAIL = N
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
   IF( PRESENT(VL) )THEN
      LVL = VL
   ELSE
      LVL = -HUGE(LVL)
   ENDIF
   IF( PRESENT(VU) )THEN
      LVU = VU
   ELSE
      LVU = HUGE(LVU)
   ENDIF
   IF( PRESENT(IL) )THEN
      LIL = IL
   ELSE
      LIL = 1
   ENDIF
   IF( PRESENT(IU) )THEN
      LIU = IU
   ELSE
      LIU = N
   ENDIF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( LVU < LVL )THEN
      LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN
      LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0  )THEN
      LINFO = -7
   ELSE IF( N < LIU )THEN
      LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND.LSAME(LJOBZ,"N") )THEN
          LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
         LRANGE = "V"
         LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
         LRANGE = "I"
         LM = LIU-LIL+1
      ELSE
         LRANGE = "A"
         LM = N
      END IF
      IF ( LSAME(LJOBZ,"V") ) THEN
         LDZ = N
         LZ = LM
      ELSE
         LDZ = 1
         LZ = 1
      ENDIF
      IF( PRESENT(IFAIL) )THEN;
         LIFAIL => IFAIL
      ELSE
         LIFAIL => ISTAT1
      ENDIF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)
      ALLOCATE(IWORK(5*N), Z(LDZ,LZ), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, Z, WORK, STAT=ISTAT1(1))
         LWORK = MAX(1,N*8)
         ALLOCATE(IWORK(5*N), Z(LDZ,LZ), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
         IF( PRESENT(ABSTOL) )THEN
            LABSTOL = ABSTOL
         ELSE
            LABSTOL = 0.0_WP
         ENDIF
!!     .. CALL LAPACK77 ROUTINE
         CALL SYEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
                         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                         LWORK, IWORK, LIFAIL, LINFO )
         IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
         IF( PRESENT(M) ) M = LM
         W(LM+1:N) = 0.0_WP
      END IF
      DEALLOCATE(IWORK, Z, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYEVX_F95
SUBROUTINE DSYGST_F95( A, B, ITYPE, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYGST_F77 => LA_SYGST                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(IN) :: B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYGST / LA_HEGST reduces a real symmetric-definite or complex
!! Hermitian-definite generalized eigenproblem to standard form.
!
!! If ITYPE = 1, the problem is A*x = lambda*B*x,
!! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
!
!! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
!! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
!
!! B must have been previously factorized as U**H*U or L*L**H
!! by LA_POTRF.
!
!! =======
!
!!    SUBROUTINE LA_SYGST / LA_HEGST( A, B, ITYPE, UPLO, INFO )
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       <type(<wp>), INTENT(IN) :: B(:,:)
!!       <type(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!       <type> ::= REAL | COMPLEX
!
!! Defaults
!! ========
!
!! 1. If ITYPE is not present then ITYPE = 1 is assumed.
!!
!! 2. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the transformed matrix, stored in the
!!            same format as A.
!
!! B       (input) either REAL or COMPLEX square array,
!!         shape (:,:), size(B,1) == size(A,1).
!!         The triangular factor from the Cholesky factorization of B,
!!         as returned by LA_POTRF.
!
!! ITYPE   Optional, (input) INTEGER
!!         If ITYPE is present then:
!!            = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
!!            = 2 or 3: compute U*A*U**H or L**H*A*L.
!!         otherwise ITYPE = 1 is assumed.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored and B is factored as
!!                    U**H*U;
!!            = "L":  Lower triangle of A is stored and B is factored as
!!                    L*L**H.
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYGST"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LITYPE
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N )THEN; LINFO = -2
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. CALL LAPACK77 ROUTINE
      CALL SYGST_F77( LITYPE, LUPLO, N, A, LD, B, LD, LINFO )
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO)
END SUBROUTINE DSYGST_F95
SUBROUTINE DSYGV_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYGV_F77 => LA_SYGV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYGV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, LD, LITYPE, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(ITYPE) )THEN
      LITYPE = ITYPE
   ELSE
      LITYPE = 1
   END IF
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
      LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
      LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -6
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      ENDIF
      LWORK = N*(2+NB)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = N*3-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( LINFO == 0 .OR. LINFO <= -200 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYGV_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
                        WORK, LWORK, LINFO )
      END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE DSYGV_F95
SUBROUTINE DSYGVD_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: SYGVD_F77 => LA_SYGVD                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
      INTEGER, INTENT(IN), OPTIONAL :: ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYGV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, LD, LITYPE, LWORK, ISTAT, ISTAT1, LIWORK
!!  .. LOCAL ARRAYS ..
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
      IF( PRESENT(ITYPE) )THEN
        LITYPE = ITYPE
      ELSE
        LITYPE = 1
      END IF
      IF( PRESENT(JOBZ) ) THEN
        LJOBZ = JOBZ
      ELSE
        LJOBZ = "N"
      END IF
      IF( PRESENT(UPLO) ) THEN
        LUPLO = UPLO
      ELSE
        LUPLO = "U"
      END IF
!!  .. TEST THE ARGUMENTS ..
      IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
        LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
        LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN
        LINFO = -3
      ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
        LINFO = -4
      ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
        LINFO = -5
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
        LINFO = -6
      ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE ..
!!  .. QUERING THE SIZE OF WORKSPACE ..
        LIWORK = -1
        LWORK = -1

        CALL SYGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )

        LWORK = WORKMIN(1)
        LIWORK = IWORKMIN(1)

        ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
        IF (ISTAT == 0) THEN
!!        .. CALL LAPACK77 ROUTINE ..
          CALL SYGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORK, LWORK, IWORK, LIWORK, LINFO )
        ELSE
          LINFO = -100
        END IF
        DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
      ENDIF
      CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE DSYGVD_F95
SUBROUTINE DSYGVX_F95( A, B, W, ITYPE, JOBZ, UPLO, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SYGVX_F77 => LA_SYGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYGVX and LA_HEGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!      A*z = lambda*B*z, A*B*z = lambda*z,  and  B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SYGVX and complex
!! Hermitian in the case of LA_HEGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SYGVX / LA_HEGVX (A, B, W, ITYPE= itype, &
!!             JOBZ= jobz, UPLO= uplo, VL= vl, VU= vu, IL= il, &
!!             IU= iu, M= m, IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the
!!        upper triangular part of matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of
!!        matrix A.
!!        On exit, if JOBZ = "V", the first M columns of A contain the
!!        orthonormal eigenvectors corresponding to the selected
!!        eigenvalues, with the i-th column of A holding the eigenvector
!!        associated with the eigenvalue in W(i).
!!        The eigenvectors are normalized as follows:
!!          if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!          if ITYPE = 3: Z^H * B^-1 * Z = I .
!!        If an eigenvector fails to converge, then that column of A
!!        contains the latest approximation to the eigenvector and the
!!        index of the eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! B      (input/output) REAL or COMPLEX square array, shape (:,:) with
!!        size(B,1) = size(A,1).
!!        On entry, the matrix B.
!!        If UPLO = "U", the upper triangular part of B contains the
!!        upper triangular part of matrix B. If UPLO = "L", the lower
!!        triangular part of B contains the lower triangular part of
!!        matrix B.
!!        On exit, the part of B containing the matrix is overwritten by
!!        the triangular factor U or L of the Cholesky factorization
!!              B = U^H*U or B = L*L^H.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! ITYPE  Optional (input) INTEGER.
!!        Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!        Default value: 1.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!           = "N": Computes eigenvalues only;
!!           = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: IFAIL should be present if JOBZ = "V".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!             ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal form.
!!        Eigenvalues will be computed most accurately when ABSTOL is set
!!        to twice the underflow threshold 2 * LA_LAMCH(1.0_<wp>, "S"),
!!        not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: the algorithm failed to converge or matrix B is not
!!        positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i, then i
!!             eigenvectors failed to converge. Their indices are stored
!!             in array IFAIL.
!!           > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!             of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!         n is the order of A.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYGVX"
      CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDA, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
      &     SIFAIL, LDB, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:), Z(:,:)
      REAL(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   IF (PRESENT(M)) M = 0
   N = SIZE(A,1); LDA = MAX(1,N); LDB=MAX(1,SIZE(B,1)); LINFO = 0; ISTAT = 0
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL);ELSE; SIFAIL = N; END IF
   IF (PRESENT (JOBZ)) THEN; LJOBZ=JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN;  LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN ; LRANGE = "V"; LM=N
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN ; LRANGE = "I"; LM=LIU-LIL+1
   ELSE ; LRANGE = "A"; LM=N; END IF
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF (SIZE (B, 2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN;  LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"V") .AND. .NOT.LSAME(LJOBZ,"N") )THEN; LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN ; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE, "I") .AND. ( LIU < MIN( N, LIL ) .OR. LIU>N))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
     IF(LSAME(LJOBZ, "V")) THEN
         LDZ = MAX(1,N); LZ=LM
     ELSE
         LDZ = 1; LZ=1
     ENDIF
       IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
       ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT )
         IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 200; ENDIF
         END IF
!!     .. DETERMINE THE WORKSPACE
         ALLOCATE(IWORK(5*N), STAT=ISTAT)
         IF (ISTAT /= 0) THEN; LINFO = -100
           GOTO 300
         ENDIF
         ALLOCATE(Z(LDZ, LZ), STAT=ISTAT)
         IF (ISTAT /= 0) THEN; LINFO = -100
            GOTO 400
         ENDIF

         LWORK = -1
             CALL SYGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
&                  LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORKMIN, &
&                  LWORK, IWORK, LIFAIL, LINFO )
!! NEXT LINE SHOULD BE LWORK = WORKMIN(1)
           LWORK = 2*WORKMIN(1)

           ALLOCATE (WORK(LWORK), STAT = ISTAT)
           IF( ISTAT /= 0 )THEN; LINFO = -100
             GOTO 500
           ENDIF
             IF( LINFO == 0 )THEN
               IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
               ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
!!     .. CALL LAPACK77 ROUTINE
                 CALL SYGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
&                  LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                   LWORK, IWORK, LIFAIL, LINFO )

                 IF( PRESENT(M) ) M = LM
                 IF (LSAME(LJOBZ,"V"))  A(1:LDZ, 1:LM)=Z(1:LDZ, 1:LM)
              END IF
         DEALLOCATE (WORK, STAT = ISTAT1(1))
500      DEALLOCATE(Z)
400      DEALLOCATE (IWORK, STAT = ISTAT)
300      IF (.NOT.PRESENT(IFAIL)) DEALLOCATE(LIFAIL, STAT=ISTAT1(1)); END IF
200       CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYGVX_F95
 SUBROUTINE DSYSV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DSYSV1_F95
 SUBROUTINE DSYSV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE DSYSV_F95
SUBROUTINE DSYSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,3*N,N*NB)
         ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, IWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DSYSVX1_F95
SUBROUTINE DSYSVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,3*N,N*NB)
         ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, IWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE DSYSVX_F95
SUBROUTINE DSYTRD_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYTRD_F77 => LA_SYTRD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: TAU(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYTRD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYTRD / LA_HETRD reduces a real symmetric or complex Hermitian
!! matrix A to real symmetric tridiagonal form T by an orthogonal
!! or unitary similarity transformation:
!! Q**H * A * Q = T.
!
!! =======
!
!!    SUBROUTINE LA_HETRD / LA_SYTRD|( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       <type>(<wp>), INTENT(OUT) :: TAU(:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A.
!!         On exit:
!!            If UPLO = "U", the diagonal and first superdiagonal
!!               of A are overwritten by the corresponding elements of the
!!               tridiagonal matrix T, and the elements above the first
!!               superdiagonal, with the array TAU, represent the unitary
!!               matrix Q as a product of elementary reflectors.
!!            If UPLO = "L", the diagonal and first subdiagonal of A are
!!               overwritten by the corresponding elements of the tridiagonal
!!               matrix T, and the elements below the first subdiagonal, with
!!               the array TAU, represent the unitary matrix Q as a product
!!               of elementary reflectors.
!!            See Further Details.
!
!! TAU     (output) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         The scalar factors of the elementary reflectors.
!!         See Further Details.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! Further Details
!! ===============
!
!! If UPLO = "U", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(n-1) . . . H(2) H(1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!! A(1:i-1,i+1), and tau in TAU(i).
!
!! If UPLO = "L", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(1) H(2) . . . H(n-1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!! and tau in TAU(i).
!
!! The contents of A on exit are illustrated by the following examples
!! with n = 5:
!
!! if UPLO = "U":                       if UPLO = "L":
!
!!   (  d   e   v2  v3  v4 )              (  d                  )
!!   (      d   e   v3  v4 )              (  e   d              )
!!   (          d   e   v4 )              (  v1  e   d          )
!!   (              d   e  )              (  v1  v2  e   d      )
!!   (                  d  )              (  v1  v2  v3  e   d  )
!
!! where d and e denote diagonal and off-diagonal elements of T, and vi
!! denotes an element of the vector defining H(i).
!
!! --------------------------------------
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: D(:), E(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB > 1 .AND. NB < N )THEN; LWORK = N*NB; ELSE; LWORK = 1; ENDIF
      ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(D, E, WORK, STAT=ISTAT1)
         LWORK = 1; ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYTRD_F77( LUPLO, N, A, LD, D, E, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(D, E, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE DSYTRD_F95
      SUBROUTINE ERINFO(LINFO, SRNAME, INFO, ISTAT)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. IMPLICIT STATEMENT ..
         IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
         CHARACTER( LEN = * ), INTENT(IN)              :: SRNAME
         INTEGER             , INTENT(IN)              :: LINFO
         INTEGER             , INTENT(OUT), OPTIONAL   :: INFO
         INTEGER             , INTENT(IN), OPTIONAL    :: ISTAT
!!  .. EXECUTABLE STATEMENTS ..
!!         IF( ( LINFO < 0 .AND. LINFO > -200 ) .OR.                     &
!!    &       ( LINFO > 0 .AND. .NOT.PRESENT(INFO) ) )THEN
      IF( ( ( LINFO < 0 .AND. LINFO > -200 ) .OR. LINFO > 0 )           &
     &           .AND. .NOT.PRESENT(INFO) )THEN
        WRITE (*,*) "Program terminated in LAPACK95 subroutine ",SRNAME
        WRITE (*,*) "Error indicator, INFO = ",LINFO
        IF( PRESENT(ISTAT) )THEN
          IF( ISTAT /= 0 ) THEN
            IF( LINFO == -100 )THEN
              WRITE (*,*) "The statement ALLOCATE caUSEs STATUS = ",    &
     &                    ISTAT
            ELSE
              WRITE (*,*) "LINFO = ", LINFO, " not expected"
            END IF
          END IF
        END IF
        STOP
         ELSE IF( LINFO <= -200 ) THEN
           WRITE(*,*) "++++++++++++++++++++++++++++++++++++++++++++++++"
           WRITE(*,*) "*** WARNING, INFO = ", LINFO, " WARNING ***"
           IF( LINFO == -200 )THEN
             WRITE(*,*)                                                 &
     &        "Could not allocate sufficient workspace for the optimum"
             WRITE(*,*)                                                 &
     &        "blocksize, hence the routine may not have performed as"
             WRITE(*,*) "efficiently as possible"
         ELSE
           WRITE(*,*) "Unexpected warning"
         END IF
           WRITE(*,*) "++++++++++++++++++++++++++++++++++++++++++++++++"
        END IF
        IF( PRESENT(INFO) ) THEN
          INFO = LINFO
        END IF
      END SUBROUTINE ERINFO
 SUBROUTINE SGBSV1_F95( A, B, K, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: K
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, LK, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LK -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LK -1
          CALL GBSV_F77( N, LK, KU, 1, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGBSV1_F95
 SUBROUTINE SGBSV_F95( A, B, KL, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: KL
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GBSV computes the solution to a real or complex linear system
!! of equations A*X = B, where A is a square band matrix and X and B are
!! rectangular matrices or vectors. The LU decomposition with row
!! interchanges is used to factor A as A = L*U , where L is a product of
!! permutation and unit lower triangular matrices with kl subdiagonals,
!! and U is upper triangular with kl + ku superdiagonals. The factored
!! form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSV( AB, B, KL=kl, IPIV=ipiv, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             INTEGER, INTENT(IN), OPTIONAL :: KL
!!             INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!         with size(AB,1) = 2*kl+ku+1 and size(AB,2) = n, where kl and ku
!!         are, respectively, the numbers of subdiagonals and
!!         superdiagonals in the band of A, and n is the order of A.
!!         On entry, the matrix A in band storage. The (kl + ku + 1)
!!         diagonals of A are stored in rows (kl + 1) to (2*kl + ku + 1)
!!         of AB, so that the j-th column of A is stored in the j-th
!!         column of AB as follows:
!!         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                        1<=j<=n
!!         The remaining elements in AB need not be set.
!!         On exit, details of the factorization. U is an upper triangular
!!         band matrix with (kl + ku + 1) diagonals. These are stored in
!!         the first (kl + ku + 1) rows of AB. The multipliers that arise
!!         during the factorization are stored in the remaining rows.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! KL      Optional (input) INTEGER.
!!         The number of subdiagonals in the band of A (KL = kl).
!!         The number of superdiagonals in the band is given by
!!         ku = size(AB,1) - 2 * kl - 1.
!!         Default value: (size(AB,1)-1)/3.
!! IPIV    Optional (output) INTEGER array, shape (:) with size(IPIV) = n.
!!         The pivot indices that define the row interchanges; row i of the
!!         matrix was interchanged with row IPIV(i).
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, U(i,i) = 0. The factorization has been
!!         completed, but the factor U is singular, so the solution could
!!         not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, NRHS, LKL, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LKL -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LKL -1 < 0 .OR. LKL < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LKL -1
          CALL GBSV_F77( N, LKL, KU, NRHS, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGBSV_F95
SUBROUTINE SGBSVX1_F95(A, B, X, KL, AF, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, &
              SC, SR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LC(:), LR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = 2*LKL+LKU+1; S2AF = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA - LKL -LKU -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AF /= 2*LKL+LKU+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, 1, A, LDA, LAF, S1AF, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGBSVX1_F95
SUBROUTINE SGBSVX_F95(A, B, X, KL, AFB, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFB(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GBSVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square band matrix and X and B are rectangular matrices or vectors.
!!    LA_GBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSVX( AB, B, X, KL=kl, AFB=afb, IPIV=ipiv, &
!!                  FACT=fact, TRANS=trans, EQUED=equed, R=r, C=c, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, &
!!                  RPVGRW=rpvgrw, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          INTEGER, INTENT(IN), OPTIONAL :: KL
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: C(:), R(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB        (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!           with size(AB,1) = kl + ku + 1 and size(AB,2) = n, where kl
!!           and ku are, respectively, the numbers of subdiagonals and
!!           superdiagonals in the band of A, and n is the order of A.
!!           On entry, the matrix A or its equilibration in band storage.
!!           The (kl + ku + 1) diagonals of A are stored in rows 1 to
!!           (kl + ku + 1) of AB, so that the j-th column of A is
!!           stored in the j-th column of AB as follows:
!!           AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                     1<=j<=n.
!!           The remaining elements in AB need not be set.
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during the previous call
!!           to LA GBSVX.
!!           On exit, if FACT = "E", the equilibrated version of A is
!!           stored in AB; otherwise, AB is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = n or shape (:) with size(B) = n.
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!           and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!           The solution matrix X .
!! KL        Optional (input) INTEGER.
!!           The number of subdiagonals in the band of A (KL = kl).
!!           The number of superdiagonals in the band is given by
!!           ku =  size(AB,1) - kl - 1.
!!           Default value: (size(AB,1) - 1) / 2.
!! AFB       Optional (input or output) REAL or COMPLEX rectangular array,
!!           shape (:,:) with size(AFB,1) = 2*kl+ku+1 and size(AFB,2)=n
!!           If FACT = "F" then AFB is an input argument that contains the
!!           details of the factorization of (the equilibrated) A returned
!!           by a previous call to LA_GBSVX.
!!           If FACT /= "F" then AFB is an output argument that contains
!!           the details of the factorization of (the equilibrated) A. U is
!!           an upper triangular band matrix with (kl + ku + 1) diagonals.
!!           These are stored in the first (kl + ku + 1) rows of AFB. The
!!           multipliers that arise during the factorization are stored in
!!           the remaining rows.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = n.
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A, returned by a previous call to LA_GBSVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!             = "N": The matrix A will be copied to AFB and factored (no
!!                  equilibration).
!!             = "E": The matrix A will be equilibrated, then copied to
!!                  AFB and factored.
!!             = "F": AFB and IPIV contain the factored form of (the
!!                  equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!             = "N": A*X = B (No transpose)
!!             = "T": A^T*X = B (Transpose)
!!             = "C": A^H*X = B (Conjugate transpose)
!!           Default value: "N".
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!             = "N": No equilibration (always true if FACT = "N").
!!             = "R": Row equilibration, i.e., A has been premultiplied
!!                  by diag(R).
!!             = "C": Column equilibration, i.e., A has been postmultiplied
!!                  by diag(C).
!!             = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with
!!           size(R) = size(A,1).
!!           The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with
!!           size(C) = size(A,1).
!!           The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j), FERR(j) is an
!!           estimated upper bound for the magnitude of the largest element
!!           in (X(j)-XTRUE) divided by the magnitude of the largest
!!           element in X(j). The estimate is as reliable as the estimate
!!           for RCOND and is almost always a slight overestimate of the
!!           true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any element
!!           of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition is
!!           indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!             <= n: U(i,i) = 0. The factorization has been completed,
!!                 but the factor U is singular, so the solution could
!!                 not be computed.
!!             = n+1: U is nonsingular, but RCOND is less than machine
!!                 precision, so the matrix is singular to working
!!                 precision. Nevertheless, the solution and error
!!                 bounds are computed because the computed solution can
!!                 be more accurate than the value of RCOND would suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, S1AFB, S2AFB, &
              SC, SR, SFERR, SBERR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAFB(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); NRHS = SIZE(B, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFB) )THEN; S1AFB = SIZE(AFB,1); S2AFB = SIZE(AFB,2)
   ELSE; S1AFB = 2*LKL+LKU+1; S2AFB = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AFB /= 2*LKL+LKU+1 .OR. S2AFB /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -12
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -13
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFB) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFB) ) THEN; ALLOCATE( LAFB(S1AFB,N), STAT=ISTAT )
      ELSE; LAFB => AFB; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, NRHS, A, LDA, LAFB, S1AFB, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AFB) ) DEALLOCATE( LAFB, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGBSVX_F95
      SUBROUTINE SGBTRF_F95( A, K, M, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GBTRF_F77 => LA_GBTRF, LANGB_F77 => LA_LANGB, & !!((07-B-INT_LAPACK1.f90))
                                          GBCON_F77 => LA_GBCON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(IN), OPTIONAL :: K, M
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      REAL(WP), INTENT( INOUT ) :: A( :, : )
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBTRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV, &
                 LK, KU, LM
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:), IWORK(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      LD = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0
      IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LD-1)/3; ENDIF
      IF( PRESENT(M) ) THEN; LM = M; ELSE; LM = N; ENDIF; MINMN = MIN(LM,N)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( N < 0 .OR. LD < 0 )THEN; LINFO = -1
      ELSE IF( LD - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -2
      ELSE IF( LM < 0 )THEN; LINFO = -3
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -4
      ELSE IF( PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -5
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -6
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( WORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGB_F77( LNORM, MINMN, LK, KU, A, LD, WORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(WORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GBTRF_F77( LM, N, LK, KU, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(3*MINMN), IWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GBCON_F77( LNORM, MINMN, LK, KU, A, LD, LIPIV, &
                                     LANORM, RCOND, WORK, IWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE SGBTRF_F95
SUBROUTINE SGEEQU_F95( A, R, C, ROWCND, COLCND, AMAX, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEQU_F77 => LA_GEEQU                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT( OUT ), OPTIONAL :: AMAX, COLCND, ROWCND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT( IN ) :: A( :, : )
   REAL(WP), INTENT( OUT ) :: C( : ), R( : )
!---------------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GEEQU computes row and column scalings intended to equilibrate a
!! rectangle matrix A and reduce its condition number.  R returns the
!! row scale factors and C the column scale factors, chosen to try to
!! make the largest entry in each row and column of the matrix B with
!! elements B(i,j) = R(i) A(i,j) C(j) have absolute value 1.
!
!! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
!! number and BIGNUM = largest safe number. Use of these scaling
!! factors is not guaranteed to reduce the condition number of A but
!! works well in practice.
!
!! Arguments
!! =========
!
!! SUBROUTINE LA_GEEQU ( A, R, C, ROWCND, COLCND, AMAX, INFO )
!!    <type>(<wp>), INTENT(IN) :: A(:,:)
!!    REAL(<wp>), INTENT( OUT ) :: R(:), C(:)
!!    REAL(<wp>), INTENT( OUT ), OPTIONAL :: ROWCND, COLCND, AMAX
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! ====================
!
!! A       (input) either REAL or COMPLEX array, shape (:,:).
!!         The matrix A, whose equilibration factors are to be computed.
!
!! R       (output) REAL array, shape (:), size(R) == size(A,1).
!!         If INFO = 0 or INFO > size(A,1), R contains the row
!!         scale factors for A.
!
!! C       (output) REAL array, shape (:), size(C) == size(A,2).
!!         If INFO = 0, C contains the column scale factors for A.
!
!! ROWCND  Optional (output) REAL.
!!         If INFO = 0 or INFO > size(A,1), ROWCND contains the ratio
!!         of the smallest R(i) to the largest R(i).  If ROWCND >= 0.1
!!         and AMAX is neither too large nor too small, it is not worth
!!         scaling by R.
!
!! COLCND  Optional (output) REAL.
!!         If INFO = 0, COLCND contains the ratio of the smallest
!!         C(i) to the largest C(i).  If COLCND >= 0.1, it is not
!!         worth scaling by C.
!
!! AMAX    Optional (output) REAL.
!!         Absolute value of largest matrix element.  If AMAX is very
!!         close to overflow or very close to underflow, the matrix
!!         should be scaled.
!
!! INFO    Optional (output) INTEGER
!!         If INFO is present
!!            = 0:  successful exit
!!            < 0:  if INFO = -k, the k-th argument had an illegal value
!!            > 0:  if INFO = k,  and k is
!!                  <= M:  the k-th row of A is exactly zero
!!                  >  M:  the (k-M)-th column of A is exactly zero
!!                         where M = size(A,1)
!!         If INFO is not present and an error occurs, then the program is
!!            terminated with an error message.
!
!-------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEQU"
!!  .. LOCAL SCALARS ..
   INTEGER :: LINFO, M, N
   REAL(WP) :: LAMAX, LCOLCND, LROWCND
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; M = SIZE(A, 1); N = SIZE(A, 2)
!!  .. TEST THE ARGUMENTS
   IF ( SIZE(R) /= M ) THEN; LINFO = -2
   ELSE IF ( SIZE(C) /= N ) THEN; LINFO = -3
   ELSE
!!     .. CALL LAPACK77 ROUTINE
      CALL GEEQU_F77( M, N, A, MAX(1,M), R, C, LROWCND, LCOLCND, LAMAX, LINFO )
      IF( PRESENT( ROWCND ) ) ROWCND = LROWCND
      IF( PRESENT( COLCND ) ) COLCND = LCOLCND
      IF( PRESENT( AMAX ) ) AMAX = LAMAX
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE SGEEQU_F95
    SUBROUTINE SGEES_F95( A, WR, WI, VS, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEES_F77 => LA_GEES                                !!((07-B-INT_LAPACK1.f90))
!!  use LA_EXTERNAL, ONLY: SELECT
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
   INTERFACE
      LOGICAL FUNCTION SELECT(WR, WI)
         use KND_LA_PRECISION, ONLY: WP => SP                                !!((05-B-KND_LA_PRECISION.f90))
         REAL(WP), INTENT(IN) :: WR, WI
      END FUNCTION SELECT
   END INTERFACE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GEES computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! Schur factorization
!!                        A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left. The leading
!! columns of Z then form an orthonormal basis for the invariant subspace
!! corresponding to the selected eigenvalues.
!!      A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks are
!! standardized in the form
!!                       [ a  b ]
!!                       [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!! A complex matrix is in complex-Schur form if it is upper triangular.
!!
!! =========
!!
!!        SUBROUTINE LA_GEES( A, <w>, VS=vs, SELECT=select, &
!!                                   SDIM=sdim, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           <type>(<wp>), INTENT(OUT) :: <w(:)>
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!           INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!           END INTERFACE
!!           OPTIONAL :: SELECT
!!           INTEGER, INTENT(OUT), OPTIONAL :: SDIM, INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <w>    ::= WR, WI | W
!!           <w(:)> ::= WR(:), WI(:) | W(:)
!!           <w(j)> ::= WR(j) , WI(j) |  W(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the Schur form T.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues in the order in which they appear on
!!          the diagonal of the Schur form T.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VS       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VS,1) = size(A,1).
!!          The matrix Z of Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION.
!!          LOGICAL FUNCTION SELECT( <w(j)> )
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!          where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j) , WI(j) | W(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!             interface in the calling (sub)program.
!!          2. SELECT is called by LA_GEES for every computed eigenvalue
!!           w(j) (but only once for a complex conjugate pair when A is
!!           real). It is used to select the eigenvalues that will be
!!             ordered to the top left of the Schur form. The eigenvalue
!!           w(j) is selected if SELECT(w(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!           SELECT(w(j)) = .TRUE. after ordering, since ordering may
!!           change the value of complex eigenvalues (especially if the
!!           eigenvalue is ill-conditioned). In this case INFO is set to
!!           size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which
!!          SELECT=.TRUE. (If A is real, complex conjugate pairs for which
!!          SELECT=.TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of w contain
!!                    those eigenvalues which have converged. VS contains
!!                    the matrix which reduces A to its partially converged
!!                    Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                  problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                  in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!-------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEES"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
!!  .. LOCAL ARRAYS ..
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   REAL(WP), TARGET :: LLVS(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LSDIM = 0
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(SDIM) .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      IF( ISTAT == 0 ) THEN
         LWORK = MAX( 1, 3*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 3*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VS) )THEN
          IF( PRESENT(SDIM) )THEN
             ALLOCATE(BWORK(N),STAT=ISTAT)
             CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        VS, S1VS, WORK, LWORK, BWORK, LINFO )
            ELSE
             CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        VS, S1VS, WORK, LWORK, LLBWORK, LINFO )
            ENDIF
          ELSE
           IF( PRESENT(SDIM) )THEN
              ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        LLVS, S1VS, WORK, LWORK, BWORK, LINFO )
           ELSE
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, WR, WI, &
                        LLVS, S1VS, WORK, LWORK, LLBWORK, LINFO )
          ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
!!      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   IF( PRESENT(SDIM) ) SDIM = LSDIM
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGEES_F95
 SUBROUTINE SGEESX_F95( A, WR, WI, VS, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEESX_F77 => LA_GEESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
   REAL(WP), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
      INTERFACE
         FUNCTION SELECT(WR, WI)
           use KND_LA_PRECISION, ONLY: WP => SP                              !!((05-B-KND_LA_PRECISION.f90))
           REAL(WP), INTENT(IN) :: WR, WI
            LOGICAL :: SELECT
         END FUNCTION SELECT
      END INTERFACE
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GEESX computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! factorization
!!                     A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left, computes a
!! reciprocal condition number for the average of the selected eigenvalues
!! and computes a reciprocal condition number for the right invariant
!! subspace corresponding to the selected eigenvalues. The leading columns
!! of Z form an orthonormal basis for this invariant subspace.
!! A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks
!! are standardized in the form
!!                        [ a  b ]
!!                        [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!!
!! =========
!!
!!       SUBROUTINE LA_GEESX( A, <w>, VS=vs, SELECT=select, SDIM=sdim, &
!!                              RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!            INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!            END INTERFACE
!!            OPTIONAL :: SELECT
!!            INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the Schur form T .
!! <w>     (output) REAL or COMPLEX array, shape (:) with size(w) =
!!         size(A,1).
!!         The computed eigenvalues in the order in which they appear on
!!         the diagonal of the Schur form T.
!!         <w(:)> ::= WR(:), WI(:) | W(:),
!!         where
!!         WR(:), WI(:) are of REAL type (for the real and imaginary
!!         parts) and W(:) is of COMPLEX type.
!!         Note: If A is real, then a complex-conjugate pair appear
!!         consecutively, with the eigenvalue having the positive
!!         imaginary part appearing first.
!! VS      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VS,1) = size(A,1).
!!         The matrix Z of Schur vectors.
!! SELECT  Optional (input) LOGICAL FUNCTION
!!         LOGICAL FUNCTION SELECT( <w(j)>)
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp> ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!         1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!         2. SELECT is called by LA_GEES for every computed eigenvalue
!!          <w(j)> (but only once for a complex conjugate pair when A
!!          is real). It is used to select the eigenvalues that will be
!!          ordered to the top left of the Schur form. The eigenvalue
!!          <w(j)> is selected if SELECT(<w(j)>) has the value .TRUE.
!!         3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<w(j)>) = .TRUE. after ordering, since ordering may
!!          change the value of complex eigenvalues (especially if the
!!          eigenvalue is ill-conditioned). In this case INFO is set to
!!          size(A,1) + 2 (see INFO below).
!!         Note: Select must be present if SDIM, RCONDE and RCONDF are
!!         desired.
!! SDIM    Optional (output) INTEGER.
!!         The number of eigenvalues (after sorting) for which
!!         SELECT = .TRUE. (If A is real, complex conjugate pairs for which
!!         SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE  Optional (output) REAL.
!!         The reciprocal condition number for the average of the selected
!!         eigenvalues.
!! RCONDV  Optional (output) REAL.
!!         The reciprocal condition number for the selected right
!!         invariant subspace.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of <w>
!!                    contain those eigenvalues which have converged.
!!                    VS contains the matrix which reduces A to its
!!                    partially converged Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                    problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                    in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0, LIWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
   REAL(WP) :: LRCONDE, LRCONDV
!!  .. LOCAL ARRAYS ..
   INTEGER, TARGET :: LLIWORK(1)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   REAL(WP), TARGET :: LLVS(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -4
   ELSE IF( LSAME(LSORT,"S") .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      IF( LSAME(LSORT,"S") )THEN; ALLOCATE(BWORK(N),STAT=ISTAT)
      ELSE; BWORK => LLBWORK; END IF
      IF( ISTAT == 0 )THEN
         IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN
            IWORK => LLIWORK; LIWORK = 1
          ELSE; LIWORK = MAX( 1, N*N/4, LIWORK )
            ALLOCATE( IWORK(LIWORK), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( LSAME(LSENSE,"N") ) THEN; LWORK = MAX( 1, 3*N, LWORK)
         ELSE; LWORK = MAX(1, 3*N, N+N*N/2, LWORK); ENDIF

!! NEXT LINE SHOULD BE REMOVED BUT CURRENTLY THERE IS BUG IN
!! DGEESX/DGEHRD SO WE NEED BIGGER BUFFER
         LWORK = MAX(1, 3*N, N+N*N/2)
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            IF( LSAME(LSENSE,"N") ) THEN; LWORK = MAX( 1, 3*N)
            ELSE; LWORK = MAX(1, 3*N, N+N*N/2); ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
       IF (PRESENT (VS)) THEN
         CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, WR, WI, &
     &                   VS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &                   IWORK, LIWORK,  BWORK, LINFO )
       ELSE
           CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, WR, WI, &
     &                   LLVS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &                   IWORK, LIWORK,  BWORK, LINFO )
       ENDIF
      IF( LINFO == 0 )THEN; LWORK = INT(WORK(1)+1); LIWORK = LSDIM*(N-LSDIM); ENDIF
      ELSE; LINFO = -100; ENDIF
      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( PRESENT(RCONDE) ) RCONDE = LRCONDE
      IF( PRESENT(RCONDV) ) RCONDV = LRCONDV
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      IF( LSAME(LSENSE,"V").OR.LSAME(LSENSE,"B") ) DEALLOCATE(IWORK,STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGEESX_F95
SUBROUTINE SGEEV_F95( A, WR, WI, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEV_F77 => LA_GEEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEV computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors. A
!! right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j).
!!
!! =========
!!
!!       SUBROUTINE LA_GEEV( A, <w>, VL=vl, VR=vr, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors were computed. Elements
!!          i+1 : n of <w> contain eigenvalues which have converged.
!!          n is the order of A
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      NN = 3; IF( LSAME(LJOBVL,"V").OR.LSAME(LJOBVR,"V") ) NN = NN + 1
      LWORK = MAX( 1, NN*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, NN*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VL) )THEN
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
              CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, WR, WI, &
                        LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGEEV_F95
SUBROUTINE SGEEVX_F95( A, WR, WI, VL, VR, BALANC, ILO, IHI, &
                       SCALE, ABNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEVX_F77 => LA_GEEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, ILO, IHI
   REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: WR(:), WI(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: SCALE(:), RCONDE(:), RCONDV(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEVX computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors.
!! Optionally, it also balances A and computes reciprocal condition
!! numbers for the  eigenvalues and right eigenvectors.
!! A right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j). The computed
!! eigenvectors are normalized to have Euclidean norm equal to 1 and
!! largest component real.
!!        Balancing A involves permuting its rows and columns to make
!! it more nearly upper triangular and then scaling rows and columns by
!! a diagonal similarity transformation to reduce the condition numbers
!! of the eigenvalues and eigenvectors.
!!        Computed reciprocal condition numbers pertain to the matrix
!! after balancing. Permuting does not change condition numbers (in
!! exact arithmetic), but scaling does.
!
!! =========
!!
!!    SUBROUTINE LA_GEEVX( A, <w>, VL=vl, VR=vr, BALANC=balanc, ILO=ilo, &
!!                     IHI=ihi, SCALE=scale, ABNRM=abnrm, RCONDE=rconde, &
!!                     RCONDV=rcondv, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <w(:)>
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!         INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: SCALE(:), ABNRM, &
!!               RCONDE(:), RCONDV(:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!         <w>    ::= WR, WI | W
!!         <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC   Optional (input) CHARACTER(LEN=1).
!!          Indicates whether the input matrix should be permuted and/or
!!          diagonally scaled.
!!             = "N": Do not permute or scale;
!!             = "P": Permute but do not scale;
!!             = "S": Scale but do not permute;
!!             = "B": Both permute and scale.
!!           Default value: "N".
!! ILO,IHI  Optional (output) INTEGER.
!!          ILO and IHI are determined when A is balanced. The balanced
!!          A(i,j) = 0 if i > j and j = 1, ..., ILO-1 or
!!          i = IHI+1, ... , size(A,1).
!! SCALE    Optional (output) REAL array, shape (:) with size(SCALE) =
!!          size(A,1).
!!          Details of the permutations and scaling factors applied when
!!          balancing A. If P(j) is the index of the row and column
!!          interchanged with row and column j, and D(j) is the
!!          scaling factor applied to row and column j, then
!!          P(j) = SCALE(j), j = 1, ..., ILO-1 and j =IHI+1, ...,  n
!!          D(j) = SCALE(j), j = ILO, ... , IHI.
!! ABNRM    Optional (output) REAL.
!!          The l1 norm of the balanced matrix (the maximum of the sum
!!          of absolute values of elements of any column).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE) =
!!          size(A,1). RCONDE(j) is the reciprocal condition number of
!!          the j-th eigenvalue.
!! RCONDV   Optional (output) REAL array, shape (:), size(RCONDV) =
!!          size(A,1). RCONDV(j) is the reciprocal condition number of
!!          the j-th right eigenvector.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors or condition numbers were
!!          computed; elements 1:ILO-1 and i+1:n of <w> contain
!!          eigenvalues which have converged.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LBALANC, LJOBVL, LJOBVR, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, NN, &
              LILO, LIHI, SSCALE, SRCONDE, SRCONDV
   REAL(WP) :: LABNRM
!!  .. LOCAL ARRAYS ..
   INTEGER, TARGET :: LLIWORK(1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP) :: WORKMIN(1)
   REAL(WP), POINTER :: LSCALE(:), LRCONDE(:), LRCONDV(:)
   REAL(WP), POINTER :: LLVL(:,:), LLVR(:,:)
   REAL(WP), POINTER :: WORK(:)

!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = N; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = N; LJOBVR = "N"; END IF
   IF( PRESENT(SCALE) )THEN; SSCALE = SIZE(SCALE); ELSE; SSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( WR ) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( WI ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -4
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
                   LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -6
   ELSE IF( SSCALE /= N )THEN; LINFO = -9
   ELSE IF( SRCONDE /= N )THEN; LINFO = -11
   ELSE IF( SRCONDV /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
      IF( PRESENT(SCALE) )THEN; LSCALE => SCALE
      ELSE; ALLOCATE( LSCALE(N), STAT=ISTAT ); ENDIF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
         ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
         ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT ); ENDIF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN; IWORK => LLIWORK
         ELSE; ALLOCATE( IWORK(MAX( 1, 2*N-2 )), STAT=ISTAT ); ENDIF
      END IF

      IF (LSAME (LSENSE,"E") .OR. LSAME(LSENSE,"B") ) THEN
        LJOBVL = "V"; LJOBVR = "V"; S1VR=N; S1VL=N
      ENDIF

      IF (PRESENT (VL)) THEN; LLVL => VL
      ELSE; ALLOCATE (LLVL(N,N), STAT = ISTAT); ENDIF
      IF (PRESENT (VR)) THEN; LLVR => VR
      ELSE; ALLOCATE (LLVR(N,N), STAT = ISTAT); ENDIF

      IF( ISTAT == 0 ) THEN
!! QUERY FOR THE SIZE OF WORK
         LWORK = -1
         IF (PRESENT (VL)) THEN
           IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&              LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, LINFO )
            ENDIF
          ENDIF
         LWORK = WORKMIN(1)

         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
            NN = MAX(1, 3*N, N*(N+6))
            LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF (PRESENT (VL)) THEN
          IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ENDIF
        ELSE
          IF (PRESENT(VR)) THEN
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ELSE
             CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, WR, WI, &
&               LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&               LRCONDE, LRCONDV, WORK, LWORK, IWORK, LINFO )
          ENDIF
        ENDIF
        IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
        ELSE; LINFO = -100; ENDIF
      IF( PRESENT(ILO) ) ILO = LILO; IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( .NOT. PRESENT(SCALE) ) DEALLOCATE( LSCALE, STAT=ISTAT1 )
      IF( .NOT. PRESENT(RCONDE) ) DEALLOCATE( LRCONDE, STAT=ISTAT1 )
      IF( .NOT. PRESENT(RCONDV) ) DEALLOCATE( LRCONDV, STAT=ISTAT1 )
      IF( LSAME(LSENSE,"V").OR.LSAME(LSENSE,"B") ) DEALLOCATE(IWORK,STAT=ISTAT1)
      DEALLOCATE(WORK, STAT=ISTAT1)
      IF (.NOT.PRESENT (VL)) DEALLOCATE(LLVL)
      IF (.NOT.PRESENT (VR)) DEALLOCATE(LLVR)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)

END SUBROUTINE SGEEVX_F95
    SUBROUTINE SGEGS_F95( A, B, ALPHAR, ALPHAI, BETA, VSL, VSR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGS_F77 => LA_GEGS                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGS computes for a pair of n-by-n real nonsymmetric matrices
!!  A, B: the generalized eigenvalues (alphar alpha, beta),
!!  the Schur form (A, B), and optionally left and/or right
!!  Schur vectors (VSL and VSR).
!
!!  (If only the generalized eigenvalues are needed, use the driver SGEGV
!!  instead.)
!
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!
!!  The (generalized) Schur form of a pair of matrices is the result of
!!  multiplying both matrices on the left by one orthogonal matrix and
!!  both on the right by another orthogonal matrix, these two orthogonal
!!  matrices being chosen so as to bring the pair of matrices into
!!  (real) Schur form.
!
!!  A pair of matrices A, B is in generalized real Schur form if B is
!!  upper triangular with non-negative diagonal and A is block upper
!!  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
!!  to real generalized eigenvalues, while 2-by-2 blocks of A will be
!!  "standardized" by making the corresponding elements of B have the
!!  form:
!!          [  a  0  ]
!!          [  0  b  ]
!
!!  and the pair of corresponding 2-by-2 blocks in A and B will
!!  have a complex conjugate pair of generalized eigenvalues.
!
!!  The left and right Schur vectors are the columns of VSL and VSR,
!!  respectively, where VSL and VSR are the orthogonal matrices
!!  which reduce A and B to Schur form:
!
!!  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
!
!! =========
!
!!   SUBROUTINE LA_GEGS( A, B, <alpha>, BETA, VSL, VSR, INFO )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose generalized
!!      eigenvalues and (optionally) Schur vectors are to be
!!      computed.
!!      On exit, the generalized Schur form of A.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      A should be less than the overflow threshold.
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) Schur vectors are
!!      to be computed.
!!      On exit, the generalized Schur form of B.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      B should be less than the overflow threshold.
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
!!      j=1,...,n  and  BETA(j),j=1,...,n  are the diagonals of the
!!      complex Schur form (A,B) that would result if the 2-by-2
!!      diagonal blocks of the real Schur form of (A,B) were further
!!      reduced to triangular form using 2-by-2 complex unitary
!!      transformations.  If ALPHAI(j) is zero, then the j-th
!!      eigenvalue is real; if positive, then the j-th and (j+1)-st
!!      eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
!!      negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VSL  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSL will contain the left Schur vectors. (See "Purpose", above.)
!
!! VSR  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSR will contain the right Schur vectors. (See "Purpose", above.)
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  (A,B) are not in Schur
!!            form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
!!            be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_GGBAK (computing VSL)
!!            =n+8: error return from LA_GGBAK (computing VSR)
!!            =n+9: error return from LA_LASCL (various places)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VSL, S2VSL, S1VSR, S2VSR, &
              SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), POINTER :: WORK(:), &
     &                   LALPHAR(:), LALPHAI(:), LBETA(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHAR) )THEN; SALPHAR = SIZE(ALPHAR); ELSE; SALPHAR = N; ENDIF
   IF( PRESENT(ALPHAI) )THEN; SALPHAI = SIZE(ALPHAI); ELSE; SALPHAI = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHAR) )THEN; LALPHAR => ALPHAR
      ELSE; ALLOCATE(LALPHAR(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(ALPHAI) )THEN; LALPHAI => ALPHAI
         ELSE; ALLOCATE(LALPHAI(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 4*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 4*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VSL, S1VSL, VSR, S1VSR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVSL, S1VSL, VSR, S1VSR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGEGS_F95
    SUBROUTINE SGEGV_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGV_F77 => LA_GEGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGV computes for a pair of N-by-N complex nonsymmetric
!!  matrices A and B, the generalized eigenvalues (alpha, beta),
!!  and optionally, the left and/or right generalized eigenvectors
!!  (VL and VR).
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!!  A right generalized eigenvector corresponding to a generalized
!!  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
!!  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
!!  l such that l**H * (A - w B) = 0, where l**H is the
!!  conjugate-transpose of l.
!!  Note: this routine performs "full balancing" on A and B -- see
!!  "Further Details", below.
!
!! =========
!
!!   SUBROUTINE LA_GEGV( A, B, <alpha>, BETA, VL, VR, INFO )
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of A on exit, see "Further
!!      Details", below.)
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of B on exit, see "Further
!!      Details", below.)
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  If ALPHAI(j) is zero, then
!!      the j-th eigenvalue is real; if positive, then the j-th and
!!      (j+1)-st eigenvalues are a complex conjugate pair, with
!!      ALPHAI(j+1) negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VL   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VL,1) == SIZE(VL,2) == n.
!!      The left generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! VR   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VR,1) == SIZE(VR,2) == n.
!!      The right generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  No eigenvectors have been
!!            calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
!!            should be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_TGEVC
!!            =n+8: error return from LA_GGBAK (computing VL)
!!            =n+9: error return from LA_GGBAK (computing VR)
!!            =n+10: error return from LA_LASCL (various calls)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!! Further Details
!! ===============
!
!! Balancing
!! ---------
!
!! This driver calls SGGBAL to both permute and scale rows and columns
!! of A and B.  The permutations PL and PR are chosen so that PL*A*PR
!! and PL*B*R will be upper triangular except for the diagonal blocks
!! A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
!! possible.  The diagonal scaling matrices DL and DR are chosen so
!! that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
!! one (except for the elements that start out zero.)
!
!! After the eigenvalues and eigenvectors of the balanced matrices
!! have been computed, SGGBAK transforms the eigenvectors back to what
!! they would have been (in perfect arithmetic) if they had not been
!! balanced.
!
!! Contents of A and B on Exit
!! -------- -- - --- - -- ----
!
!! If any eigenvectors are computed (either VL or VR or both), then on
!! exit the arrays A and B will contain the real Schur form[*] of the
!! "balanced" versions of A and B. If no eigenvectors are computed,
!! then only the diagonal blocks will be correct.
!
!! [*] See LA_HGEQZ, LA_GEGS, or read the book "Matrix Computations",
!!     by Golub & van Loan, pub. by Johns Hopkins U. Press.
!--------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, &
              SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   REAL(WP), POINTER :: WORK(:), LALPHAR(:), &
                        LALPHAI(:), LBETA(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHAR) )THEN; SALPHAR = SIZE(ALPHAR); ELSE; SALPHAR = N; ENDIF
   IF( PRESENT(ALPHAI) )THEN; SALPHAI = SIZE(ALPHAI); ELSE; SALPHAI = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHAR) )THEN; LALPHAR => ALPHAR
      ELSE; ALLOCATE(LALPHAR(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(ALPHAI) )THEN; LALPHAI => ALPHAI
         ELSE; ALLOCATE(LALPHAI(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 8*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 8*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VL) )THEN
          IF( PRESENT(VR) )THEN
            CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
             CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
           ENDIF
          ELSE
           IF( PRESENT(VR) )THEN
             CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
           ELSE
              CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHAR, LALPHAI, &
                        LBETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
          ENDIF
         ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGEGV_F95
 SUBROUTINE SGELS1_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "S"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"T") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, 1, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGELS1_F95
 SUBROUTINE SGELS_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GELS computes the minimum-norm least squares solution to one
!! or more real or complex linear systems of the form A*x = b, A^T*x = b
!! or A^H*x = b using a QR or LQ factorization of A. Matrix A is
!! rectangular assumed to be of full rank. The vectors b and correspon-
!! ding solution vectors x are the columns of matrices denoted B and X,
!! respectively.
!!
!! ==========
!!
!!       SUBROUTINE LA_GELS( A, B, TRANS=trans, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX rectangular array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, if size(A,1) >= size(A,2), A is overwritten by
!!          details of its QR factorization. If size(A,1) < size(A,2), A
!!          is overwritten by details of its LQ factorization.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!          size(B) = max(size(A,1); size(A,2)).
!!          On entry, the matrix B.
!!          On exit, the solution matrix X. There are four cases:
!!          1. If TRANS = "N" and size(A,1) >= size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the least squares
!!             solution vector(s); the residual sum of squares for the
!!             solution vector in a column of B is given by the sum of
!!             squares of elements in rows size(A,2)+1 to size(A,1) of
!!             that column.
!!          2. If TRANS = "N" and size(A,1) < size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the minimum norm
!!             solution vector(s).
!!          3. If TRANS = "T" or TRANS = "C", and size(A,1)>=size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             minimum norm solution vector(s).
!!          4. If TRANS = "T" or TRANS = "C", and size(A,1) < size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             least squares solution vector(s); the residual sum of
!!             squares for the solution vector in a column of B is given
!!             by the sum of squares of elements in rows size(A,1)+1 to
!!             size(A,2) of that column.
!! TRANS    Optional (input) CHARACTER(LEN=1).
!!          Specifies the form of the system of equations:
!!          = "N": Ax = b (No transpose)
!!          = "T": A^T*x = b (Transpose)
!!          = "C": A^H*x = b (Conjugate transpose)
!!          Default value: "N".
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!---------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "S"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, NRHS
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"T") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, NRHS, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N,NRHS)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGELS_F95
SUBROUTINE SGELSD1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT,  LWORK, N, M, MN, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      REAL(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    SMLSIZ = ILAENV_F77( 9, "DGELSD", " ", 0, 0, 0, 0 )
    NLVL = INT( LOG( DBLE( MAX(1,MN) ) / DBLE( SMLSIZ+1 ) ) / LOG( TWO ) )
      LIWORK = 3*MAX(M,N)*(3 * NLVL + 11 )
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
      LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N)) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
      IF( PRESENT(S) )THEN; LS => S
      ELSE; ALLOCATE( LS(MN), STAT = ISTAT );
        IF (ISTAT /= 0) THEN
          LINFO = -100
          GOTO 100
        ENDIF
      END IF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
&       LS, LRCOND, LRANK, WORKMIN, LWORK, IWORKMIN,  LINFO )
      LWORK = WORKMIN(1)

      ALLOCATE( WORK(LWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 200
      ENDIF
      ALLOCATE( IWORK(LIWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 250
      ENDIF
      CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, SIZE(B,1), &
&       LS, LRCOND, LRANK, WORK, LWORK, IWORK, LINFO )
      IF( PRESENT(RANK) ) RANK = LRANK

300     DEALLOCATE(IWORK)
250     DEALLOCATE(WORK)
200     IF (.NOT. PRESENT(S)) DEALLOCATE(LS)
ENDIF
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGELSD1_F95
SUBROUTINE SGELSD_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, NRHS, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      REAL(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    SMLSIZ = ILAENV_F77( 9, "DGELSD", " ", 0, 0, 0, 0 )
    NLVL = INT( LOG( DBLE( MAX(1,MN) ) / DBLE( SMLSIZ+1 ) ) / LOG( TWO ) )
      LIWORK = 3*MAX(M,N)*(3 * NLVL + 11 )
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
      LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
      IF( PRESENT(S) )THEN; LS => S
      ELSE; ALLOCATE( LS(MN), STAT = ISTAT );
        IF (ISTAT /= 0) THEN
          LINFO = -100
          GOTO 100
        ENDIF
      END IF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
&       LS, LRCOND, LRANK, WORKMIN, LWORK, IWORKMIN,  LINFO )
      LWORK = WORKMIN(1)

      ALLOCATE( WORK(LWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 200
      ENDIF
      ALLOCATE( IWORK(LIWORK), STAT = ISTAT )
      IF (ISTAT /= 0) THEN
        LINFO = -100
        GOTO 250
      ENDIF
      CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, SIZE(B,1), &
&       LS, LRCOND, LRANK, WORK, LWORK, IWORK, LINFO )
      IF( PRESENT(RANK) ) RANK = LRANK

300     DEALLOCATE(IWORK)
250     DEALLOCATE(WORK)
200     IF (.NOT. PRESENT(S)) DEALLOCATE(LS)
ENDIF
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGELSD_F95
 SUBROUTINE SGELSS1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "S"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:), LS(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = 1; MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 3*MIN(M,N) + MAX( 2*MIN(M,N), MAX(M,N), NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGELSS1_F95
 SUBROUTINE SGELSS_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "S"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:), LS(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 3*MIN(M,N) + MAX( 2*MIN(M,N), MAX(M,N), NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGELSS_F95
 SUBROUTINE SGELSX1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF
       IF( ISTAT == 0 ) THEN
          LWORK = MAX( 1, MIN(M,N) + 3*N, 2*MIN(M,N) + 1 )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSX_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         LJPVT, LRCOND, LRANK, WORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGELSX1_F95
 SUBROUTINE SGELSX_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GELSX computes the minimum-norm solution to a real linear least
!! squares problem:
!!     minimize || A * X - B ||
!! using a complete orthogonal factorization of A.  A is an m-by-n
!! matrix which may be rank-deficient.
!! Several right hand side vectors b and solution vectors x can be
!! handled in a single call; they are stored as the columns of the
!! M-by-NRHS right hand side matrix B and the n-by-nrhs solution
!! matrix X.
!! The routine first computes a QR factorization with column pivoting:
!!     A * P = Q * [ R11 R12 ]
!!                 [  0  R22 ]
!! with R11 defined as the largest leading submatrix whose estimated
!! condition number is less than 1/RCOND.  The order of R11, RANK,
!! is the effective rank of A.
!! Then, R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal transformations from the right, arriving at the
!! complete orthogonal factorization:
!!    A * P = Q * [ T11 0 ] * Z
!!                [  0  0 ]
!! The minimum-norm solution is then
!!    X = P * Z" [ inv(T11)*Q1"*B ]
!!               [        0       ]
!! where Q1 consists of the first RANK columns of Q.
!
!
!! Arguments
!! =========
!
!!  SUBROUTINE LA_GELSX( A, B, RANK, JPVT, RCOND, INFO )
!!    <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!    INTEGER, INTENT(IN), OPTIONAL :: RANK
!!    INTEGER, INTENT(OUT), OPTIONAL :: JPVT(:)
!!    REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A    (input/output) Deither REAL or COMPLEX array, shape (:,:),
!!      SIZE(A,1) == m, SIZE(A,2) == n.
!!      On entry, the m-by-n matrix A.
!!      On exit, A has been overwritten by details of its
!!      complete orthogonal factorization.
!!      INFO = -1 if SIZE(A,1) < 0 or SIZE(A,2) < 0
!
!! B    Optional (input/output) either REAL or COMPLEX array, shape either
!!      (:,:) or (:), size(B,1) or size(B) == size(A,1). SIZE(B,2) == nrhs.
!!      On entry, the m-by-nrhs right hand side matrix B.
!!      On exit, the n-by-nrhs solution matrix X.
!!      If m >= n and RANK = n, the residual sum-of-squares for
!!      the solution in the i-th column is given by the sum of
!!      squares of elements n+1:m in that column.
!!      INFO = -2 if SIZE(B,1) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                    and if shape of B is (:,:) or
!!                if SIZE(B) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                   and if shape of B is (:)
!
!! RANK Optional (output) INTEGER
!!      The effective rank of A, i.e., the order of the submatrix
!!      R11.  This is the same as the order of the submatrix T11
!!      in the complete orthogonal factorization of A.
!
!! JPVT Optional (input/output) INTEGER array, shape (:), SIZE(JPVT) == n
!!      On entry, if JPVT(i) .ne. 0, the i-th column of A is an
!!      initial column, otherwise it is a free column.  Before
!!      the QR factorization of A, all initial columns are
!!      permuted to the leading positions; only the remaining
!!      free columns are moved as a result of column pivoting
!!      during the factorization.
!!      On exit, if JPVT(i) = k, then the i-th column of A*P
!!      was the k-th column of A.
!!      INFO = -4 if SIZE(S) /= SIZE(A,2)
!
!! RCOND Optional (input) REAL
!!      RCOND is used to determine the effective rank of A, which
!!      is defined as the order of the largest leading triangular
!!      submatrix R11 in the QR factorization with pivoting of A,
!!      whose estimated condition number < 1/RCOND.
!
!! INFO    (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!--------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
       LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF
       IF( ISTAT == 0 ) THEN
          LWORK = MAX( 1, MIN(M,N) + 3*N, 2*MIN(M,N) + NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSX_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LJPVT, LRCOND, LRANK, WORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGELSX_F95
      SUBROUTINE SGELSY1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      REAL(WP), POINTER :: WORK(:)
      REAL(WP) :: WORKMIN(1)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
         LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= MAX(1,M,N)) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE SGELSY1_F95
      SUBROUTINE SGELSY_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GELSY computes the minimum-norm least squares solution to one
!! or more real or complex linear systems A*x = b using a complete
!! orthogonal factorization of A. Matrix A is rectangular and may be
!! rankdeficient. The vectors b and corresponding solution vectors x are
!! the columns of matrices denoted B and X, respectively.
!!     The routine computes a QR factorization of A with column pivoting:
!!           A * P = Q * [ R11 R12 ]
!!                       [  0  R22 ]
!! where R11 is the largest leading submatrix whose estimated condition
!! number is less than 1/RCOND. The order of R11, RANK, is the effective
!! rank of A. R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal (unitary) transformations from the right, yielding the
!! complete orthogonal (unitary) factorization
!!           A * P = Q * [ T11  0  ] * Z
!!                     [  0   0  ]
!! The minimum-norm least squares solution is then
!!           x = P * Z^H [ T11^-1 * Q1^H * b ]
!!                     [        0          ]
!! where Q1 consists of the first RANK columns of Q.
!!
!! =========
!!
!!          SUBROUTINE LA_GELSY( A, B, RANK=rank, &
!!                     JPVT= jpvt, RCOND= rcond, INFO= info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!              INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!              INTEGER, INTENT(INOUT), OPTIONAL :: JPVT(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been overwritten by details of its complete
!!         orthogonal factorization.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1),size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, rows 1 to size(A,2) contain the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution vector in a column of B is
!!         given by the sum of squares of elements in rows size(A,2)+1 :
!!         size(A,1) of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the order of the submatrix R11.
!!         This is the same as the order of the submatrix T11 in the
!!         complete orthogonal factorization of A.
!! JPVT    Optional (input/output) INTEGER array, shape (:) with
!!         size(JPVT) = size(A,2).
!!         On entry, if JPVT(i) /= 0, the i-th column of A is an initial
!!         column, otherwise it is a free column.
!!         Before the QR factorization of A, all initial columns are
!!         permuted to the leading positions; only the remaining free
!!         columns are moved as a result of column pivoting during the
!!         factorization.
!!         On exit, if JPVT(i) = k, then the i-th column of the matrix
!!         product A*P was the k-th column of A.
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A. This is
!!         defined as the order of the largest leading triangular
!!         submatrix R11 in the QR factorization of A, with pivoting,
!!         whose estimated condition number < 1/RCOND.
!!         Default value: 10*max(size(A,1),size(A,2))*BEPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      REAL(WP), POINTER :: WORK(:)
      REAL(WP) :: WORKMIN(1)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
          LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE SGELSY_F95
SUBROUTINE SGERFS1_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(IN) :: A(:,:), AF(:,:)
   REAL(WP), INTENT(IN) :: B(:)
   REAL(WP), INTENT(INOUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: N, LINFO, ISTAT, ISTAT1, LD
   REAL(WP) :: LFERR, LBERR
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); ISTAT = 0; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N ) THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, 1, A, LD, AF, LD, IPIV, &
                    B, LD, X, LD, LFERR, LBERR, WORK, IWORK, LINFO )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGERFS1_F95
SUBROUTINE SGERFS_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN), TARGET :: IPIV(:)
   REAL(WP), INTENT(IN) :: A(:,:), AF(:,:), B(:,:)
   REAL(WP), INTENT(INOUT) :: X(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GERFS improves the computed solution X of a system of linear
!! equations   A X = B  or  A^T X = B
!! and provides error bounds and backward error estimates for
!! the solution. LA_GERFS uses the LU factors computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GERFS (A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:), AF(:,:), <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    <type>(<wp>), INTENT(INOUT) :: <sol>
!!    REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!!    <sol>  ::= X(:,:) | X(:)
!!    <err>  ::= FERR(:), BERR(:) | FERR, BERR
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The original matrix A.
!
!! AF    (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(AF,1) == size(AF,2) == size(A,1).
!!       The factors L and U from the factorization A = PLU
!!       as computed by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       The right hand side vector(s) of matrix B for
!!       the system of equations AX = B.
!
!! X     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(X,1) or size(X) == size(A,1).
!!       On entry, the solution matrix X, as computed by LA_GETRS.
!!       On exit, the improved solution matrix X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!       of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! FERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(FERR) == size(X,2).
!!       The estimated forward error bound for each solution vector
!!       X(j) (the j-th column of the solution matrix X).
!!       If XTRUE is the true solution corresponding to X(j), FERR(j)
!!       is an estimated upper bound for the magnitude of the largest
!!       element in (X(j) - XTRUE) divided by the magnitude of the
!!       largest element in X(j).  The estimate is as reliable as
!!       the estimate for RCOND, and is almost always a slight
!!       overestimate of the true error.
!
!! BERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(BERR) == size(X,2).
!!       The componentwise relative backward error of each solution
!!       vector X(j) (i.e., the smallest relative change in
!!       any element of A or B that makes X(j) an exact solution).
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!
!! Internal Parameters
!! ===================
!
!! ITMAX is the maximum number of steps of iterative refinement.
!! It is set to 5 in the LAPACK77 subroutines
!! -----------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SFERR, SBERR
!!  .. LOCAL ARRAYS, POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: LFERR(:), LBERR(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF ( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF ( SIZE(B, 1) /= N ) THEN; LINFO = -4
   ELSE IF ( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -7
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -8
   ELSE IF ( N > 0 ) THEN
      IF( .NOT.PRESENT(FERR) ) THEN
         ALLOCATE( LFERR(NRHS), STAT=ISTAT )
      ELSE; LFERR => FERR; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) ) THEN
            ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN; ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT ); END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, NRHS, A, MAX(1,N), AF, MAX(1,N), &
                         IPIV, B, MAX(1,N), X, MAX(1,N), LFERR, &
                         LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGERFS_F95
SUBROUTINE SGESDD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESDD_F77 => LA_GESDD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESDD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, JOBZ
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, S1U, S2U, S1VT, S2VT, &
&             MN, SMLSIZ
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLVT(1,1)
   REAL(WP), POINTER :: WORK(:), W1(:,:), W2(:,:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)

   IF( PRESENT(JOB) )THEN; LJOBZ = JOB; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF(.NOT. (LSAME(LJOBZ, "N") .OR. LSAME(LJOBZ,"U") .OR. LSAME(LJOBZ, "V"))) THEN ; LINFO = -6
   ELSE

        SMLSIZ = ILAENV_F77( 9, "DGESDD", " ", 0, 0, 0, 0 )
        LWORK = MAX(MAX(14*MIN(M,N)+4, 10*MIN(M,N)+2+SMLSIZ*(SMLSIZ+8)) + MAX(M,N), &
&         5*MIN(M,N)*MIN(M,N) + MAX(M,N) + 9*MIN(M,N))

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF( ISTAT == 0 ) THEN
          ALLOCATE(IWORK(8*MIN(M,N)), STAT=ISTAT)
          IF( ISTAT == 0 ) THEN
            IF (.NOT.PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
              ALLOCATE(W1(M,M), W2(N,N), STAT=ISTAT)
              IF (ISTAT == 0) THEN
                IF (.NOT. LSAME(LJOBZ, "N")) THEN
                  JOBZ = "S"
                ELSE
                  JOBZ = "N"
                ENDIF
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
                SELECT CASE(LJOBZ)
                  CASE ("U")
                    A(1:MN, 1:MN) = W1(1:MN, 1:MN)
                  CASE ("V")
                    A(1:MN, 1:MN) = W2(1:MN, 1:MN)
                END SELECT
                DEALLOCATE(W1, W2)
              ELSE
                LINFO = -100
              END IF
            ELSE IF (.NOT. PRESENT(U) .AND. PRESENT(VT)) THEN
              JOBZ = "A"
              ALLOCATE(W1(M,M), STAT=ISTAT)
              IF (ISTAT == 0) THEN
               IF (PRESENT (VT)) THEN
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 VT, MAX(1, S1VT), WORK, LWORK, IWORK, LINFO )
               ELSE
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                 LLVT, MAX(1, S1VT), WORK, LWORK, IWORK, LINFO )
               ENDIF
                IF (LSAME(LJOBZ, "U")) A(1:M, 1:MN) = W1(1:M, 1:MN)
                DEALLOCATE(W1)
              ELSE
                LINFO = -100
              END IF
            ELSE IF (PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
              JOBZ = "A"
              ALLOCATE(W2(N,N), STAT=ISTAT)
              IF (ISTAT == 0) THEN
               IF (PRESENT (U)) THEN
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
               ELSE
                CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                 W2, MAX(1,N), WORK, LWORK, IWORK, LINFO )
               ENDIF
                IF (LSAME(LJOBZ, "V")) A(1:MN, 1:N) = W2(1:MN, 1:N)
                DEALLOCATE(W2)
              ELSE
                LINFO = -100
              END IF
            ELSE
              JOBZ = "A"
              IF (PRESENT (VT)) THEN
                IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                   VT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                   VT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ENDIF
              ELSE
                IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                   LLVT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                   LLVT, MAX(1,S1VT), WORK, LWORK, IWORK, LINFO )
                ENDIF
              ENDIF
              IF (PRESENT(WW)) WW = WORK(1)
            ENDIF
          ELSE
            LINFO = -100
          END IF
          DEALLOCATE(WORK)
        ELSE
          LINFO = -100
        END IF
      ENDIF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
    END SUBROUTINE SGESDD_F95
      SUBROUTINE SGESV1_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!     .. PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= SIZE(A,1) ) THEN; LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN; LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN; LPIV => IPIV
         ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
         IF ( ISTAT == 0 ) THEN
!!        .. CALL LAPACK77 ROUTINE ..
            CALL GESV_F77( SIZE(A,1), 1, A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)),         &
                           LINFO )
         ELSE; LINFO = -100; END IF
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE(LPIV, STAT = ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE SGESV1_F95
      SUBROUTINE SGESV_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. "Local Pointers" ..
      INTEGER, POINTER :: LPIV(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. "Test the arguments" ..
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN
         LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= SIZE(A,1) .OR. SIZE(B,2) < 0 ) THEN
         LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN
            LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN
            LPIV => IPIV
         ELSE
            ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT )
         END IF
         IF ( ISTAT == 0 ) THEN
!!        .. "Call LAPACK77 routine" ..
            CALL GESV_F77( SIZE(A,1), SIZE(B,2), A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)), &
                           LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            DEALLOCATE(LPIV, STAT = ISTAT1 )
         END IF
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE SGESV_F95
SUBROUTINE SGESVD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESVD_F77 => LA_GESVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOB
   CHARACTER(LEN=1) :: LJOBU, LJOBVT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, ISTAT1, S1U, S2U, S1VT, S2VT, &
              NN, MN, SWW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLVT(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)
   IF( PRESENT(JOB) )THEN; LJOB = JOB; ELSE; LJOB = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
   IF( PRESENT(WW) )THEN; SWW = SIZE(WW); ELSE; SWW = MN-1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF( SWW /= MN-1 .AND. MN > 0 ) THEN; LINFO = -5
   ELSE IF( PRESENT(JOB) .AND. ( .NOT. ( LSAME(LJOB,"U") .OR. &
            LSAME(LJOB,"V") .OR. LSAME(LJOB,"N") ) .OR. &
            LSAME(LJOB,"U") .AND. PRESENT(U) .OR. &
            LSAME(LJOB,"V") .AND. PRESENT(VT)) )THEN; LINFO = -6
   ELSE
      IF( PRESENT(U) )THEN
         IF( S2U == M )THEN; LJOBU = "A"; ELSE; LJOBU = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"U") ) THEN; LJOBU = "O"
         ELSE; LJOBU = "N"; ENDIF
      ENDIF
      IF( PRESENT(VT) )THEN
         IF( S1VT == N )THEN; LJOBVT = "A"; ELSE; LJOBVT = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"V") )THEN; LJOBVT = "O"
         ELSE; LJOBVT = "N"; ENDIF
      ENDIF
      IF( ISTAT == 0 )THEN
         NN = MAX( 5, 3*MN + MAX(M,N), 5*MN )
         LWORK = MAX( 1, NN, LWORK ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
          LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
          IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
       END IF
       IF( ISTAT == 0 ) THEN
          IF( PRESENT(U) ) THEN
            IF ( PRESENT(VT) )THEN
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
             VT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ENDIF
         ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             VT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORK, LWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = INT(WORK(1)+1)
         IF( LINFO > 0 .AND. PRESENT(WW) ) WW(1:MN-1) = WORK(2:MN)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGESVD_F95
      SUBROUTINE SGESVX1_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,    &
                              RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT) :: X(:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SC, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: IWORK(:), LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:)
      REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
      ELSE; LEQUED="N"; END IF
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
      IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE; S1AF = N; S2AF = N; END IF
      IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
      ELSE; MVC = TINY(1.0_WP); END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B) /= N )THEN
         LINFO = -2
      ELSE IF( SIZE(X) /= N )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE
            LPIV => IPIV
         END IF
         IF( .NOT.PRESENT(R) )THEN
            ALLOCATE( LR(N), STAT=ISTAT )
         ELSE
            LR => R
         END IF
         IF( .NOT.PRESENT(C) )THEN
            ALLOCATE( LC(N), STAT=ISTAT )
         ELSE
            LC => C
         END IF
            ALLOCATE(WORK(4*N), IWORK(N), STAT=ISTAT )
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE SGESVX1_F95
      SUBROUTINE SGESVX_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,     &
                             RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: X(:,:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square matrix and X and B are rectangular matrices or vectors.
!!    LA_GESVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_GESVX ( A, B, X, AF=af, IPIV=ipiv, FACT=fact, &
!!                  TRANS=trans, EQUED=equed, R=r, C=c, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, RPVGRW=rpvgrw, &
!!                  INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, &
!!                                       TRANS
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: R(:), C(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A         (input/output) REAL or COMPLEX square array, shape (:,:).
!!           On entry, the matrix A or its equilibration:
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during a previous call
!!           to LA_GESVX.
!!           On exit, if FACT = "E", then the equilibrated version of A
!!           is stored in A; otherwise, A is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!           size(A,1) and size(X,2) = size(B,2), or shape (:) with
!!           size(X) = size(A,1).
!!           The solution matrix X .
!! AF        Optional (input or output) REAL or COMPLEX square array,
!!           shape (:,:) with the same size as A.
!!           If FACT = "F" then AF is an input argument that contains the
!!           factors L and U of (the equilibrated) A returned by a
!!           previous call to LA_GESVX.
!!           If FACT /= "F" then AF is an output argument that contains
!!           the factors L and U of (the equilibrated) A.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = size(A,1).
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A, returned by a previous call to LA_GESVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF and IPIV contain the factored form of (the
!!                 equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "R": Row equilibration, i.e., A has been premultiplied by
!!                 diag(R).
!!            = "C": Column equilibration, i.e., A has been postmultiplied
!!                 by diag(C).
!!            = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with size(R)
!!           = size(A,1). The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with size(C)
!!           = size(A,1). The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j) , FERR(j) is an
!!           estimated upper bound for the magnitude of the largest
!!           element in (X(j)-XTRUE) divided by the magnitude of the
!!           largest element in X(j). The estimate is as reliable as the
!!           estimate for RCOND and is almost always a slight
!!           overestimate of the true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any
!!           element of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition
!!           is indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!               <= n: U(i,i) = 0. The factorization has been completed,
!!                    but the factor U is singular, so the solution could
!!                  not be computed.
!!               = n+1: U is nonsingular, but RCOND is less than machine
!!                  precision, so the matrix is singular to working
!!                  precision. Nevertheless, the solution and error
!!                    bounds are computed because the computed solution
!!                  can be more accurate than the value of RCOND would
!!                  suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SBERR, SC, SFERR, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: IWORK(:), LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:)
      REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
      LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN
         LFACT = FACT
      ELSE
         LFACT="N"
      END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN
         LEQUED = EQUED
      ELSE
         LEQUED="N"
      END IF
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = N
      END IF
      IF( PRESENT(AF) )THEN
         S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE
         S1AF = N; S2AF = N
      END IF
      IF( ( PRESENT(C) ) )THEN
         SC = SIZE(C)
      ELSE
         SC = N
      END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN
         MVC = MINVAL(C)
      ELSE
         MVC = TINY(1.0_WP)
      END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF( PRESENT(FERR) )THEN
         SFERR = SIZE(FERR)
      ELSE
         SFERR = NRHS
      END IF
      IF( PRESENT(BERR) )THEN
         SBERR = SIZE(BERR)
      ELSE
         SBERR = NRHS
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN
         LINFO = -2
      ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( SFERR /= NRHS )THEN
         LINFO = -11
      ELSE IF( SBERR /= NRHS )THEN
         LINFO = -12
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(IPIV) )THEN
               ALLOCATE( LPIV(N), STAT=ISTAT )
            ELSE
               LPIV => IPIV
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(R) )THEN
               ALLOCATE( LR(N), STAT=ISTAT )
            ELSE
               LR => R
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(C) )THEN
               ALLOCATE( LC(N), STAT=ISTAT )
            ELSE
               LC => C
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(FERR) )THEN
               ALLOCATE( LFERR(NRHS), STAT=ISTAT )
            ELSE
               LFERR => FERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(BERR) )THEN
               ALLOCATE( LBERR(NRHS), STAT=ISTAT )
            ELSE
               LBERR => BERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            ALLOCATE(WORK(4*N), IWORK(N), STAT=ISTAT )
         END IF
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
         IF( PRESENT(RPVGRW) ) RPVGRW=WORK(1)
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE SGESVX_F95
      SUBROUTINE SGETRF_F95( A, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GETRF_F77 => LA_GETRF, LANGE_F77 => LA_LANGE, & !!((07-B-INT_LAPACK1.f90))
                                          GECON_F77 => LA_GECON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      REAL(WP), INTENT( INOUT ) :: A( :, : )
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, M, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:), IWORK(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MAX, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      M = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0; MINMN = MIN(M,N)
      LD = MAX(1,M)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 .OR. PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -1
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -2
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -4
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( WORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGE_F77( LNORM, MINMN, MINMN, A, LD, WORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(WORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GETRF_F77( M, N, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(4*MINMN), IWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GECON_F77( LNORM, MINMN, A, LD, LANORM, &
                                     RCOND, WORK, IWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE SGETRF_F95
SUBROUTINE SGETRI_F95( A, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRI_F77 => LA_GETRI, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRI computes the inverse of a matrix using the LU factorization
!! computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRI (A, IPIV, INFO)
!!    <type>(<wp>), INTENT(INOUT)  :: A(:,:)
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! =====================
!
!! A      (input/output) either REAL or COMPLEX square array, shape (:,:),
!!        size(A,1) == size(A,2).
!!        On entry contains the factors L and U from the factorization
!!           A = PLU as computed by LA_GETRF.
!!        On exit, if INFO = 0, the inverse of the original matrix A.
!
!! IPIV   (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!        The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i of
!!        the matrix was interchanged with row IPIV(i).
!
!! INFO   Optional (output) INTEGER.
!!        If INFO is present
!!           = 0: successful exit
!!           < 0: if INFO = -k, the k-th argument had an illegal value
!!           > 0: if INFO = k, U(k,k) is exactly zero.  The matrix is
!!               singular and its inverse could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!           terminated with an error message.
!-----------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRI"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SGETRI"
!!  .. LOCAL SCALARS ..
   INTEGER    :: LINFO, N, LD, LWORK, ISTAT, ISTAT1, NB
!!  .. LOCAL ARRAY ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LINFO = 0; LD = MAX(1,N); ISTAT = 0
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N )THEN; LINFO = -2
   ELSE IF( N > 0 )THEN
!!     DETERMINE THE WORK SPACE.
      NB = ILAENV_F77( 1, BSNAME, " ", N, -1, -1, -1 )
      IF( NB < 1 .OR. NB >= N )THEN; NB = 1; END IF
      LWORK = MAX( N*NB, 1 )
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = MAX(1,N); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( LINFO == 0 )THEN
         CALL GETRI_F77( N, A, LD, IPIV, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGETRI_F95
SUBROUTINE SGETRS1_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE SGETRS1_F95
SUBROUTINE SGETRS_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRS solves a system of linear equations
!!    A X = B, A^T X = B or  A^H X = B
!! with a general square matrix A using the LU factorization computed
!! by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRS (A, IPIV, B, TRANS, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:)
!!    <type>(<wp>), INTENT(INOUT) :: <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The factors L and U from the factorization A = PLU as computed
!!       by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       On entry, the right hand side vector(s) of matrix B for
!!          the system of equations AX = B.
!!       On exit, if there is no error, the matrix of solution
!!          vector(s) X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!          of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!---------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = SIZE(B,2); LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B, 1 ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE SGETRS_F95
      SUBROUTINE SGGES_F95( A, B, ALPHAR, ALPHAI, BETA, VSL, VSR, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  SP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGES_F77 => LA_GGES                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!!  .. FUNCTIONAL ARGUMENTS ..
     INTERFACE
      LOGICAL FUNCTION SELECT(ALPHAR, ALPHAI, BETA)
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      REAL(WP), INTENT(IN) :: ALPHAR, ALPHAI, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGES computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!
!! =========
!!
!!           SUBROUTINE LA_GGES( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGES for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGES"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHAR, SALPHAI, SBETA
      INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      LOGICAL, POINTER :: BWORK(:)
      LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   IF (PRESENT (SELECT)) THEN
      LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
      ELSE IF( SALPHAR /= N )THEN; LINFO = -3
      ELSE IF( SALPHAI /= N )THEN; LINFO = -4
      ELSE IF( SBETA /= N )THEN; LINFO = -5
      ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
      ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7
   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 500; ENDIF
      ELSE; BWORK => LLBWORK; END IF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
        LWORK = -1
        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ELSE
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ELSE
             CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               WORKMIN, LWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
        LWORK = WORKMIN(1)

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 400; ENDIF

        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                WORK, LWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
          IF (PRESENT(SDIM)) SDIM = LSDIM

          DEALLOCATE(WORK)
400       IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK)
        ENDIF
500     CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGGES_F95
SUBROUTINE SGGESX_F95( A, B,  ALPHAR, ALPHAI, &
&   BETA, VSL, VSR, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGESX_F77 => LA_GGESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: RCONDE(2), RCONDV(2)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT(ALPHAR, ALPHAI, BETA)
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      REAL(WP), INTENT(IN) :: ALPHAR, ALPHAI, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGESX computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       LA_GGESX also computes two reciprocal condition numbers for the
!! average of the selected eigenvalues and reciprocal condition numbers
!! for the right and left deflating subspaces corresponding to the
!! selected eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_GGESX( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim,
!!                      RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE(2), RCONDV(2)
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGESX for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE)=2.
!!          The reciprocal condition numbers for the average of the
!!          selected eigenvalues.
!! RCONDV   Optional (output) REAL array, shape (:) with size(RCONDV)=2.
!!          The reciprocal condition numbers for the left and right
!!          deflating subspaces corresponding to the selected
!!          eigenvalues.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHAR, SALPHAI, SBETA, LIWORK
   INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), TARGET :: LLRCONDE(2), LLRCONDV(2)
   REAL(WP), POINTER :: WORK(:)
   LOGICAL, POINTER :: BWORK(:)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   IF  (PRESENT (SELECT)) THEN
     LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
      ELSE IF( SALPHAR /= N )THEN; LINFO = -3
      ELSE IF( SALPHAI /= N )THEN; LINFO = -4
      ELSE IF( SBETA /= N )THEN; LINFO = -5
      ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -6
      ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -7

   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-101; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      IF (LSAME (LSENSE, "N")) THEN
        LWORK =   8 * (N+1)+16
      ELSE
        LWORK = MAX( 8*(N+1)+16, N*N/2+1 )
      ENDIF
      ALLOCATE (WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-105; GOTO 500; ENDIF
      LIWORK = 8*(N+6)+10
      ALLOCATE ( IWORK (LIWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-106; GOTO 600; ENDIF

      IF (PRESENT (RCONDV)) THEN
        IF (PRESENT (RCONDE)) THEN
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, RCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ENDIF
      ELSE
        IF (PRESENT (RCONDE)) THEN
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               RCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT (VSR)) THEN
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ELSE
            IF (PRESENT (VSL)) THEN
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ELSE
              CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&               LSDIM, ALPHAR, ALPHAI, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&               LLRCONDE, LLRCONDV, WORK, LWORK, IWORK, LIWORK, BWORK, LINFO )
            ENDIF
          ENDIF
        ENDIF
      ENDIF

      IF (PRESENT(SDIM)) SDIM = LSDIM

      DEALLOCATE(WORK, STAT=ISTAT)
600   DEALLOCATE(IWORK, STAT=ISTAT)
500   IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK, STAT=ISTAT)

    ENDIF
100   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGGESX_F95
      SUBROUTINE SGGEV_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEV_F77 => LA_GGEV                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
       REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!! LA_GGEV computes for a pair of n by n real or complex matrices (A,B)
!! the generalized eigenvalues in the form of scalar pairs (alpha, beta)
!! and, optionally, the left and/or right generalized eigenvectors.
!!       A generalized eigenvalue of the pair (A,B) is, roughly
!! speaking, a scalar of the form  lambda=alpha/beta such that the matrix
!! A-lambda*B is singular. It is usually represented as the pair
!! (alpha; beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector v such that (A-lambda*B)*v=0. A left
!! generalized eigenvector is a vector u such that u^H*(A-lambda*B)=0,
!! where u^H is the conjugate-transpose of u.
!!       The computation is based on the (generalized) real or complex
!! Schur form of (A,B). (See LA_GGES for details of this form.)
!!
!! =========
!!
!!     SUBROUTINE LA_GGEV( A, B, <alpha>, BETA, VL=vl, &
!!                 VR=vr, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!         <type>     ::= REAL | COMPLEX
!!         <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!         <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!         <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B.
!!         On exit, B has been destroyed.
!! <alpha> (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!         size(A,1).
!!         The values of alpha.
!!         alpha(:) ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!         where
!!         ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!         imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA    (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!         size(A,1).
!!         The values of beta.
!!         Note: The generalized eigenvalues of the pair (A,B) are the
!!         scalars lambda(j)=alpha(j)/beta(j). These quotients may easily
!!         over- or underflow, and beta(j) may even be zero. Thus, the
!!         USEr should avoid computing them naively.
!!         Note: If A and B are real then complex eigenvalues occur in
!!         complex conjugate pairs. Each pair is stored consecutively.
!!         Thus a complex conjugate pair is given by
!!             lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!             lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!         where
!!             ALPHAI(j)/BETA(j) = -(ALPHAI(j+1)/BETA(j+1))
!! VL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VL,1) = size(A,1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag:part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!            <= n: The QZ iteration failed. No eigenvectors have been
!!                  calculated, but (alpha(j), BETA(j)) should be
!!                  correct for j = INFO+1, ..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: a failure occurred during the computation of the
!!                  generalized eigenvectors.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------

!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGEV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHAR, SALPHAI, SBETA
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI)
   SBETA = SIZE(BETA)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( N > 0 )THEN


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, VL, S1VL, VR, S1VR, WORKMIN, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, VL, S1VL, LLVR, S1VR, WORKMIN, LWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, LLVL, S1VL, VR, S1VR, WORKMIN, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&              BETA, LLVL, S1VL, LLVR, S1VR, WORKMIN, LWORK, LINFO )
        ENDIF
       ENDIF
      LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, VL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, LINFO )
        ELSE
           CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&                        BETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, LINFO )
        ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      DEALLOCATE(WORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGGEV_F95
      SUBROUTINE SGGEVX_F95( A, B, ALPHAR, ALPHAI, BETA, VL, VR, &
     &  BALANC, ILO, IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEVX_F77 => LA_GGEVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: ILO,IHI
      REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!  .. ARRAY ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: LSCALE(:), RSCALE(:), &
     &  RCONDE(:), RCONDV(:)
      REAL(WP), INTENT(OUT) :: ALPHAR(:), ALPHAI(:), BETA(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGEVX computes for a pair of n-by-n real or complex matrices
!! (A, B) the generalized eigenvalues in the form of scalar pairs
!! (alpha; beta) and, optionally, the left and/or right generalized
!! eigenvectors.
!!      A generalized eigenvalue of the pair (A; B) is, roughly speaking,
!! a scalar of the form lambda = alpha / beta such that the matrix
!! A - lambda * B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!      A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector  v  such that ( A - lambda*B)* v = 0.
!! A left generalized eigenvector is a vector u such that
!! u^H*(A-lambda*B) = 0, where u^H is the conjugate-transpose of u.
!!      The computation is based on the (generalized) real or complex
!! Schur form of (A, B). (See LA_GGES for details of this form.)
!!      Optionally, LA_GGEVX also computes a balancing transformation
!! (to improve the conditioning of the eigenvalues and eigenvectors),
!! reciprocal condition numbers for the eigenvalues, and reciprocal
!! condition numbers for the right eigenvectors. The balancing
!! transformation consists of a permutation of rows and columns and/or a
!! scaling of rows and columns.
!!
!! ==========
!!
!!    SUBROUTINE LA_GGEVX( A, B, <alpha>, BETA, VL=vl, &
!!          VR=vr, BALANC=balanc, ILO=ilo, IHI=ihi, &
!!          LSCALE=lscale, RSCALE=rscale, ABNRM=abnrm, &
!!          BBNRM=bbnrm, RCONDE=rconde, RCONDV=rcondv, &
!!          INFO=info )
!!        <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!        <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!        <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!        CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!        INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: LSCALE(:),
!!             RSCALE(:), RCONDE(:), RCONDV(:)
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!        INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!        <type>     ::= REAL | COMPLEX
!!        <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!        <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!        <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:, :).
!!          On entry, the matrix A.
!!          On exit, A has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then A contains
!!          the first part of the real/complex Schur form of the
!!          "balanced" versions of the matrix pair (A, B).
!! B        (input/output) REAL or COMPLEX square array, shape (:, :)
!!          with size(B, 1) = size(A, 1).
!!          On entry, the matrix B.
!!          On exit, B has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then B contains
!!          the second part of the real/complex Schur form of the "bal-
!!          anced" versions of the matrix pair (A, B).
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with
!!          size(<alpha>) = size(A, 1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) |  ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with
!!          size(BETA) = size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A, B) are the
!!          scalars lambda(j) = alpha(j) / beta(j) . These quotients
!!          may easily over- or underflow, and beta(j) may even be zero.
!!          Thus, the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!                 lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!                 lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!              ALPHAI(j)/BETA(j)= - (ALPHAI(j+1)/BETA(j+1))
!! VL       Optional (output) REAL or COMPLEX square array, shape (:, :)
!!          with  size(VL, 1) = size(A, 1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!         | realpart | + | imag.part | = 1,except that for eigenvalues
!!         with alpha = beta = 0, a zero vector is returned as the
!!         corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC  Optional (input) CHARACTER(LEN=1).
!!         Specifies the balance option to be performed.
!!            = "N": do not permute or scale;
!!            = "P": permute only;
!!            = "S": scale only;
!!            = "B": both permute and scale.
!!         Default value: "N".
!!         Note: Computed reciprocal condition numbers will be for the
!!         matrices after balancing. Permuting does not change condition
!!         numbers (in exact arithmetic), but scaling does.
!! ILO,IHI Optional (output) INTEGER.
!!         ILO and IHI are integer values such that on exit A(i,j) = 0
!!         and B(i,j) = 0 if i > j and j =1,...,ILO-1 or
!!         i = IHI+1,...,n.
!!         If BALANC = "N" or "S", then ILO = 1 and IHI = n.
!! LSCALE  Optional (output) REAL array, shape (:) with size(LSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to
!!         the left side of A and B. If PL(j) is the index of the row
!!         interchanged with row j, and DL(j) is the scaling factor
!!         applied to row j, then
!!                 PL(j) = LSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!               DL(j) = LSCALE(j),  j = ILO, ..., IHI
!! RSCALE  Optional (output) REAL array, shape (:), size(RSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to the
!!         right side of A and B. If PR(j) is the index of the column
!!         interchanged with column j, and DR(j) is the scaling factor
!!         applied to column j, then
!!                PR(j) = RSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!                DR(j) = RSCALE(j),  j = ILO, ..., IHI
!! ABNRM   Optional (output) REAL.
!!         The l1 norm of A after balancing.
!! BBNRM   Optional (output) REAL.
!!         The l 1 norm of B after balancing.
!! RCONDE  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The reciprocal condition numbers of the eigenvalues.
!! RCONDV  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The estimated reciprocal condition numbers of the right
!!         eigenvectors. If the eigenvalues cannot be reordered to
!!         compute RCONDV(j) then RCONDV(j) is set to 0. This can only
!!         occur when the true value would be very small.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!           <= n: The QZ iteration failed. No eigenvectors have been
!!                 calculated, but (alpha(j) , BETA(j) ) should be
!!          correct for j = INFO + 1,..., n.
!!             = n+1: another part of the algorithm failed.
!!             = n+2: a failure occurred during the computation of the
!!                 generalized eigenvectors.
!!         If INFO is not present and an error occurs, then the program
!!       is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGEVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR, LBALANC, LSENSE
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHAR, SALPHAI, SBETA, LILO, LIHI, SRCONDE, SRCONDV, SLSCALE, SRSCALE
      REAL(WP) :: LABNRM, LBBNRM
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: LRCONDE(:), LRCONDV(:), LLSCALE(:), LRSCALE(:)
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      LOGICAL, POINTER :: BWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHAR = SIZE(ALPHAR); SALPHAI = SIZE(ALPHAI); SBETA = SIZE(BETA)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(LSCALE) )THEN; SLSCALE = SIZE(LSCALE); ELSE; SLSCALE = N; ENDIF
   IF( PRESENT(RSCALE) )THEN; SRSCALE = SIZE(RSCALE); ELSE; SRSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHAR /= N )THEN; LINFO = -3
   ELSE IF( SALPHAI /= N )THEN; LINFO = -4
   ELSE IF( SBETA /= N )THEN; LINFO = -5
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -6
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -7
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
     &  LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -8
   ELSE IF( SLSCALE /= N )THEN; LINFO = -11
   ELSE IF( SRSCALE /= N )THEN; LINFO = -12
   ELSE IF( SRCONDE /= N )THEN; LINFO = -15
   ELSE IF( SRCONDV /= N )THEN; LINFO = -16
   ELSE IF( N > 0 )THEN
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF

      ALLOCATE(BWORK(N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1000; ENDIF

      ALLOCATE(IWORK(N+6), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 900; ENDIF

      IF( PRESENT(LSCALE) )THEN; LLSCALE => LSCALE
      ELSE; ALLOCATE( LLSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 800; ENDIF
      END IF

      IF( PRESENT(RSCALE) )THEN; LRSCALE => RSCALE
      ELSE; ALLOCATE( LRSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 700; ENDIF
      END IF

      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 600; ENDIF
      END IF

      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 500; ENDIF
      END IF

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, IWORK, BWORK, LINFO )
        ENDIF
       ENDIF
      LWORK = WORKMIN(1)

      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ELSE
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ELSE
            CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHAR, ALPHAI, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&             LRCONDE, LRCONDV, WORK, LWORK, IWORK, BWORK, LINFO )
        ENDIF
      ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO; IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( PRESENT(BBNRM) ) BBNRM = LBBNRM

      DEALLOCATE(WORK)
100  IF (.NOT. PRESENT(RCONDE)) DEALLOCATE(LRCONDE)
500  IF (.NOT. PRESENT(RCONDV)) DEALLOCATE(LRCONDV)
600  IF (.NOT. PRESENT(RSCALE)) DEALLOCATE(LRSCALE)
700  IF (.NOT. PRESENT(LSCALE)) DEALLOCATE(LLSCALE)
800  DEALLOCATE (IWORK)
900  DEALLOCATE (BWORK)
     ENDIF
1000  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGGEVX_F95
SUBROUTINE SGGGLM_F95( A, B, D, X, Y, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGGLM_F77 => LA_GGGLM                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:), D(:)
    REAL(WP), INTENT(OUT) :: X(:), Y(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GGGLM solves the general (Gauss-Markov) linear model (GLM)
!! problem:
!!      min ||y||2  subject to d=A*x + B*y
!!       x
!! where A and B are real or complex rectangular matrices and d is a real
!! or complex vector. Further, A is n by m, B is n by p, and d is n by 1,
!! and it is assumed that m <= n <= m+p, rank(A) = m, rank(A, B) = n.
!! These conditions ensure that the GLM problem has unique solution
!! vectors x and y. The problem is solved using the generalized QR
!! factorization of A and B.
!!        If matrix B is square and nonsingular, then the GLM problem is
!! equivalent to the weighted linear least squares problem
!!         min ||B^-1 * (d-A*x)||2
!!          x
!!
!! =========
!!
!!       SUBROUTINE LA_GGGLM( A, B, D, X, Y, INFO=info )
!!           <type>(<wp>), INTENT( INOUT ) :: A( :, : ), B(:,:), D(:)
!!           <type>(<wp>), INTENT( OUT ) :: X(:), Y(:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(A,1) = n and size(A,2) = m.
!!       On entry, the matrix A.
!!       On exit, the contents of A are destroyed.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n and size(B,2) = p.
!!       On entry, the matrix B.
!!       On exit, the contents of B are destroyed.
!! D     (input/output) REAL or COMPLEX array, shape (:) with
!!       size(D) = n.
!!       On entry, the vector d.
!!       On exit, the contents of D are destroyed.
!! X     (output) REAL or COMPLEX array, shape (:) with size(X) = m.
!!       The solution vector x.
!! Y     (output) REAL or COMPLEX array, shape (:) with size(Y) = p.
!!       The solution vector y.
!! INFO  Optional (output) INTEGER.
!!       = 0: successful exit
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGGLM"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); M = SIZE(A,2); P = SIZE(B,2)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < M ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P < N-M .OR. SIZE(B,1) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(D) /= N ) THEN; LINFO = -3
    ELSE IF( SIZE(X) /= M ) THEN; LINFO = -4
    ELSE IF( SIZE(Y) /= P ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGGLM_F77( N, M, P, A, MAX(1,N), B, MAX(1,N), &
                          D, X, Y, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT( WORK(1) )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGGGLM_F95
SUBROUTINE SGGLSE_F95( A, B, C, D, X, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGLSE_F77 => LA_GGLSE                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:), C(:), D(:)
    REAL(WP), INTENT(OUT) :: X(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GGLSE solves the linear equality-constrained least squares
!! (LSE) problem:
!!      min || c - A*x||2 subject to B*x = d,
!! where A and B are real or complex rectangular matrices and c and d are
!! real or complex vectors. Further, A is m by n, B is p by n, c is m by 1
!! and d is p by 1, and it is assumed that
!!       p <= n <=  m + p, rank(B) = p,  rank [ A ] = n.
!!                                            [ B ]
!! These conditions ensure that the LSE problem has a unique solution x.
!! This is obtained using the generalized RQ factorization of the matrices
!! B and A.
!!
!! =========
!!
!!        SUBROUTINE LA_GGLSE( A, B, C, D, X, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A(:,:), B(:,:), C(:), D(:)
!!          <type>(<wp>), INTENT( OUT ) :: X(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(A,1) = m and size(A,2) = n.
!!         On entry, the matrix A.
!!         On exit, the contents of A are destroyed.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = p and size(B,2) = n.
!!         On entry, the matrix B.
!!         On exit, the contents of B are destroyed.
!! C       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(C) = m.
!!         On entry, the vector c.
!!         On exit, the residual sum of squares for the solution is given
!!         by the sum of squares of elements n-p+1 to m.
!! D       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(D) = p.
!!         On entry, The vectors d.
!!         On exit, the contents of D are destroyed.
!! X       (output) REAL or COMPLEX array, shape (:) with size(X) = n.
!!         The solution vector x.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGLSE"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P > N .OR. P < N-M .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(C) /= M ) THEN; LINFO = -3
    ELSE IF( SIZE(D) /= P ) THEN; LINFO = -4
    ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGLSE_F77( M, N, P, A, MAX(1,M), B, MAX(1,P), &
                          C, D, X, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT(WORK(1))
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SGGLSE_F95
SUBROUTINE SGGSVD_F95( A, B, ALPHA, BETA, K, L, U, V, Q, IWORK, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGSVD_F77 => LA_GGSVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, K, L
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), V(:,:), Q(:,:)
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IWORK(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGSVD computes the generalized singular values and, optionally,
!! the transformation matrices from the generalized singular value
!! decomposition (GSVD) of a real or complex matrix pair (A,B), where A
!! is m by n and B is p by n. The GSVD of (A,B) is written
!!       A = U * SIGMA1(0, R)*Q^H , B = V * SIGMA2(0, R)*Q^H
!! where U , V and Q are orthogonal (unitary) matrices of dimensions m by m,
!! p by p and n by n, respectively. Let l be the rank of B and r the rank of
!! the (m + p) * n matrix ( A )
!!                        ( B )
!! , and let k = r-l. Then SIGMA1 and SIGMA2 are m*(k + l) and p * (k + l)
!! "diagonal" matrices, respectively, and R is a (k + l) * (k + l)
!! nonsingular triangular matrix. The detailed structure of SIGMA1 ,SIGMA2
!! and R depends on the sign of (m - k - l) as follows:
!!       The case m-k-l>=0:
!!
!!                               k   l
!!                      k      ( I   0 )
!!        SIGMA1 =      l      ( 0   C )
!!                    m-k-l    ( 0   0 )
!!
!!
!!                           k   l
!!       SIGMA2 =    l   ( 0   S )
!!                 p - l ( 0   S )
!!
!!
!!                          n-k-l   k     l
!!          (0, R) =   k   (  0    R11   R12  )
!!                     l   (  0     0    R22  )
!!
!! where C^2 + S^2 = I . We define
!! alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i=1,2,...,l
!! beta(1) = beta(2) = ... = beta(k) = 0, beta(k+i) = s(i i), i=1,2,...,l
!!
!! The case m-k-l < 0:
!!
!!                                k    m-k    k+l-m
!!            SIGMA1 =    k    (  I     0       0   )
!!                       m-k   (  0     C       0   )
!!
!!
!!                              k    m-k     k+l-m
!!                        m-k   ( 0     S        0  )
!!            SIGMA2 =   k+l-m  ( 0     0        I  )
!!                        p-l   ( 0     0        0  )
!!
!!
!!                                  n-k-l    k     m-k   k+l-m
!!                         k      (   0     R11    R12    R13  )
!!              (0,R) =   m-k     (   0      0     R22    R23  )
!!                       k+l-m    (   0      0      0     R33  )
!!
!! where C^2 + S^2 = I . We define
!!  alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i =1,2,...,m-k,
!!  alpha(m+1) = alpha(m+2)=...= alpha(k+l) = 0
!!  beta(1)=beta(2)= ... =beta(k)=0, beta(k+i)=s(i i), i=1,2,...,m-k,
!!  beta(m+1) = beta(m+2) = ... = beta(k+l) = 1
!!
!! In both cases the generalized singular values of the pair (A,B) are the
!! ratios
!!  sigma(i) = alpha(i)/beta(i), i = 1,2, ... ,k+l
!!
!! The first k singular values are infinite. The finite singular values
!! are real and nonnegative.
!!     LA_GGSVD computes the real (nonnegative) scalars alpha(i), beta(i),
!! i=1,2,..., k+l , the matrix R, and, optionally, the transformation
!! matrices U , V and Q.
!!
!! =========
!!
!!      SUBROUTINE LA_GGSVD( A, B, ALPHA, BETA, K=k, L=l, &
!!                       U=u, V=v, Q=q, IWORK=iwork, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: ALPHA(:), BETA(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: K, L
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), V(:,:), Q(:,:)
!!          INTEGER, INTENT(IN), OPTIONAL :: IWORK(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(A,1) = m and size(A,2) = n.
!!        On entry, the matrix A.
!!        On exit, A contains the triangular matrix R, or part of R, as
!!        follows:
!!        If m-k-l >= 0, then R is stored in A(1:k+l,n-k-l+1:n).
!!        If m-k-l < 0, then the matrix
!!                  ( R11     R12    R13 )
!!                (  0      R22    R23 )
!!        is stored in A(1:m,n-k-l+1:n).
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = p and size(B,2) = n.
!!        On entry, the matrix B.
!!        On exit, if m-k-l < 0, then R33 is stored in
!!        B(m-k+1:l,n+m-k-l+1:n).
!! ALPHA  (output) REAL array, shape (:) with size(ALPHA) = n
!!        The real scalars alpha(i) , i = 1, 2,..., k+l.
!! BETA   (output) REAL array, shape (:) with size(BETA) = n.
!!        The real scalars beta(i) , i = 1, 2, ..., k+l.
!!        Note: The generalized singular values of the pair (A,B) are
!!        sigma(i) = ALPHA(i)/BETA(i), i = 1, 2, ...,  k+l.
!!        If k + l < n, then ALPHA(k+l+1:n) = BETA(k+l+1:n) = 0.
!! K, L   Optional (output) INTEGER.
!!        The dimension parameters k and l.
!! U      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(U,1) = m.
!!        The matrix U .
!! V      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(V,1) = p.
!!        The matrix V .
!! Q      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Q,1) = n.
!!        The matrix Q.
!! IWORK  Optional (output) INTEGER array, shape(:) with size(IWORK) = n.
!!        IWORK contains sorting information. More precisely, the loop
!!             for i = k + 1, min(m, k + l)
!!                   swap ALPHA(i) and ALPHA(IWORK(i))
!!             end
!!        will sort ALPHA so that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(n).
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = 1, the algorithm failed to converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGSVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBU, LJOBV, LJOBQ
   INTEGER :: M, N, P, LINFO, ISTAT, ISTAT1, S1U, S2U, S1V, S2V, &
              S1Q, S2Q, LK, LL
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLU(1,1), LLV(1,1), LLQ(1,1)
   INTEGER, POINTER :: LIWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2); LJOBU = "U"
   ELSE; S1U = 1; S2U = 1; LJOBU = "N"; END IF
   IF( PRESENT(V) )THEN; S1V = SIZE(V,1); S2V = SIZE(V,2); LJOBV = "V"
   ELSE; S1V = 1; S2V = 1; LJOBV = "N"; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2); LJOBQ = "Q"
   ELSE; S1Q = 1; S2Q = 1; LJOBQ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < N )THEN; LINFO = -1
   ELSE IF( SIZE(B,2) /= N .OR. P < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( ALPHA ) /= N )THEN; LINFO = -3
   ELSE IF( SIZE( BETA ) /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(U) .AND. ( S1U /= MAX(1,M) .OR.  S2U /= M ) )THEN; LINFO = -7
   ELSE IF( PRESENT(V) .AND. ( S1V /= MAX(1,P) .OR.  S2V /= P ) )THEN; LINFO = -8
   ELSE IF( PRESENT(Q) .AND. ( S1Q /= MAX(1,N) .OR.  S2Q /= N ) )THEN; LINFO = -9
   ELSE
    IF (PRESENT(IWORK)) THEN
      LIWORK => IWORK
    ELSE
      ALLOCATE( LIWORK(MAX(1,N)), STAT=ISTAT )
    ENDIF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( WORK( MAX(1,MAX(3*N,M,P)+N) ), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(U) )THEN
           IF( PRESENT(V) )THEN
             IF( PRESENT(Q) )THEN
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ELSE
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ENDIF
             ELSE
              IF( PRESENT(Q) )THEN
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ELSE
                CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
              ENDIF
            ENDIF
           ELSE
             IF( PRESENT(V) )THEN
               IF( PRESENT(Q) )THEN
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
               ELSE
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ENDIF
              ELSE
               IF( PRESENT(Q) )THEN
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ELSE
                 CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, LIWORK, LINFO )
                ENDIF
               ENDIF
              ENDIF
         IF( PRESENT(K) ) K = LK
         IF( PRESENT(L) ) L = LL
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
      IF (.NOT. PRESENT(IWORK)) DEALLOCATE(LIWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SGGSVD_F95
 SUBROUTINE SGTSV1_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, 1, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SGTSV1_F95
 SUBROUTINE SGTSV_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GTSV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square tridiagonal matrix and X and B
!! are rectangular matrices or vectors. The LU decomposition is used to
!! factor the matrix A as A = L*U , where L is a product of permutation
!! and unit lower bidiagonal matrices and U is upper triangular with
!! nonzeros in only the main diagonal and first two superdiagonals.
!! The factored form of A is then used to solve the above system.
!!
!! Note: The system A^T*X = B may be solved by interchanging the order of
!! the arguments DU and DL.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSV( DL, D, DU, B, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: DL(:), D(:), DU(:), <rhs>
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs> ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! DL    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1, where n is the order of A.
!!       On entry, the subdiagonal of A.
!!       On exit, the n-2 elements of the second superdiagonal of U in
!!       DL(1),..., DL(n-2).
!! D     (input/output) REAL or COMPLEX array, shape (:) with size(D) = n.
!!       On entry, the diagonal of A.
!!       On exit, the diagonal of U .
!! DU    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1.
!!       On entry, the superdiagonal of A.
!!       On exit, the first superdiagonal of U .
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n or shape (:) with size(B) = n.
!!       On entry, the matrix B.
!!       On exit, the solution matrix X .
!! INFO  Optional (output) INTEGER
!!       = 0: successful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, then U(i,i) = 0. The factorization has not been
!!       completed unless i = n. The factor U is singular, so the solution
!!       could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, NRHS, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SGTSV_F95
SUBROUTINE SGTSVX1_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                            IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0 ) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, 1, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGTSVX1_F95
SUBROUTINE SGTSVX_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                           IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
   REAL(WP), INTENT(OUT) :: X(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GTSVX computes the solution to a real or complex linear system
!! of equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square tridiagonal matrix and X and B are rectangular matrices or
!! vectors.
!!     LA_GTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSVX( DL, D, DU, B, X, DLF=dlf, DF=df, DUF=duf, &
!!               DU2=du2, IPIV=ipiv, FACT=fact, TRANS=trans, FERR=ferr, &
!!               BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(IN) :: DL(:), D(:), DU(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: DLF(:), DF(:), &
!!                                                   DUF(:), DU2(:)
!!           INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, TRANS
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! DL     (input) REAL or COMPLEX array, shape (:) with size(DL) = n-1.
!!        The subdiagonal of A.
!! D      (input) REAL or COMPLEX array, shape (:) with size(D) = n.
!!        The diagonal of A.
!! DU     (input) REAL or COMPLEX array, shape (:) with size(DU) = n-1.
!!        The superdiagonal of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        The matrix B.
!! X      (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!        and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!        The solution matrix X .
!! DLF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DLF)= n-1.
!!        If FACT = "F" then DLF is an input argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!!        If FACT = "N" then DLF is an output argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!! DF     Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DF)= n.
!!        If FACT = "F" then DF is an input argument that contains the
!!        diagonal of the matrix U .
!!        If FACT = "N" then DF is an output argument that contains the
!!        diagonal of the matrix U .
!! DUF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DUF) = n-1.
!!        If FACT = "F" then DUF is an input argument that contains the
!!        first superdiagonal of U.
!!        If FACT = "N" then DUF is an output argument that contains the
!!        first superdiagonal of U.
!! DU2    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DU2) = n-2.
!!        If FACT = "F", then DU2 is an input argument that contains the
!!        second superdiagonal of U.
!!        If FACT = "N", then DU2 is an output argument that contains the
!!        second superdiagonal of U.
!! IPIV   Optional (input or output) INTEGER array, shape (:) with
!!        size(IPIV) = n.
!!        If FACT = "F" then IPIV is an input argument that contains the
!!        pivot indices from the LU factorization of A.
!!        If FACT = "N", then IPIV is an output argument that contains the
!!        pivot indices from the LU factorization of A; row i of the
!!        matrix was interchanged with row IPIV(i). IPIV(i) will always
!!        be either i or i+1; IPIV(i) = i indicates a row interchange was
!!        not required.
!! FACT   Optional (input) CHARACTER(LEN=1).
!!        Specifies whether the factored form of A is supplied on entry.
!!            = "N": The matrix will be copied to DLF, DF and DUF and
!!                 factored.
!!            = "F": DLF, DF, DUF, DU2 and IPIV contain the factored form
!!                 of A.
!!        Default value: "N".
!! TRANS  Optional (input) CHARACTER(LEN=1).
!!        Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!!        Default value: "N".
!! FERR   Optional (output) REAL array of shape (:), with size(FERR) =
!!        size(X,2), or REAL scalar.
!!        The estimated forward error bound for each solution vector X(j)
!!        (the j-th column of the solution matrix X). If XTRUE is the true
!!        solution corresponding to X(j) , FERR(j) is an estimated upper
!!        bound for the magnitude of the largest element in (X(j)-XTRUE)
!!        divided by the magnitude of the largest element in X(j). The
!!        estimate is as reliable as the estimate for RCOND and is almost
!!        always a slight overestimate of the true error.
!! BERR   Optional (output) REAL array of shape (:), with size(BERR) =
!!        size(X,2), or REAL scalar.
!!        The componentwise relative backward error of each solution
!!        vector X(j) (i.e.,the smallest relative change in any element of
!!        A or B that makes X(j) an exact solution).
!! RCOND  Optional (output) REAL.
!!        The estimate of the reciprocal condition number of the matrix A.
!!        If RCOND is less than the machine precision, the matrix is
!!        singular to working precision. This condition is indicated by
!!        a return code of INFO > 0.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, and i is
!!           <= n: U(i,i) = 0. The factorization has not been completed
!!               unless i = n. The factor U is singular, so the solution
!!               could not be computed.
!!           = n+1: U is nonsingular, but RCOND is less than machine
!!               precision, meaning that the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!                 error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2, &
              SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  PRINT *, LINFO, ISTAT, N, NRHS, LFACT, SIPIV, SDLF, SDF, SDUF, SDU2, SFERR, SBERR, LTRANS
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0) THEN; LINFO = -3
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -4
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -13
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -14
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, NRHS, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SGTSVX_F95
      SUBROUTINE SLAGGE_F95( A, KL, KU, D, ISEED, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAGGE_F77 => LA_LAGGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(IN), OPTIONAL :: KL, KU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: ISEED(4)
      REAL(WP), INTENT(IN), OPTIONAL, TARGET :: D(:)
      REAL(WP), INTENT(OUT) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LAGGE generates a real general m by n matrix A, by pre- and post-
!!  multiplying a real diagonal matrix D with random orthogonal matrices:
!!  A = U*D*V. The lower and upper bandwidths may then be reduced to
!!  kl and ku by additional orthogonal transformations.
!
!!  Arguments
!!  =========
!
!!  SUBROUTINE LA_LAGGE( A, KL, KU, D, ISEED, INFO )
!!     <type>(<wp>), INTENT(OUT) :: A(:,:)
!!     INTEGER, INTENT(IN), OPTIONAL :: KL, KU
!!     REAL(<wp>), INTENT(IN), OPTIONAL, TARGET :: D(:)
!!     INTEGER, INTENT(INOUT), OPTIONAL :: ISEED(4)
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!!  =====================
!
!!  A       (output) REAL array, shape (:,:), SIZE(A,1) == m,
!!          SIZE(A,2) == n.
!!          The generated m by n matrix A.
!
!!  KL      (input) INTEGER
!!          The number of nonzero subdiagonals within the band of A.
!!          0 <= KL <= M-1.
!
!!  KU      (input) INTEGER
!!          The number of nonzero superdiagonals within the band of A.
!!          0 <= KU <= N-1.
!
!!  D       (input) REAL array, dimension (min(M,N))
!!          The diagonal elements of the diagonal matrix D.
!
!!  ISEED   Optional (input/output) INTEGER array, shape (:),
!!          SIZE(ISEED) == 4.
!!          On entry, the seed of the random number generator; the array
!!          elements must be between 0 and 4095, and ISEED(4) must be
!!          odd.
!!          On exit, the seed is updated.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LAGGE"
!!     .. "LOCAL Scalars" ..
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, LKL, LKU, M, MN, N, SD, SISEED
!!     .. "Local Arrays" ..
      INTEGER :: LISEED(4)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: LD(:)
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX, MIN
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      MN = MIN(M,N); ISTAT = 0
      IF( PRESENT(KL) )THEN; LKL = KL; ELSE; LKL = M-1; ENDIF
      IF( PRESENT(KU) )THEN; LKU = KU; ELSE; LKU = M-1; ENDIF
      IF( PRESENT(D) )THEN; SD = SIZE(D); ELSE; SD = MN; ENDIF
      IF( PRESENT(ISEED) )THEN; SISEED = SIZE(ISEED); LISEED = ISEED
      ELSE; SISEED = 4
            LISEED(1) = 15; LISEED(2) = 1926
            LISEED(3) = 16; LISEED(4) = 1931; ENDIF
!!     .. "Test the arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( LKL < 0 .OR. LKL > M-1 )THEN; LINFO = -2
      ELSE IF( LKU < 0 .OR. LKU > N-1 )THEN; LINFO = -3
      ELSE IF( SD /= MN )THEN; LINFO = -4
      ELSE IF( SISEED /= 4 .OR. PRESENT(ISEED) .AND. (                  &
     &   ( LISEED(1) < 0 .OR. LISEED(1) > 4095 ) .OR.                   &
     &   ( LISEED(2) < 0 .OR. LISEED(2) > 4095 ) .OR.                   &
     &   ( LISEED(3) < 0 .OR. LISEED(3) > 4095 ) .OR.                   &
     &   ( LISEED(4) < 0 .OR. LISEED(4) > 4095 ) .OR.                   &
     &   ( MOD( LISEED(4), 2 ) == 0 ) ) )THEN; LINFO = -5
      ELSE
         IF( PRESENT(D) )THEN; LD => D
         ELSE; ALLOCATE( LD( MN ), STAT=ISTAT); ENDIF
         IF( ISTAT == 0 )THEN
            ALLOCATE( WORK( M + N ), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               IF( .NOT. PRESENT(D) )THEN
                  LD(1:MN-1) = 1.0_WP; LD(MN) = 0.5_WP; ENDIF
               CALL LAGGE_F77( M, N, LKL, LKU, LD, A, LDA, LISEED, WORK, LINFO )
               IF( PRESENT(ISEED) )ISEED = LISEED
            ELSE; LINFO = -100; END IF
            DEALLOCATE( WORK, STAT=ISTAT1 )
         ENDIF
         IF( .NOT. PRESENT(D) )DEALLOCATE( LD, STAT=ISTAT1)
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE SLAGGE_F95
FUNCTION SLAMCH_F95( PRECISION, CMACH, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. "Use Statements" ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SLAMCH                                             !!((07-B-INT_LAPACK1.f90))
!!  .. "Implicit Statement" ..
   IMPLICIT NONE
!!  .. "Scalar Arguments" ..
   CHARACTER(LEN=1), INTENT(IN) :: CMACH
   REAL(WP), INTENT(IN) :: PRECISION
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP) :: SLAMCH_F95
!--------------------------------------------------
!! .. "Parameters" ..
   CHARACTER( LEN=10 ), PARAMETER :: CHR="ESBPNRMULO"
   CHARACTER( LEN=10 ), PARAMETER :: SRNAME = "LA_LAMCH"
!! .. "Local Scalars" ..
   INTEGER :: I, LINFO
!!  .. "Executable Statements" ..
   LINFO = 2; SLAMCH_F95 = PRECISION
   DO I = 1, 10
     IF( LSAME(CMACH, CHR(I:I)) ) LINFO = 0
   END DO
   SLAMCH_F95 = SLAMCH(CMACH)
   CALL ERINFO( LINFO, SRNAME, INFO )
END FUNCTION SLAMCH_F95
      FUNCTION SLANGE1_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: SLANGE1_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      REAL(WP), INTENT(IN) :: A(:)
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET :: LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A); N = 1; LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           SLANGE1_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION SLANGE1_F95
      FUNCTION SLANGE_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: SLANGE_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      REAL(WP), INTENT(IN) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LANGE  returns the value of the one norm,  or the Frobenius norm,
!!  or the  infinity norm,  or the  element of  largest absolute value
!!  of a complex matrix A.
!
!!  Description
!!  ===========
!
!!  LA_LANGE returns the value
!
!!     LA_LANGE = ( max(abs(A(i,j))), NORM = "M" or "m"
!!              (
!!              ( norm1(A),         NORM = "1", "O" or "o"
!!              (
!!              ( normI(A),         NORM = "I" or "i"
!!              (
!!              ( normF(A),         NORM = "F", "f", "E" or "e"
!
!!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!!  =========
!
!!  FUNCTION LA_ANGE( A, NORM, INFO )
!!     REAL(<wp>) :: LA_ANGE
!!     <type>(<wp>), INTENT(IN) :: <a>
!!     CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!     <a>    ::= A(:,:) | A(:)
!
!!  Arguments
!!  =========
!
!!  A       (input) COMPLEX array, shape either (:,:) or (:).
!!          If shape is (:,:) then SIZE(A,1) == m, SIZE(A,2) == n.
!!          If shape is (:) then SIZE(A) == n.
!!          If either m or n == 0 LA_LANGE is set to zero.
!!          The m by n matrix A.
!
!!  NORM    (input) CHARACTER*1
!!          Specifies the value to be returned in LA_LANGE as described
!!          above.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET ::LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           SLANGE_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION SLANGE_F95
SUBROUTINE SORGTR_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: ORGTR_F77 => LA_ORGTR, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: TAU(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_ORGTR / LA_UNGTR generates a real orthogonal / complex unitary
!! matrix Q which is defined as the product of elementary reflectors,
!! as returned by LA_SYTRD / LA_HETRD:
!!
!! if UPLO = "U", Q = H(n-1) . . . H(2) H(1),
!
!! if UPLO = "L", Q = H(1) H(2) . . . H(n-1).
!
!! =======
!
!!    SUBROUTINE LA_ORGTR / LA_UNGTR( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(IN) :: TAU(:)
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the vectors which define the elementary
!!            reflectors, as returned by LA_SYTRD or LA_HETRD.
!!         On exit the orthogonal or unitary matrix Q.
!
!! TAU     (input) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         TAU(i) must contain the scalar factor of the elementary
!!         reflector H(i), as returned by LA_SYTRD or LA_HETRD.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! ----------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_ORGTR"
   CHARACTER(LEN=5), PARAMETER :: BSNAM  = "SORGQ"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   CHARACTER(LEN=6) :: BSNAME
   INTEGER :: LINFO, LWORK, NB, ISTAT, ISTAT1, N, LD
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      IF( LSAME(LUPLO,"U") )THEN; BSNAME = BSNAM // "L"
      ELSE; BSNAME = BSNAM // "R"; ENDIF
      NB = ILAENV_F77( 1, BSNAME, " ", N-1, N-1, N-1, -1 )
      IF( NB < 1 .OR. NB >= N ) NB = 1
      LWORK = MAX( 1, (N-1)*NB ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT)
         LWORK = MAX( 1, N-1 ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!     .. CALL LAPACK77 ROUTINE
         CALL ORGTR_F77( LUPLO, N, A, LD, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE SORGTR_F95
 SUBROUTINE SPBSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, 1, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPBSV1_F95
 SUBROUTINE SPBSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSV computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. The Cholesky decomposition is used to
!! factor A as A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular band matrix and L is a lower triangular
!! band matrix, each with the same number of superdiagonals or subdiagonals
!! as A. The factored form of A is then used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_PBSV( AB, B, UPLO=uplo, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!         of superdiagonals or subdiagonals in the band and n is the
!!         order of A.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The (kd + 1) diagonals of
!!         A are stored in the rows of AB so that the j-th column of A is
!!         stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                  1<=j<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U = L*L^H in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1)
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, NRHS, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPBSV_F95
SUBROUTINE SPBSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                            S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, KD
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, 1, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPBSVX1_F95
SUBROUTINE SPBSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                           S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSVX computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B
!! are rectangular matrices or vectors.
!!     LA_PBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PBSVX( AB, B, X, UPLO=uplo, AFB=afb, FACT=fact, &
!!                             EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                             RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             <type>(<wp>), INTENT(OUT) :: <sol>
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!             CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!             REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!             <sol>  ::= X(:,:) | X(:)
!!             <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!          of superdiagonals or subdiagonals and n is the order of A.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!          triangle of matrix A, or its equilibration, in band storage.
!!          The (kd + 1) diagonals of A are stored in the rows of AB so
!!          that the j-th column of A is stored in the j-th column of AB
!!          as follows:
!!          if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!          if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in AB; otherwise, AB is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!          and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFB      Optional (input or output) REAL or COMPLEX array, shape (:)
!!          with the same size as AB.
!!          If FACT = "F" then AFB is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_PBSVX.
!!          If FACT /= "F" then AFB is an output argument that contains
!!          the factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is supplied
!!          on entry, and if not, whether A should be equilibrated before
!!          it is factored.
!!            = "N": The matrix A will be copied to AFB and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to
!!                 AFB and factored.
!!            = "F": AFB contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)
!!          = size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!                is not positive definite, so the factorization could
!!                not be completed and the solution and error bounds
!!                could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!                machine precision, so the matrix is singular to
!!                working precision. Nevertheless, the solution and
!!                error bounds are computed because the computed solution
!!                can be more accurate than the value of RCOND would
!!                suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, SFERR, SBERR, KD
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A,1) < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, NRHS, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPBSVX_F95
 SUBROUTINE SPOSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, 1, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPOSV1_F95
 SUBROUTINE SPOSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_POSV computes the solution to a linear system of equations
!! A*X=B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices
!! or vectors. The Cholesky decomposition is used to factor A as
!! A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!         SUBROUTINE LA_POSV( A, B, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX square array, shape (:,:).
!!       On entry, the matrix A.
!!       If UPLO = "U", the upper triangular part of A contains the upper
!!       triangular part of the matrix A, and the strictly lower triangular
!!       part of A is not referenced. If UPLO = "L", the lower triangular
!!       part of A contains the lower triangular part of the matrix A, and
!!       the strictly upper triangular part of A is not referenced.
!!       On exit, the factor U or L from the Cholesky factorization
!!       A = U^H*U = L*L^H.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!       On entry, the matrix B.
!!       On exit, the solution matrix X.
!! UPLO  Optional (input) CHARACTER(LEN=1)
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!       Default value: "U".
!! INFO  Optional (output) INTEGER
!!       = 0: sauccessful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!          completed and the solution could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, NRHS, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPOSV_F95
SUBROUTINE SPOSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPOSVX1_F95
SUBROUTINE SPOSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!   LA_POSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors.
!!   LA_POSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_POSVX( A, B, X, UPLO=uplo, AF=af, FACT=fact, &
!!                          EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                          RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!            REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A or its equilibration:
!!          If UPLO = "U", then the upper triangular part of A contains
!!          the upper triangular part of (the equilibrated) A, and the
!!          strictly lower triangular part of A is not referenced.
!!          If UPLO = "L", then the lower triangular part of A contains
!!          the lower triangular part of (the equilibrated) A, and the
!!          strictly upper triangular part of A is not referenced.
!!          If FACT = "F" and EQUED = "Y", then A has been equilibrated
!!          by the scaling factors in S during a previous call to
!!          LA_POSVX.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in A; otherwise, A is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = size(A,1) or shape (:) with size(B) =
!!          size(A,1).
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!          size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!          = size(A,1).
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AF       Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as A.
!!          If FACT = "F" then AF is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_POSVX
!!          If FACT /= "F" then AF is an output argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is
!!          supplied on entry, and, if not, whether A should be
!!          equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored
!!                 (no equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)=
!!          size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j), FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the leading minor of order i of (the equilibrated)
!!                  A is not positive definite, so the factorization
!!                  could not be completed and the solution and error
!!                  bounds could not be computed. RCOND= 0 is returned.
!!              = n+1: U or L is nonsingular, but RCOND is less than
!!                  machine precision, so the matrix is singular to
!!                  working precision. Nevertheless, the solution and
!!                  error bounds are computed because the computed
!!                  solution can be more accurate than the value of
!!                    RCOND would suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:), LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPOSVX_F95
SUBROUTINE SPOTRF_F95( A, UPLO, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POTRF_F77 => LA_POTRF, LANSY_F77 => LA_LANSY, &    !!((07-B-INT_LAPACK1.f90))
                                  POCON_F77 => LA_POCON
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL  :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_POTRF computes the Cholesky factorization of a real symmetric or
!! complex Hermitian positive definite matrix A.
!
!! The factorization has the form
!!    A = U**H * U,  if UPLO = "U", or
!!    A = L * L**H,  if UPLO = "L",
!! where U is an upper triangular matrix and L is lower triangular.
!
!! This is the block version of the algorithm, calling Level 3 BLAS.
!
!! LA_POTRF optionally estimates the reciprocal of the condition number
!! (in the 1-norm) of a real symmetric or complex Hermitian positive
!! definite matrix A.
!! An estimate is obtained for norm(inv(A)), and the reciprocal of the
!! condition number is computed as RCOND = 1 / (norm(A) * norm(inv(A))).
!
!! =======
!
!!    SUBROUTINE LA_POTRF( A, UPLO, RCOND, NORM, INFO )
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the factor U or L from the Cholesky
!!            factorization A = U**H*U or A = L*L**H.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored;
!!            = "L":  Lower triangle of A is stored.
!!         otherwise UPLO = "U" is assumed.
!
!! RCOND   Optional (output) REAL
!!         The reciprocal of the condition number of the matrix A
!!         computed as RCOND = 1/(norm(A) * norm(inv(A))).
!! NORM    Optional (input) CHARACTER*1
!!         Specifies whether the 1-norm condition number or the
!!         infinity-norm condition number is required:
!!           If NORM is present then:
!!              = "1", "O" or "o": 1-norm;
!!              = "I" or "i": infinity-norm.
!!           otherwise NORM = "1" is used.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!            > 0: if INFO = i, the leading minor of order i is not
!!               positive definite, and the factorization could not be
!!               completed.
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! --------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LNORM, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, LD
   REAL(WP) :: ANORM
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .AND. N < 0 )THEN; LINFO = -1
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -2
   ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
            ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
              .AND. LNORM /= "1" ) ) THEN; LINFO = -4
   ELSE IF(  N > 0 )THEN
      IF( PRESENT(RCOND) ) THEN
!!     .. COMPUTE THE NORM OF THE MATRIX A
         ALLOCATE(WORK(N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN; ANORM = LANSY_F77( LNORM, LUPLO, LD, A, N, WORK )
         ELSE; LINFO = -100; END IF
         DEALLOCATE(WORK, STAT=ISTAT1)
      END IF
!
      IF( LINFO == 0 ) THEN
!!     .. COMPUTE THE CHOLESKY FACTORS OF THE MATRIX A
         CALL POTRF_F77( LUPLO, N, A, LD, LINFO )
!
         IF( PRESENT(RCOND) .AND. LINFO == 0 ) THEN
!!        .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
            IF( ANORM == 0.0_WP )THEN; RCOND = 0.0_WP
            ELSE; ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT)
               IF( ISTAT == 0 )THEN
                  CALL POCON_F77( LUPLO, N, A, LD, ANORM, RCOND, &
                                  WORK, IWORK, LINFO )
               ELSE; LINFO = -100; END IF
               DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
            END IF
         END IF
      END IF
   ELSE IF( PRESENT(RCOND) ) THEN; RCOND = 1.0_WP; ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SPOTRF_F95
 SUBROUTINE SPPSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, 1, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPPSV1_F95
 SUBROUTINE SPPSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: A(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PPSV computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format. The Cholesky decomposition is
!! used to factor A as
!!      A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSV( AP, B, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)
!!         = n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U or A = L*L^H , in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! UPLO    Optional, (input) CHARACTER(LEN=1)
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, NRHS, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPPSV_F95
SUBROUTINE SPPSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SAF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:)
   REAL(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPPSVX1_F95
SUBROUTINE SPPSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PPSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format.
!!     LA_PPSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                  FACT=fact, EQUED=equed, S=s, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!           CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!           REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX square array, shape (:) with
!!         size(AP) = n*(n + 1)=2, where n is a rank of the matrix A.
!!         On entry, the upper or lower triangle of matrix A, or its
!!         equilibration, in packed storage. The elements are stored
!!         columnwise as follows:
!!         if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, if FACT = "E", then the equilibrated version of A is
!!         stored in AP; otherwise, AP is unchanged.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the scaled version of B if the system has been
!!         equilibrated; otherwise, B is unchanged.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AFP     Optional (input or output) REAL or COMPLEX array, shape (:)
!!         with the same size as AP.
!!         If FACT = "F" then AFP is an input argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A, in the same storage format as A, returned by
!!         a previous call to LA_PPSVX.
!!         If FACT 6= "F" then AFP is an output argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A in the same storage format as A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A is supplied
!!         on entry, and, if not, whether A should be equilibrated before
!!         it is factored.
!!           = "N": The matrix A will be copied to AFP and factored
!!                (no equilibration).
!!           = "E": The matrix A will be equilibrated, then copied to AFP
!!                and factored.
!!           = "F": AFP contains the factored form of (the equilibrated) A.
!!         Default value: "N".
!! EQUED   Optional (input or output) CHARACTER(LEN=1).
!!         Specifies the form of equilibration that was done.
!!         EQUED is an input argument if FACT = "F", otherwise it is an
!!         output argument:
!!           = "N": No equilibration (always true if FACT = "N").
!!           = "Y": Equilibration, i.e., A has been premultiplied and
!!                postmultiplied by diag(S).
!!         Default value: "N".
!! S       Optional (input or output) REAL array, shape (:) with size(S)
!!         = size(A,1).
!!         The scaling factors for A.
!!         S is an input argument if FACT = "F" and EQUED = "Y".
!!         S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR    Optional (output) REAL array of shape (:), with size(FERR) =
!!         size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j) , FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of (the
!!         equilibrated) A. If RCOND is less than the machine precision,
!!         the matrix is singular to working precision. This condition is
!!         indicated by a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!               is not positive definite, so the factorization could
!!               not be completed and the solution and error bounds
!!               could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!               machine precision, so the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!               error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SAF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:)
   REAL(WP),  POINTER :: LS(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(3*N), IWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPPSVX_F95
 SUBROUTINE SPTSV1_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    REAL(WP), INTENT(INOUT) :: E(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, 1, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPTSV1_F95
 SUBROUTINE SPTSV_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    REAL(WP), INTENT(INOUT) :: E(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSV computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. A is factored as A = L*D*L^H, where L
!! is a unit lower bidiagonal matrix and D is a diagonal matrix. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!        SUBROUTINE LA_PTSV( D, E, B, INFO=info )
!!            REAL(<wp>), INTENT(INOUT) :: D(:)
!!            <type>(<wp>), INTENT(INOUT) :: E(:), <rhs>
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal of A.
!!        On exit, the diagonal of D.
!! E      (input/output) REAL or COMPLEX array, shape (:), with
!!        size(E) = n-1.
!!        On entry, the subdiagonal of A.
!!        On exit, the subdiagonal of L.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, the leading minor of order i of A is not
!!             positive definite, and the solution has not been computed.
!!           The factorization has not been completed unless i = n.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, NRHS, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE SPTSV_F95
SUBROUTINE SPTSVX1_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   REAL(WP), INTENT(IN) :: E(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SDF, SEF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: LDF(:)
   REAL(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -3
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, 1, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPTSVX1_F95
SUBROUTINE SPTSVX_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   REAL(WP), INTENT(IN) :: E(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSVX computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors.
!!    LA_PTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_PTSVX( D, E, B, X, DF=df, EF=ef, FACT=fact, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, INFO=info )
!!          REAL(<wp>), INTENT(IN) :: D(:)
!!          <type>(<wp>), INTENT(IN) :: E(:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: DF(:)
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: EF(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! D       (input) REAL array, shape (:) with size(D) = n, where n is the
!!         order of A.
!!         The diagonal of A.
!! E       (input) REAL or COMPLEX array, shape (:) with size(E) = n-1.
!!         The subdiagonal of A.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) = n
!!         or shape (:) with size(B) = n.
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! DF      Optional (input or output) REAL array, shape (:) with the same
!!         size as D.
!!         If FACT = "F", then DF is an input argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!!         If FACT = "N", then DF is an output argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!! EF      Optional (input or output) REAL or COMPLEX array, shape (:) with
!!         the same size as E.
!!         If FACT = "F", then EF is an input argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!!         If FACT = "N", then EF is an output argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of A has been supplied on
!!         entry.
!!           = "N": The matrix A will be copied to DF and EF and factored.
!!           = "F": DF and EF contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j), FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element in
!!         X(j).
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL.
!!         The estimate of the reciprocal condition number of the matrix
!!         A. If RCOND is less than the machine precision, the matrix is
!!         singular to working precision. This condition is indicated by
!!         a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of A is not positive
!!                definite, so the factorization could not be completed
!!                unless i = n, and the solution and error bounds could
!!                not be computed. RCOND = 0 is returned.
!!             = n+1: L is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error
!!                  bounds are computed because the computed solution can
!!                  be more accurate than the value of RCOND would suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SDF, SEF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: LDF(:), LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -3
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, NRHS, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SPTSVX_F95
SUBROUTINE SSBEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBEV_F77 => LA_SBEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SBEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
            CALL SBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LINFO )
         ELSE
            CALL SBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBEV_F95
SUBROUTINE SSBEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBEVD_F77 => LA_SBEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1)); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, 2*N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1 + 5*N + 2*N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N ); LIWORK = 1
         ELSE; LWORK = 1 + 5*N + 2*N**2; LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
          CALL SBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
        ELSE
          CALL SBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
        ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBEVD_F95
SUBROUTINE SSBEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: SBEVX_F77 => LA_SBEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBEVX / LA_HBEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! band matrix A. Eigenvalues and eigenvectors can be selected by
!! specifying either a range of values or a range of indices for the
!! desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SBEVX / LA_HBEVX( AB, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 Q=q, ABSTOL=abstol, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!            INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!            INTEGER, INTENT(OUT), OPTIONAL :: M
!!            INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL j COMPLEX
!!            <wp> ::= KIND(1.0) j KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!        of subdiagonals or superdiagonals in the band and n is the order
!!        of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U" the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U" : Upper triangle of A is stored;
!!        = "L" : Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        the matrix A corresponding to the selected eigenvalues, with the
!!        i-th column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). If an eigenvector fails to converge, then
!!        that column of Z contains the latest approximation to the
!!        eigenvector, and the index of the eigenvector is returned in
!!        IFAIL.
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in
!!        advance, an upper bound must be used. In all cases M<=n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0<=M<=size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) = n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional (output) REAL or COMPLEX square array, shape(:,:) with
!!        size(Q,1) = n.
!!        The n by n unitary matrix used in the reduction to tridiagonal
!!        form. This is computed only if Z is present.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|, |b|),
!!        where <wp> is the working precision. If ABSTOL<=0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing A to tridiagonal form. Eigenvalues will be computed most
!!        accurately when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, S1Q, S2Q, KD
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1), LLQ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:), LQ(:,:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1 ) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
         IF( ISTAT == 0 )THEN
            IF( PRESENT(Q) )THEN; LQ => Q
            ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
         END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,7*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
               CALL SBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                IWORK, LIFAIL, LINFO )
            ELSE
               CALL SBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBEVX_F95
SUBROUTINE SSBGV_F95( A, B, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBGV_F77 => LA_SBGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SBGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KA, KB, &
              LDA, LDB
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KA = SIZE(A,1)-1; N = SIZE(A,2); LDA = MAX(SIZE(A,1),1)
   ISTAT = 0; KB = SIZE(B,1)-1; LDB = MAX(SIZE(B,1),1)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( KB < 0 .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
            CALL SBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, Z, S1Z, &
                        WORK, LINFO )
         ELSE
            CALL SBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, LLZ, S1Z, &
                        WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBGV_F95
SUBROUTINE SSBGVD_F95( AB, BB, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP =>  SP                                     !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SBGVD_F77 => LA_SBGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KAB, KBB, &
          LDAB, LDBB, LWORK, LIWORK, IWORKMIN(1)
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; KAB = SIZE(AB,1)-1; N = SIZE(AB,2); LDAB = MAX(SIZE(AB,1),1)
      ISTAT = 0; KBB = SIZE(BB,1)-1; LDBB = MAX(SIZE(BB,1),1)
      IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
      ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
        IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
          IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
          ELSE IF( KBB < 0 .OR. SIZE(BB,2) /= N ) THEN; LINFO = -2
          ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
          ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
          ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
          ELSE IF( N > 0 )THEN
            LIWORK = -1
            LWORK = -1
            IF (PRESENT (Z)) THEN
               CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &               LDBB, W, Z, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            ELSE
             CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &               LDBB, W, LLZ, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            ENDIF
            LWORK = WORKMIN(1)
             LIWORK = IWORKMIN(1)
            ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
            IF (PRESENT (Z)) THEN
                CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &            LDBB, W, Z, S1Z,  WORK, LWORK, IWORK, LIWORK, LINFO )
            ELSE
                CALL SBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &            LDBB, W, LLZ, S1Z,  WORK, LWORK, IWORK, LIWORK, LINFO )
            ENDIF
              ELSE; LINFO = -100; ENDIF
                DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
              ENDIF
              CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBGVD_F95
SUBROUTINE SSBGVX_F95( AB, BB,  W, UPLO, Z, VL, VU, IL, IU, &
      &         M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  SP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SBGVX_F77 => LA_SBGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
      REAL(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBGVX and LA_HBGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of the generalized eigenvalue problem
!!                      A*z = lambda*B*z,
!! where A and B are real symmetric in the case of LA_SBGVX and complex
!! Hermitian in the case of LA_HBGVX. In both cases B is positive
!! definite. Matrices A and B are stored in a band format. Eigenvalues
!! and eigenvectors can be selected by specifying either a range of
!! values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_SBGVX / LA_HBGVX( AB, BB, W, UPLO=uplo, Z=z, &
!!                   VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, Q=q, &
!!                   ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!        of subdiagonals or superdiagonals in the band of A and n is
!!        the order of A and B.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of A in band storage. The ka + 1 diagonals of A are
!!        stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                   1<=j<=n.
!!        On exit, the contents of AB are destroyed.
!! BB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!        of subdiagonals or superdiagonals in the band of B.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix B in band storage. The kb + 1 diagonals of
!!        B are stored in the rows of BB so that the j-th column of B
!!        is stored in the j-th column of BB as follows:
!!        if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                   1<=j<=n.
!!        On exit, the factor S from the split Cholesky factorization
!!                     B = S^H*S.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangles of A and B are stored;
!!            = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!        with size(Z,1) = n.
!!        The first M columns of Z contain the orthonormal eigenvectors
!!        corresponding to the selected eigenvalues, with the i-th
!!        column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). The eigenvectors are normalized so that
!!        Z^H*B*Z = I . If an eigenvector fails to converge, then that
!!        column of Z contains the latest approximation to the
!!        eigenvector and the index of the eigenvector is returned in
!!        IFAIL.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL)=n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional, (Output) REAL or COMPLEX square array, shape(:,:)
!!        with size(Q,1) = n.
!!        If Z is present, the matrix used in the reduction of
!!        A*z = lambda*B*z to tridiagonal form.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An
!!        approximate eigenvalue is accepted as converged when it is
!!        determined to lie in an interval [a,b] of width less than or
!!        equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal
!!        form. Eigenvalues will be computed most accurately when ABSTOL
!!        is set to twice the underflow threshold
!!                   2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i,
!!             then i eigenvectors failed to converge. Their indices
!!             are stored in array IFAIL.
!!           > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!             minor of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!        If INFO is not present and an error occurs, then the program
!!        is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SBGVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDAB, LDBB, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, S1Q, S2Q, KAB, KBB
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP), TARGET :: LLZ(1,1), LLQ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:), LQ(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KAB = SIZE(AB,1)-1; KBB = SIZE(BB,1)-1
   N = SIZE(AB,2); LDAB = MAX(1,SIZE(AB,1))
   LDBB = MAX(1, SIZE(BB,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
      ELSE; LRANGE = "A" ; END IF

      IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE  IF (KBB < 0) THEN; LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
      ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
      ELSE IF( LVU < LVL )THEN; LINFO = -6
      ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &    (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
      ELSE IF( LRANGE == "I" .AND. ( LIU.LT.MIN( N, LIL ) .OR. LIU.GT.N)) THEN; LINFO = -8
      ELSE IF( N < LIU )THEN; LINFO = -9
      ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
      ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
      ELSE IF( N > 0 )THEN
          IF( PRESENT(Z) ) THEN; LJOBZ = "V"
            IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
            ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
            IF( ISTAT == 0 )THEN
              IF( PRESENT(Q) )THEN; LQ => Q
              ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
            END IF
          ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!! .. DETERMINE THE WORKSPACE
          IF( ISTAT == 0 ) THEN
            ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,7*N)), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
              ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
               IF (PRESENT (Z))  THEN
                CALL SBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z,&
     &            S1Z, WORK, IWORK, LIFAIL, LINFO )
               ELSE
                CALL SBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, LLZ,&
     &            S1Z, WORK, IWORK, LIFAIL, LINFO )
               ENDIF
                  IF( PRESENT(M) ) M = LM
                ELSE; LINFO = -100; END IF
                END IF
        IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
        IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
        DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSBGVX_F95


SUBROUTINE SSPEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPEV_F77 => LA_SPEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
          CALL SPEV_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LINFO )
         ELSE
          CALL SPEV_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPEV_F95
SUBROUTINE SSPEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPEVD_F77 => LA_SPEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LIWORK
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, 2*N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1+ 6*N+N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N ); LIWORK = 1
         ELSE
            LWORK = 1+ 6*N+N**2
            LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
           CALL SPEVD_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ELSE
           CALL SPEVD_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPEVD_F95
SUBROUTINE SSPEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: SPEVX_F77 => LA_SPEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   REAL(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SPEVX / LA_HPEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex hermitian
!! matrix A in packed storage. Eigenvalues and eigenvectors can be
!! selected by specifying either a range of values or a range of indices
!! for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SPEVX / LA_HPEVX( AP, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 ABSTOL=abstol, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!!  AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n+1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!          On exit, AP is overwritten by values generated during the
!!          reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!          diagonal and first superdiagonal of T overwrite the correspond-
!!          ing diagonals of A. If UPLO = "L", the diagonal and first
!!          subdiagonal of T overwrite the corresponding diagonals of A.
!!  W       (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!!  UPLO    Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors of
!!          the matrix A corresponding to the selected eigenvalues, with the
!!          i-th column of Z containing the eigenvector associated with
!!          the eigenvalue in W(i) . If an eigenvector fails to converge,
!!          then that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are supplied
!!          in the array Z. When the exact value of M is not known in
!!          advance, an upper bound must be used. In all cases M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th
!!          eigenvalues will be found. 1<=IL<=IU<=size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0<=M<=size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL+EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL<=0, then
!!          EPSILON(1.0_<wp>)*||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing A to tridiagonal form. Eigenvalues will be computed
!!          most accurately when ABSTOL is set to twice the underflow
!!          threshold 2*LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2*LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!          indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPEVX"
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, NN
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &      (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N > 0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
               CALL SPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                  LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                  IWORK, LIFAIL, LINFO )
            ELSE
               CALL SPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                  LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                  IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPEVX_F95
SUBROUTINE SSPGV_F95( A, B, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPGV_F77 => LA_SPGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP), POINTER :: WORK(:)
   COMPLEX(WP) :: WW
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= SIZE(A)  )THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
           CALL SPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, Z, S1Z, &
                        WORK, LINFO )
         ELSE
           CALL SPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, LLZ, S1Z, &
                        WORK, LINFO )
        ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPGV_F95
SUBROUTINE SSPGVD_F95( AP, BP, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPGVD_F77 => LA_SPGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: AP(:), BP(:)
   REAL(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) ::  LJOBZ, LUPLO
      INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, S1Z, S2Z
      INTEGER :: LWORK, LIWORK
!!  .. LOCAL ARRAYS ..
      REAL(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      REAL(WP), POINTER :: WORK(:)
      INTEGER :: IWORKMIN(1)
      COMPLEX(WP) :: WW
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; NN = SIZE(AP)
      WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
      IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
        IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
        ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
          IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
            IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
            ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
            ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
            ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
            ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
            ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
            ELSE IF( N > 0 )THEN
!!  QUERING THE SIZE OF WORKSPACE ...
                LWORK = -1
                LIWORK = -1
                IF (PRESENT (Z)) THEN
                   CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                Z, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
                ELSE
                   CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                LLZ, S1Z, WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
                ENDIF
                LWORK = WORKMIN(1)
                LIWORK= IWORKMIN(1)
                ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
                IF( ISTAT == 0 )THEN
                  IF (PRESENT(Z)) THEN
                     CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                    Z, S1Z, WORK, LWORK, IWORK, LIWORK, LINFO )
                  ELSE
                     CALL SPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                    LLZ, S1Z, WORK, LWORK, IWORK, LIWORK, LINFO )
                  ENDIF
                ELSE; LINFO = -100; ENDIF
                ENDIF
                DEALLOCATE(WORK, IWORK, STAT=ISTAT)
                CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPGVD_F95


SUBROUTINE SSPGVX_F95( AP, BP, W, ITYPE, UPLO, Z, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SPGVX_F77 => LA_SPGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      REAL(WP), INTENT(INOUT) :: AP(:), BP(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPGVX and LA_HPGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!       A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SPGVX and complex
!! Hermitian in the case of LA_HPGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues. Matrices A and B are stored in a packed format.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGVX / LA_HPGVX( AP, BP, W, ITYPE= itype, &
!!             UPLO= uplo, Z= z, VL= vl, VU= vu, IL= il, IU= iu, M= m, &
!!             IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!         <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!         REAL(<wp>), INTENT(OUT) :: W(:)
!!         INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!         INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!         INTEGER, INTENT(OUT), OPTIONAL :: M
!!         INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^T*U or B = L*L^T, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX rectangular array, shape
!!          (:,:) with size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          corresponding to the selected eigenvalues, with the i-th
!!          column of Z holding the eigenvector associated with the
!!          eigenvalue in W(i). The eigenvectors are normalized as
!!          follows:
!!            if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!            if ITYPE = 3: Z^H * B^-1 * Z = I .
!!          If an eigenvector fails to converge, then that column of Z
!!          contains the latest approximation to the eigenvector and the
!!          index of the eigenvector is returned in IFAIL.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!          size(A,1).
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing the generalized eigenvalue problem to tridiagonal
!!          form. Eigenvalues will be computed most accurately when
!!          ABSTOL is set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with 0 < INFO <= n, then some
!!          eigenvectors did not converge.
!!          Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!          > 0: the algorithm failed to converge or matrix B is not
!!            positive definite:
!!             <= n: the algorithm failed to converge; if INFO = i, then
!!              i eigenvectors failed to converge. Their indices are
!!              stored in array IFAIL.
!!             > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!              minor of order i of B is not positive definite. The
!!              factorization of B could not be completed and no
!!                eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPGVX"
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
      INTEGER :: N, LINFO, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, NN, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
      COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(AP)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
   ELSE ; LRANGE = "A"; END IF

   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF (LITYPE <1 .OR. LITYPE >3) THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &  (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE,"I") .AND. ( LIU < MIN(N, LIL) .OR. LIU > N ))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
        IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
        ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
        ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
       IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
           IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
           ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
             IF (PRESENT (Z)) THEN
                  CALL SPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &              LVU, LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, IWORK, LIFAIL, &
     &              LINFO )
             ELSE
                  CALL SPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &              LVU, LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, IWORK, LIFAIL, &
     &              LINFO )
             ENDIF
             IF( PRESENT(M) ) M = LM
           ELSE; LINFO = -100; END IF
           END IF
           IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
           DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
         END IF
         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSPGVX_F95
 SUBROUTINE SSPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SSPSV1_F95
 SUBROUTINE SSPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SSPSV_F95
SUBROUTINE SSPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), IWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SSPSVX1_F95
SUBROUTINE SSPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), IWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SSPSVX_F95
SUBROUTINE SSTEV_F95( D, E, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEV_F77 => LA_STEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEV and LA_STEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric tridiagonal matrix A.
!!    LA_STEVD uses a divide and conquer algorithm. If eigenvectors are
!! desired, they can be much faster than LA_STEV for large matrices but
!! uses more workspace.
!! =========
!!
!!      SUBROUTINE LA_STEV / LA_STEVD( D, E, Z=z, INFO=info )
!!         REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D    (input/output) REAL array shape (:) with size(D) = n, where n is
!!      the order of A.
!!      On entry, the diagonal elements of the matrix A.
!!      On exit, the eigenvalues in ascending order.
!! E    (input/output) REAL array, shape (:) with size(E) = n.
!!      On entry, the n - 1 subdiagonal elements of A in E(1) to E(n-1).
!!      E(n) need not be set but is used by the routine.
!!      On exit, the contents of E are destroyed.
!! Z    Optional (output) REAL square array, shape(:,:) with size(Z,1)=n.
!!      The columns of Z contain the orthonormal eigenvectors of A in the
!!      order of the eigenvalues.
!! INFO Optional (output) INTEGER.
!!      = 0: successful exit.
!!      < 0: if INFO = -i, the i-th argument had an illegal value.
!!      > 0: if INFO = i, then i elements of E did not converge to zero.
!!      If INFO is not present and an error occurs, then the program is
!!      terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_STEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1), LLWORK(1)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N>0 ) THEN; LINFO = -2
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) .AND. N>0)THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
    IF( ISTAT == 0 ) THEN
       IF( PRESENT(Z) )THEN
         ALLOCATE(WORK(MAX(1,2*N-2)), STAT=ISTAT)
         CALL STEV_F77( LJOBZ, N, D, E, Z, S1Z, WORK, LINFO )
       ELSE
         CALL STEV_F77( LJOBZ, N, D, E, LLZ, S1Z, LLWORK, LINFO )
       ENDIF
      ELSE; LINFO = -100; ENDIF
      IF( PRESENT(Z) ) DEALLOCATE(WORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSTEV_F95
SUBROUTINE SSTEVD_F95( D, E, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEVD_F77 => LA_STEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEV and LA_STEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric tridiagonal matrix A.
!!    LA_STEVD uses a divide and conquer algorithm. If eigenvectors are
!! desired, they can be much faster than LA_STEV for large matrices but
!! uses more workspace.
!! =========
!!
!!      SUBROUTINE LA_STEV / LA_STEVD( D, E, Z=z, INFO=info )
!!         REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D    (input/output) REAL array shape (:) with size(D) = n, where n is
!!      the order of A.
!!      On entry, the diagonal elements of the matrix A.
!!      On exit, the eigenvalues in ascending order.
!! E    (input/output) REAL array, shape (:) with size(E) = n.
!!      On entry, the n - 1 subdiagonal elements of A in E(1) to E(n-1).
!!      E(n) need not be set but is used by the routine.
!!      On exit, the contents of E are destroyed.
!! Z    Optional (output) REAL square array, shape(:,:) with size(Z,1)=n.
!!      The columns of Z contain the orthonormal eigenvectors of A in the
!!      order of the eigenvalues.
!! INFO Optional (output) INTEGER.
!!      = 0: successful exit.
!!      < 0: if INFO = -i, the i-th argument had an illegal value.
!!      > 0: if INFO = i, then i elements of E did not converge to zero.
!!      If INFO is not present and an error occurs, then the program is
!!      terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ
   INTEGER :: N, LD, ISTAT1, S1Z, S2Z, LWORK, LIWORK
   INTEGER :: LINFO, ISTAT
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0
!!  .. LOCAL ARRAYS ..
   REAL(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N > 0 )THEN; LINFO = -2
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, LWORKN ); LIWORK = MAX( 1, LIWORKN )
      ELSE
         LWORK = MAX( 1+ 4*N + N**2, LWORKV )
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = 1; LIWORK = 1
         ELSE
           LWORK = 1+ 4*N + N**2
           LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
            CALL STEVD_F77( LJOBZ, N, D, E, Z, S1Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ELSE
            CALL STEVD_F77( LJOBZ, N, D, E, LLZ, S1Z, WORK, LWORK, &
                         IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK,IWORK,STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSTEVD_F95
SUBROUTINE SSTEVR_F95( D, E, W, Z, VL, VU, IL, IU, M, ISUPPZ, &
     &    ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: STEVR_F77 => LA_STEVR, LAMCH_F77 => SLAMCH      !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      REAL(WP), INTENT(INOUT) :: D(:), E(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!       LA_STEVR computes selected eigenvalues and, optionally, the
!! corresponding eigenvectors of a real symmetric tridiagonal matrix A.
!! Eigenvalues and eigenvectors can be selected by specifying either a
!! range of values or a range of indices for the desired eigenvalues.
!!       LA_STEVR uses a relatively robust representation (RRR) algorithm.
!! It is usually the fastest algorithm of all and uses the least
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_STEVR ( D, E, W, Z=z, VL=vl, VU=vu, &
!!                         IL=il, IU=iu, M=m, ISUPPZ=isuppz, &
!!                         ABSTOL=abstol, INFO=info )
!!                 REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!                 REAL(<wp>), INTENT(OUT) :: W(:)
!!                 REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!                 INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!                 REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!                 INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!                 INTEGER, INTENT(OUT), OPTIONAL :: M
!!                 REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!                 INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!                 <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal elements of the matrix A.
!!        On exit, the original contents of D possibly multiplied by a
!!        constant factor to avoid over/underflow in computing the
!!        eigenvalues.
!! E      (input/output) REAL array, shape (:) with size(E) = n.
!!        On entry, the n-1 subdiagonal elements of A in E(1) to E(n-1) .
!!        E(n) need not be set.
!!        On exit, the original contents of E possibly multiplied by a
!!        constant factor to avoid over/underflow in computing the
!!        eigenvalues.
!! W      (output) REAL array with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        A corresponding to the selected eigenvalues, with the i-th column
!!        of Z containing the eigenvector associated with the eigenvalue in
!!        W(i).
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in advance,
!!        an upper bound must be used. In all cases M <= n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= n.
!!        Default values: IL = 1 and IU = n.
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <=  n.
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! ISUPPZ Optional (output) INTEGER array, shape (:) with
!!        size(ISUPPZ) = 2*max(1,M).
!!        The support of the eigenvectors in A, i.e., the indices
!!        indicating the nonzero elements. The i-th eigenvector is nonzero
!!        only in elements ISUPPZ(2*i-1) through ISUPPZ(2*i).
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a, b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)*||A||1 will be used in its place. Eigenvalues
!!        will be computed most accurately if ABSTOL is set to
!!        LA_LAMCH( 1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: an internal error occurred.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LRANGE
      INTEGER :: N, LD, LIL, LIU, LM, SISUPPZ, S1Z, S2Z, NN
      INTEGER :: LINFO, ISTAT, LWORK, LIWORK
      REAL(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER:: IWORKMIN(1), DUMMY(1)
      REAL(WP), TARGET :: WORKMIN(1)
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   NN=2*MAX(1,N)
   IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N/=0)THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= MAX(1,N) ) )THEN; LINFO = -4
   ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND..NOT.PRESENT(Z) )THEN; LINFO = -5
   ELSE IF( LVU < LVL .AND. N>0)THEN; LINFO = -6
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
   ELSE IF (((LIU<LIL) .OR. (LIL<1)) .AND. (N>0))THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( N > 0 )THEN
     IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
     ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
     ELSE; LRANGE = "A"; LM = N; END IF
       IF( PRESENT(Z) ) THEN; LJOBZ = "V"
       ELSE; LJOBZ = "N"
       ENDIF
!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
       LWORK = -1
       LIWORK = -1
       IF (PRESENT(Z)) THEN
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E,  LVL, LVU, &
     &       LIL, LIU, LABSTOL, LM, W, Z, S1Z, DUMMY, &
     &       WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
       ELSE
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E,  LVL, LVU, &
     &       LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, DUMMY, &
     &       WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
       ENDIF
       LWORK = WORKMIN(1)
       LIWORK = IWORKMIN(1)

       ALLOCATE(IWORK(LIWORK), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 100; ENDIF

       ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 200; ENDIF

       ALLOCATE(WORK(LWORK), STAT=ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

       IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
       ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF

       IF (PRESENT (Z)) THEN
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
     &     LABSTOL, LM, W, Z, S1Z, LISUPPZ, WORK, LWORK, &
     &     IWORK, LIWORK, LINFO )
       ELSE
         CALL STEVR_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
     &     LABSTOL, LM, W, LLZ, S1Z, LISUPPZ, WORK, LWORK, &
     &     IWORK, LIWORK, LINFO )
       ENDIF

       IF( PRESENT(M) ) M = LM

       DEALLOCATE(WORK)
300    DEALLOCATE(LISUPPZ)
200    DEALLOCATE(IWORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSTEVR_F95
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_STEVX computes selected eigenvalues and, optionally, the
!! corresponding eigenvectors of a real symmetric tridiagonal matrix A.
!! Eigenvalues and eigenvectors can be selected by specifying either a
!! range of values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_STEVX( D, E, W, Z=z, VL=vl, VU=vu, &
!!                         IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                         ABSTOL=abstol, INFO=info )
!!             REAL(<wp>), INTENT(INOUT) :: D(:), E(:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!             INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!             INTEGER, INTENT(OUT), OPTIONAL :: M
!!             INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! D        (input/output) REAL array, shape (:) with size(D) = n, where n
!!          is the order of A.
!!          On entry, the diagonal elements of the matrix A.
!!          On exit, the original contents of D possibly multiplied by a
!!          constant factor to avoid over/underflow in computing the
!!          eigenvalues.
!! E        (input/output) REAL array, shape (:) with size(E) = n.
!!          On entry, the n-1 subdiagonal elements of A in E(1) to E(n-1).
!!          E(n) need not be set.
!!          On exit, the original contents of E possibly multiplied by a
!!          constant factor to avoid over/underflow in computing the
!!          eigenvalues.
!! W        (output) REAL array with size(W) = n.
!!          The first M elements contain the selected eigenvalues in
!!          ascending order.
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          of A corresponding to the selected eigenvalues, with the i-th
!!          column of Z containing the eigenvector associated with the
!!          eigenvalue in W(i) . If an eigenvector fails to converge, then
!!          that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are
!!          supplied in the array Z. When the exact value of M is not
!!          known in advance, an upper bound must be used. In all cases
!!          M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= n.
!!          Default values: IL = 1 and IU = n.
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= n.
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||A||1 will be used in its place.
!!          Eigenvalues will be computed most accurately when ABSTOL is
!!          set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge.
!!             Their indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
SUBROUTINE SSTEVX_F95( D, E, W, Z, VL, VU, IL, IU, M, &
                            IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: STEVX_F77 => LA_STEVX, LAMCH_F77 => SLAMCH         !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   REAL(WP), INTENT(INOUT) :: D(:), E(:)
   REAL(WP), INTENT(OUT) :: W(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_STEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LRANGE
   INTEGER :: N, LD, LIL, LIU, LM, SIFAIL, S1Z, S2Z
   INTEGER :: LINFO, ISTAT
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D); LD = MAX(1,N)
   IF( PRESENT(M)) M = 0
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N .AND. N > 0 )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &         (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"
      LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(5*N), WORK(5*N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT(Z)) THEN
               CALL STEVX_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
                            LABSTOL, LM, W, Z, S1Z, WORK, IWORK, LIFAIL, LINFO )
            ELSE
               CALL STEVX_F77( LJOBZ, LRANGE, N, D, E, LVL, LVU, LIL, LIU, &
                            LABSTOL, LM, W, LLZ, S1Z, WORK, IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSTEVX_F95
SUBROUTINE SSYEV_F95( A, W, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEV_F77 => LA_SYEV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYEV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LWORK, NB
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; ISTAT = 0; LD = MAX(1,N)
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
     LWORK = (2+NB)*N
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         LWORK = 3*N-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
         CALL SYEV_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, LINFO )
      ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYEV_F95
SUBROUTINE SSYEVD_F95( A, W, JOBZ, UPLO, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEVD_F77 => LA_SYEVD, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LIWORK, LMWORK, LWORK, NB
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      IF( LSAME(LJOBZ,"V") )THEN
         LMWORK = 1+6*N+2*N**2
         LIWORK = 3+5*N
      ELSE
         LMWORK = 2*N+1
         LIWORK = 1
      END IF
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
      LWORK = MAX( LMWORK, (NB+2)*N )
      ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
         LWORK = LMWORK
         ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, &
                         IWORK, LIWORK,  LINFO )
      ENDIF
      DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYEVD_F95
SUBROUTINE  SSYEVR_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, M, ISUPPZ, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: SYEVR_F77 => LA_SYEVR                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_SYEVR / LA_HEEVR compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!       LA_SYEVR and LA_HEEVR use a relatively robust representation
!! (RRR) algorithm. It is usually the fastest algorithm of all and uses
!! the least workspace.
!!
!! ========
!!
!!        SUBROUTINE LA SYEVR / LA HEEVR( A, W, JOBZ=jobz, &
!!                 UPLO=uplo, VL=vl, VU=vu, IL=il, IU=iu, M=m, &
!!                 ISUPPZ= isuppz, ABSTOL=abstol, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!           INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!           INTEGER, INTENT(OUT), OPTIONAL :: M
!!           INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A.
!!         On exit:
!!         If JOBZ = "V", then the first M columns of A contain the
!!         orthonormal eigenvectors of the matrix A corresponding to the
!!         selected eigenvalues, with the i-th column of A containing the
!!         eigenvector associated with the eigenvalue in W(i).
!!         If JOBZ = "N", the upper triangle (if UPLO = "U") or the lower
!!         triangle (if UPLO = "L") of A, including the diagonal, is
!!         destroyed.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The first M elements contain the selected eigenvalues in
!!         ascending order.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!         = "N": Computes eigenvalues only;
!!         = "V": Computes eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! VL,VU   Optional (input) REAL.
!!         The lower and upper bounds of the interval to be searched for
!!         eigenvalues. VL < VU.
!!         Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0).
!!         Note: Neither VL nor VU may be present if IL and/or IU is
!!         present.
!! IL,IU   Optional (input) INTEGER.
!!         The indices of the smallest and largest eigenvalues to be
!!         returned. The IL-th through IU-th eigenvalues will be found.
!!            1 <= IL <= IU <= size(A,1).
!!         Default values: IL = 1 and IU = size(A,1).
!!         Note: Neither IL nor IU may be present if VL and/or VU is
!!         present.
!!         Note: All eigenvalues are calculated if none of the arguments
!!         VL, VU, IL and IU are present.
!! M       Optional (output) INTEGER.
!!         The total number of eigenvalues found. 0 <= M <= size(A,1).
!!         Note: If IL and IU are present then M = IU-IL+1.
!! ISUPPZ  Optional (output) INTEGER array, shape (:) with
!!         size(ISUPPZ) = 2*max(1,M).
!!         The support of the eigenvectors in A, i.e., the indices
!!         indicating the nonzero elements. The i-th eigenvector is
!!         nonzero only in elements ISUPPZ(2i-1) through ISUPPZ(2i) .
!!         Note: ISUPPZ must be absent if JOBZ = "N".
!! ABSTOL  Optional (input) REAL.
!!         The absolute error tolerance for the eigenvalues. An
!!         approximate eigenvalue is accepted as converged when it is
!!         determined to lie in an interval [a, b] of width less than or
!!         equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!         where <wp> is the working precision. If ABSTOL <= 0, then
!!         EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!         ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!         reducing A to tridiagonal form.
!!         Default value: 0.0_<wp>.
!!         Note: Eigenvalues are computed most accurately if ABSTOL is set
!!         to LA_LAMCH(1.0_<wp>,"Safe minimum"), not zero.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
     &  LIWORK, SISUPPZ, NN
      INTEGER:: IWORKMIN(1)
      REAL(WP) :: WORKMIN(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      REAL(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
      N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
      NN=2*MAX(1,N)
      IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
      IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
      IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U";  END IF
      IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL);  ENDIF
      IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
      IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
      IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS ..
        IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
        ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
        ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN; LINFO = -3
        ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
        ELSE IF( LVU < LVL )THEN; LINFO = -5
        ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. (PRESENT(IL) .OR. PRESENT(IU)) )THEN
          LINFO = -6
        ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0)THEN; LINFO = -7
        ELSE IF( N < LIU )THEN; LINFO = -8
        ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND.LSAME(LJOBZ,"N"))THEN; LINFO = -10
        ELSE IF( N > 0 )THEN
          IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
            LRANGE = "V"; LM = N
          ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
            LRANGE = "I"; LM = LIU-LIL+1
          ELSE
            LRANGE = "A"; LM = N
          END IF
          IF ( LSAME(LJOBZ,"V") ) THEN
              LDZ=N; LZ=LM
          ELSE
              LDZ=1; LZ=1
          ENDIF
          ALLOCATE (Z(LDZ,LZ), STAT=ISTAT)
!!  .. QUERING THE SIZE OF WORKSPACE ..
            LWORK = -1
            LIWORK = -1
              CALL SYEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &            LIL, LIU, LABSTOL, LM, W, Z, LDZ, IWORKMIN, &
     &            WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )
            LWORK = WORKMIN(1)
            LIWORK = IWORKMIN(1)
            DEALLOCATE(Z)

            ALLOCATE(IWORK(LIWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 100; ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 200; ENDIF

            ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
            IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

            ALLOCATE(Z(LDZ, LZ), STAT = ISTAT)
            IF(ISTAT /= 0) THEN; LINFO = -100; GOTO 400; ENDIF

            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL; ELSE
!!              LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
              LABSTOL = 0.0_WP;  ENDIF
!! .. CALL LAPACK77 ROUTINE ..
              CALL SYEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &          LIL, LIU, LABSTOL, LM, W, Z, LDZ, LISUPPZ, &
     &          WORK, LWORK, IWORK, LIWORK, LINFO )

              IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
              IF( PRESENT(M) ) M = LM
              IF(PRESENT(ISUPPZ)) ISUPPZ = LISUPPZ

              DEALLOCATE(Z)
400           DEALLOCATE(LISUPPZ)
300           DEALLOCATE(WORK)
200           DEALLOCATE(IWORK)
         ENDIF
100         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYEVR_F95
SUBROUTINE SSYEVX_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYEVX_F77 => LA_SYEVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEVX / LA_HEEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!         SUBROUTINE LA_SYEVX / LA_HEEVX ( A, W, JOBZ=jobz, UPLO=uplo, &
!!                        VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                        ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the first M columns of A contain the
!!        orthonormal eigenvectors of the matrix A corresponding to the
!!        selected eigenvalues, with the i-th column of A containing the
!!        eigenvector associated with the eigenvalue in W(i) . If an
!!        eigenvector fails to converge, then that column of A contains the
!!        latest approximation to the eigenvector and the index of the
!!        eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU-IL+1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: IFAIL must be absent if JOBZ = "N".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL<= 0, then
!!        EPSILON(1.0_<wp>)*||T||1 will be used in its place, where ||T||1
!!        is the l1 norm of the tridiagonal matrix obtained by reducing A
!!        to tridiagonal form. Eigenvalues will be computed most accurately
!!        when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYEVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
              SIFAIL
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   REAL(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
   IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(M)) M=0
   IF( PRESENT(IFAIL) )THEN
      SIFAIL = SIZE(IFAIL)
   ELSE
      SIFAIL = N
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
   IF( PRESENT(VL) )THEN
      LVL = VL
   ELSE
      LVL = -HUGE(LVL)
   ENDIF
   IF( PRESENT(VU) )THEN
      LVU = VU
   ELSE
      LVU = HUGE(LVU)
   ENDIF
   IF( PRESENT(IL) )THEN
      LIL = IL
   ELSE
      LIL = 1
   ENDIF
   IF( PRESENT(IU) )THEN
      LIU = IU
   ELSE
      LIU = N
   ENDIF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( LVU < LVL )THEN
      LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN
      LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0  )THEN
      LINFO = -7
   ELSE IF( N < LIU )THEN
      LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND.LSAME(LJOBZ,"N") )THEN
          LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
         LRANGE = "V"
         LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
         LRANGE = "I"
         LM = LIU-LIL+1
      ELSE
         LRANGE = "A"
         LM = N
      END IF
      IF ( LSAME(LJOBZ,"V") ) THEN
         LDZ = N
         LZ = LM
      ELSE
         LDZ = 1
         LZ = 1
      ENDIF
      IF( PRESENT(IFAIL) )THEN;
         LIFAIL => IFAIL
      ELSE
         LIFAIL => ISTAT1
      ENDIF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)
      ALLOCATE(IWORK(5*N), Z(LDZ,LZ), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, Z, WORK, STAT=ISTAT1(1))
         LWORK = MAX(1,N*8)
         ALLOCATE(IWORK(5*N), Z(LDZ,LZ), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
         IF( PRESENT(ABSTOL) )THEN
            LABSTOL = ABSTOL
         ELSE
            LABSTOL = 0.0_WP
         ENDIF
!!     .. CALL LAPACK77 ROUTINE
         CALL SYEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
                         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                         LWORK, IWORK, LIFAIL, LINFO )
         IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
         IF( PRESENT(M) ) M = LM
         W(LM+1:N) = 0.0_WP
      END IF
      DEALLOCATE(IWORK, Z, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYEVX_F95
SUBROUTINE SSYGST_F95( A, B, ITYPE, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYGST_F77 => LA_SYGST                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(IN) :: B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYGST / LA_HEGST reduces a real symmetric-definite or complex
!! Hermitian-definite generalized eigenproblem to standard form.
!
!! If ITYPE = 1, the problem is A*x = lambda*B*x,
!! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
!
!! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
!! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
!
!! B must have been previously factorized as U**H*U or L*L**H
!! by LA_POTRF.
!
!! =======
!
!!    SUBROUTINE LA_SYGST / LA_HEGST( A, B, ITYPE, UPLO, INFO )
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       <type(<wp>), INTENT(IN) :: B(:,:)
!!       <type(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!       <type> ::= REAL | COMPLEX
!
!! Defaults
!! ========
!
!! 1. If ITYPE is not present then ITYPE = 1 is assumed.
!!
!! 2. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the transformed matrix, stored in the
!!            same format as A.
!
!! B       (input) either REAL or COMPLEX square array,
!!         shape (:,:), size(B,1) == size(A,1).
!!         The triangular factor from the Cholesky factorization of B,
!!         as returned by LA_POTRF.
!
!! ITYPE   Optional, (input) INTEGER
!!         If ITYPE is present then:
!!            = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
!!            = 2 or 3: compute U*A*U**H or L**H*A*L.
!!         otherwise ITYPE = 1 is assumed.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored and B is factored as
!!                    U**H*U;
!!            = "L":  Lower triangle of A is stored and B is factored as
!!                    L*L**H.
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYGST"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LITYPE
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N )THEN; LINFO = -2
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. CALL LAPACK77 ROUTINE
      CALL SYGST_F77( LITYPE, LUPLO, N, A, LD, B, LD, LINFO )
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO)
END SUBROUTINE SSYGST_F95
SUBROUTINE SSYGV_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYGV_F77 => LA_SYGV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYGV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, LD, LITYPE, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(ITYPE) )THEN
      LITYPE = ITYPE
   ELSE
      LITYPE = 1
   END IF
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
      LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
      LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -6
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      ENDIF
      LWORK = N*(2+NB)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = N*3-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( LINFO == 0 .OR. LINFO <= -200 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYGV_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
                        WORK, LWORK, LINFO )
      END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE SSYGV_F95
SUBROUTINE SSYGVD_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: SYGVD_F77 => LA_SYGVD                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
      INTEGER, INTENT(IN), OPTIONAL :: ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYGV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, LD, LITYPE, LWORK, ISTAT, ISTAT1, LIWORK
!!  .. LOCAL ARRAYS ..
      REAL(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
      IF( PRESENT(ITYPE) )THEN
        LITYPE = ITYPE
      ELSE
        LITYPE = 1
      END IF
      IF( PRESENT(JOBZ) ) THEN
        LJOBZ = JOBZ
      ELSE
        LJOBZ = "N"
      END IF
      IF( PRESENT(UPLO) ) THEN
        LUPLO = UPLO
      ELSE
        LUPLO = "U"
      END IF
!!  .. TEST THE ARGUMENTS ..
      IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
        LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
        LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN
        LINFO = -3
      ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
        LINFO = -4
      ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
        LINFO = -5
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
        LINFO = -6
      ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE ..
!!  .. QUERING THE SIZE OF WORKSPACE ..
        LIWORK = -1
        LWORK = -1

        CALL SYGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORKMIN, LWORK, IWORKMIN, LIWORK, LINFO )

        LWORK = WORKMIN(1)
        LIWORK = IWORKMIN(1)

        ALLOCATE(WORK(LWORK), IWORK(LIWORK), STAT=ISTAT)
        IF (ISTAT == 0) THEN
!!        .. CALL LAPACK77 ROUTINE ..
          CALL SYGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORK, LWORK, IWORK, LIWORK, LINFO )
        ELSE
          LINFO = -100
        END IF
        DEALLOCATE(WORK, IWORK, STAT=ISTAT1)
      ENDIF
      CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE SSYGVD_F95
SUBROUTINE SSYGVX_F95( A, B, W, ITYPE, JOBZ, UPLO, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => SP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => SLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: SYGVX_F77 => LA_SYGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYGVX and LA_HEGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!      A*z = lambda*B*z, A*B*z = lambda*z,  and  B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SYGVX and complex
!! Hermitian in the case of LA_HEGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SYGVX / LA_HEGVX (A, B, W, ITYPE= itype, &
!!             JOBZ= jobz, UPLO= uplo, VL= vl, VU= vu, IL= il, &
!!             IU= iu, M= m, IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the
!!        upper triangular part of matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of
!!        matrix A.
!!        On exit, if JOBZ = "V", the first M columns of A contain the
!!        orthonormal eigenvectors corresponding to the selected
!!        eigenvalues, with the i-th column of A holding the eigenvector
!!        associated with the eigenvalue in W(i).
!!        The eigenvectors are normalized as follows:
!!          if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!          if ITYPE = 3: Z^H * B^-1 * Z = I .
!!        If an eigenvector fails to converge, then that column of A
!!        contains the latest approximation to the eigenvector and the
!!        index of the eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! B      (input/output) REAL or COMPLEX square array, shape (:,:) with
!!        size(B,1) = size(A,1).
!!        On entry, the matrix B.
!!        If UPLO = "U", the upper triangular part of B contains the
!!        upper triangular part of matrix B. If UPLO = "L", the lower
!!        triangular part of B contains the lower triangular part of
!!        matrix B.
!!        On exit, the part of B containing the matrix is overwritten by
!!        the triangular factor U or L of the Cholesky factorization
!!              B = U^H*U or B = L*L^H.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! ITYPE  Optional (input) INTEGER.
!!        Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!        Default value: 1.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!           = "N": Computes eigenvalues only;
!!           = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: IFAIL should be present if JOBZ = "V".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!             ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal form.
!!        Eigenvalues will be computed most accurately when ABSTOL is set
!!        to twice the underflow threshold 2 * LA_LAMCH(1.0_<wp>, "S"),
!!        not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: the algorithm failed to converge or matrix B is not
!!        positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i, then i
!!             eigenvectors failed to converge. Their indices are stored
!!             in array IFAIL.
!!           > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!             of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!         n is the order of A.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYGVX"
      CHARACTER(LEN=6), PARAMETER :: BSNAME = "DSYTRD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDA, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
      &     SIFAIL, LDB, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      REAL(WP), POINTER :: WORK(:), Z(:,:)
      REAL(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   IF (PRESENT(M)) M = 0
   N = SIZE(A,1); LDA = MAX(1,N); LDB=MAX(1,SIZE(B,1)); LINFO = 0; ISTAT = 0
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL);ELSE; SIFAIL = N; END IF
   IF (PRESENT (JOBZ)) THEN; LJOBZ=JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN;  LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN ; LRANGE = "V"; LM=N
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN ; LRANGE = "I"; LM=LIU-LIL+1
   ELSE ; LRANGE = "A"; LM=N; END IF
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF (SIZE (B, 2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN;  LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"V") .AND. .NOT.LSAME(LJOBZ,"N") )THEN; LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN ; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE, "I") .AND. ( LIU < MIN( N, LIL ) .OR. LIU>N))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
     IF(LSAME(LJOBZ, "V")) THEN
         LDZ = MAX(1,N); LZ=LM
     ELSE
         LDZ = 1; LZ=1
     ENDIF
       IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
       ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT )
         IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 200; ENDIF
         END IF
!!     .. DETERMINE THE WORKSPACE
         ALLOCATE(IWORK(5*N), STAT=ISTAT)
         IF (ISTAT /= 0) THEN; LINFO = -100
           GOTO 300
         ENDIF
         ALLOCATE(Z(LDZ, LZ), STAT=ISTAT)
         IF (ISTAT /= 0) THEN; LINFO = -100
            GOTO 400
         ENDIF

         LWORK = -1
             CALL SYGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
&                  LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORKMIN, &
&                  LWORK, IWORK, LIFAIL, LINFO )
!! NEXT LINE SHOULD BE LWORK = WORKMIN(1)
           LWORK = 2*WORKMIN(1)

           ALLOCATE (WORK(LWORK), STAT = ISTAT)
           IF( ISTAT /= 0 )THEN; LINFO = -100
             GOTO 500
           ENDIF
             IF( LINFO == 0 )THEN
               IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
               ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
!!     .. CALL LAPACK77 ROUTINE
                 CALL SYGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
&                  LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                   LWORK, IWORK, LIFAIL, LINFO )

                 IF( PRESENT(M) ) M = LM
                 IF (LSAME(LJOBZ,"V"))  A(1:LDZ, 1:LM)=Z(1:LDZ, 1:LM)
              END IF
         DEALLOCATE (WORK, STAT = ISTAT1(1))
500      DEALLOCATE(Z)
400      DEALLOCATE (IWORK, STAT = ISTAT)
300      IF (.NOT.PRESENT(IFAIL)) DEALLOCATE(LIFAIL, STAT=ISTAT1(1)); END IF
200       CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYGVX_F95
 SUBROUTINE SSYSV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SSYSV1_F95
 SUBROUTINE SSYSV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => SP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    REAL(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    REAL(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE SSYSV_F95
SUBROUTINE SSYSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:,:), B(:)
   REAL(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,3*N,N*NB)
         ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, IWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SSYSVX1_F95
SUBROUTINE SSYSVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: IWORK(:), LPIV(:)
   REAL(WP),  POINTER :: LFERR(:), LBERR(:)
   REAL(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,3*N,N*NB)
         ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, IWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), IWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, IWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, IWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE SSYSVX_F95
SUBROUTINE SSYTRD_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => SP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYTRD_F77 => LA_SYTRD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: TAU(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYTRD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "SSYTRD"
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYTRD / LA_HETRD reduces a real symmetric or complex Hermitian
!! matrix A to real symmetric tridiagonal form T by an orthogonal
!! or unitary similarity transformation:
!! Q**H * A * Q = T.
!
!! =======
!
!!    SUBROUTINE LA_HETRD / LA_SYTRD|( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       <type>(<wp>), INTENT(OUT) :: TAU(:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A.
!!         On exit:
!!            If UPLO = "U", the diagonal and first superdiagonal
!!               of A are overwritten by the corresponding elements of the
!!               tridiagonal matrix T, and the elements above the first
!!               superdiagonal, with the array TAU, represent the unitary
!!               matrix Q as a product of elementary reflectors.
!!            If UPLO = "L", the diagonal and first subdiagonal of A are
!!               overwritten by the corresponding elements of the tridiagonal
!!               matrix T, and the elements below the first subdiagonal, with
!!               the array TAU, represent the unitary matrix Q as a product
!!               of elementary reflectors.
!!            See Further Details.
!
!! TAU     (output) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         The scalar factors of the elementary reflectors.
!!         See Further Details.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! Further Details
!! ===============
!
!! If UPLO = "U", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(n-1) . . . H(2) H(1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!! A(1:i-1,i+1), and tau in TAU(i).
!
!! If UPLO = "L", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(1) H(2) . . . H(n-1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!! and tau in TAU(i).
!
!! The contents of A on exit are illustrated by the following examples
!! with n = 5:
!
!! if UPLO = "U":                       if UPLO = "L":
!
!!   (  d   e   v2  v3  v4 )              (  d                  )
!!   (      d   e   v3  v4 )              (  e   d              )
!!   (          d   e   v4 )              (  v1  e   d          )
!!   (              d   e  )              (  v1  v2  e   d      )
!!   (                  d  )              (  v1  v2  v3  e   d  )
!
!! where d and e denote diagonal and off-diagonal elements of T, and vi
!! denotes an element of the vector defining H(i).
!
!! --------------------------------------
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: D(:), E(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB > 1 .AND. NB < N )THEN; LWORK = N*NB; ELSE; LWORK = 1; ENDIF
      ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(D, E, WORK, STAT=ISTAT1)
         LWORK = 1; ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYTRD_F77( LUPLO, N, A, LD, D, E, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(D, E, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE SSYTRD_F95
      INTEGER FUNCTION LA_WS_GELS( VER, M, N, NRHS, TRANS )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use LIB_LA_AUXMOD, ONLY: LSAME                                         !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: ILAENV_F77 => LA_ILAENV                         !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN) :: TRANS, VER
      INTEGER, INTENT(IN) :: M, N, NRHS
!!     .. PARAMETERS ..
      CHARACTER(LEN=5), PARAMETER :: NAME1="GEQRF", NAME2="ORMQR", NAME3="ORMLQ", NAME4="GELQF"
!!     .. LOCAL SCALARS ..
      INTEGER :: NB, MN
      LOGICAL :: TPSD
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, MIN
!!     .. EXECUTABLE STATEMENTS ..
      MN = MIN( M, N )
      IF( LSAME( TRANS, "N" ) )THEN
        TPSD = .FALSE.
      ELSE
        TPSD = .TRUE.
      ENDIF
      IF( M.GE.N ) THEN
        NB = ILAENV_F77( 1, VER//NAME1, " ", M, N, -1, -1 )
        IF( TPSD ) THEN
          NB = MAX( NB,ILAENV_F77( 1,VER//NAME2,"LN",M,NRHS,N,-1 ) )
        ELSE
          NB = MAX( NB, ILAENV_F77( 1,VER//NAME2,"LT",M,NRHS,N,-1 ) )
        END IF
      ELSE
        NB = ILAENV_F77( 1, VER//NAME4, " ", M, N, -1, -1 )
        IF( TPSD ) THEN
          NB = MAX( NB, ILAENV_F77( 1,VER//NAME3,"LT",N,NRHS,M,-1 ) )
        ELSE
          NB = MAX( NB, ILAENV_F77( 1,VER//NAME3,"LN",N,NRHS,M,-1 ) )
        END IF
      END IF
      LA_WS_GELS = MN + MAX( M, N, NRHS )*NB
      END FUNCTION LA_WS_GELS
      INTEGER FUNCTION LA_WS_GELSS( VER, M, N, NRHS )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use INT_LAPACK1, ONLY: ILAENV_F77 => LA_ILAENV                         !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN) :: VER
      INTEGER, INTENT(IN) :: M, N, NRHS
!!     .. PARAMETERS ..
      CHARACTER(LEN=5), PARAMETER :: NAME1="GELSS", NAME2="GEQRF", NAME3="ORMQR", NAME4="GEBRD", &
                                     NAME5="ORMBR", NAME6="ORGBR", NAME7="GELQF", NAME8="ORMLQ"
!!     .. LOCAL SCALARS ..
      INTEGER :: MNTHR, MINWRK, MAXWRK, MM, BDSPAC
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX
!!     .. EXECUTABLE STATEMENTS ..
      MNTHR = ILAENV_F77( 6, VER//NAME1, " ", M, N, NRHS, -1 )
!
!!     COMPUTE WORKSPACE
!!      (NOTE: COMMENTS IN THE CODE BEGINNING "Workspace:" DESCRIBE THE
!!       MINIMAL AMOUNT OF WORKSPACE NEEDED AT THAT POINT IN THE CODE,
!!       AS WELL AS THE PREFERRED AMOUNT FOR GOOD PERFORMANCE.
!!       NB REFERS TO THE OPTIMAL BLOCK SIZE FOR THE IMMEDIATELY
!!       FOLLOWING SUBROUTINE, AS RETURNED BY ILAENV.)
!
      MINWRK = 1
      MAXWRK = 0
      MM = M
      IF( M.GE.N .AND. M.GE.MNTHR ) THEN
!
!!        PATH 1A - OVERDETERMINED, WITH MANY MORE ROWS THAN COLUMNS
!
         MM = N
         MAXWRK = MAX(MAXWRK,N+N*ILAENV_F77(1,VER//NAME2," ",M,N,-1,-1))
         MAXWRK = MAX( MAXWRK, N+NRHS*                                  &
     &            ILAENV_F77( 1, VER//NAME3, "LT", M, NRHS, N, -1 ) )
      END IF
      IF( M.GE.N ) THEN
!
!!        PATH 1 - OVERDETERMINED OR EXACTLY DETERMINED
!
!!        COMPUTE WORKSPACE NEEDE FOR DBDSQR
!
         BDSPAC = MAX( 1, 5*N-4 )
         MAXWRK = MAX( MAXWRK, 3*N+( MM+N )*                            &
     &            ILAENV_F77( 1, VER//NAME4, " ", MM, N, -1, -1 ) )
         MAXWRK = MAX( MAXWRK, 3*N+NRHS*                                &
     &            ILAENV_F77( 1, VER//NAME5, "QLT", MM, NRHS, N, -1 ) )
         MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*                             &
     &            ILAENV_F77( 1, VER//NAME6, "P", N, N, N, -1 ) )
         MAXWRK = MAX( MAXWRK, BDSPAC )
         MAXWRK = MAX( MAXWRK, N*NRHS )
         MINWRK = MAX( 3*N+MM, 3*N+NRHS, BDSPAC )
         MAXWRK = MAX( MINWRK, MAXWRK )
      END IF
      IF( N.GT.M ) THEN
!
!!        COMPUTE WORKSPACE NEEDE FOR DBDSQR
!
         BDSPAC = MAX( 1, 5*M-4 )
         MINWRK = MAX( 3*M+NRHS, 3*M+N, BDSPAC )
         IF( N.GE.MNTHR ) THEN
!
!!           PATH 2A - UNDERDETERMINED, WITH MANY MORE COLUMNS
!!           THAN ROWS
!
            MAXWRK = M + M*ILAENV_F77( 1,VER//NAME7," ",M,N,-1,-1 )
            MAXWRK = MAX( MAXWRK, M*M+4*M+2*M*                          &
     &               ILAENV_F77( 1, VER//NAME4, " ", M, M, -1, -1 ) )
            MAXWRK = MAX( MAXWRK, M*M+4*M+NRHS*                         &
     &               ILAENV_F77( 1,VER//NAME5,"QLT",M,NRHS,M,-1 ) )
            MAXWRK = MAX( MAXWRK, M*M+4*M+( M-1 )*                      &
     &               ILAENV_F77( 1, VER//NAME6, "P", M, M, M, -1 ) )
            MAXWRK = MAX( MAXWRK, M*M+M+BDSPAC )
            IF( NRHS.GT.1 ) THEN
               MAXWRK = MAX( MAXWRK, M*M+M+M*NRHS )
            ELSE
               MAXWRK = MAX( MAXWRK, M*M+2*M )
            END IF
            MAXWRK = MAX( MAXWRK, M+NRHS*                               &
     &               ILAENV_F77( 1, VER//NAME8, "LT", N, NRHS, M, -1 ) )
         ELSE
!
!!           PATH 2 - UNDERDETERMINED
!
            MAXWRK = 3*M+(N+M)*ILAENV_F77(1,VER//NAME4," ",M,N,-1,-1)
            MAXWRK = MAX( MAXWRK, 3*M+NRHS*                             &
     &               ILAENV_F77( 1,VER//NAME5,"QLT",M,NRHS,M,-1 ) )
            MAXWRK = MAX( MAXWRK, 3*M+M*                                &
     &               ILAENV_F77( 1, VER//NAME6, "P", M, N, M, -1 ) )
            MAXWRK = MAX( MAXWRK, BDSPAC )
            MAXWRK = MAX( MAXWRK, N*NRHS )
         END IF
      END IF
      LA_WS_GELSS = MAX( MINWRK, MAXWRK )
      END FUNCTION LA_WS_GELSS
 SUBROUTINE ZGBSV1_F95( A, B, K, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: K
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, LK, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LK -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LK -1
          CALL GBSV_F77( N, LK, KU, 1, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGBSV1_F95
 SUBROUTINE ZGBSV_F95( A, B, KL, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GBSV_F77 => LA_GBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(IN), OPTIONAL :: KL
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GBSV computes the solution to a real or complex linear system
!! of equations A*X = B, where A is a square band matrix and X and B are
!! rectangular matrices or vectors. The LU decomposition with row
!! interchanges is used to factor A as A = L*U , where L is a product of
!! permutation and unit lower triangular matrices with kl subdiagonals,
!! and U is upper triangular with kl + ku superdiagonals. The factored
!! form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSV( AB, B, KL=kl, IPIV=ipiv, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             INTEGER, INTENT(IN), OPTIONAL :: KL
!!             INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!         with size(AB,1) = 2*kl+ku+1 and size(AB,2) = n, where kl and ku
!!         are, respectively, the numbers of subdiagonals and
!!         superdiagonals in the band of A, and n is the order of A.
!!         On entry, the matrix A in band storage. The (kl + ku + 1)
!!         diagonals of A are stored in rows (kl + 1) to (2*kl + ku + 1)
!!         of AB, so that the j-th column of A is stored in the j-th
!!         column of AB as follows:
!!         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                        1<=j<=n
!!         The remaining elements in AB need not be set.
!!         On exit, details of the factorization. U is an upper triangular
!!         band matrix with (kl + ku + 1) diagonals. These are stored in
!!         the first (kl + ku + 1) rows of AB. The multipliers that arise
!!         during the factorization are stored in the remaining rows.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! KL      Optional (input) INTEGER.
!!         The number of subdiagonals in the band of A (KL = kl).
!!         The number of superdiagonals in the band is given by
!!         ku = size(AB,1) - 2 * kl - 1.
!!         Default value: (size(AB,1)-1)/3.
!! IPIV    Optional (output) INTEGER array, shape (:) with size(IPIV) = n.
!!         The pivot indices that define the row interchanges; row i of the
!!         matrix was interchanged with row IPIV(i).
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, U(i,i) = 0. The factorization has been
!!         completed, but the factor U is singular, so the solution could
!!         not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GBSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, LDA, N, NRHS, LKL, KU
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0
    LDA = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/3; ENDIF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( LDA - 2*LKL -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( LDA - 2*LKL -1 < 0 .OR. LKL < 0 ) THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       IF( PRESENT(IPIV) )THEN; LPIV => IPIV; ELSE
           ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
       IF ( ISTAT == 0 ) THEN
          KU = LDA -2*LKL -1
          CALL GBSV_F77( N, LKL, KU, NRHS, A, LDA, LPIV, B, N, LINFO )
       ELSE
          LINFO = -100
       END IF
       IF( .NOT.PRESENT(IPIV) )THEN
          DEALLOCATE(LPIV, STAT = ISTAT1 )
       END IF
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGBSV_F95
SUBROUTINE ZGBSVX1_F95(A, B, X, KL, AF, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, &
              SC, SR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LC(:), LR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = 2*LKL+LKU+1; S2AF = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA - LKL -LKU -1 < 0 .OR. LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AF /= 2*LKL+LKU+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, 1, A, LDA, LAF, S1AF, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGBSVX1_F95
SUBROUTINE ZGBSVX_F95(A, B, X, KL, AFB, IPIV, FACT, TRANS, &
                      EQUED, R, C, FERR, BERR, RCOND, RPVGRW, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GBSVX_F77 => LA_GBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(IN), OPTIONAL :: KL
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFB(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GBSVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square band matrix and X and B are rectangular matrices or vectors.
!!    LA_GBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GBSVX( AB, B, X, KL=kl, AFB=afb, IPIV=ipiv, &
!!                  FACT=fact, TRANS=trans, EQUED=equed, R=r, C=c, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, &
!!                  RPVGRW=rpvgrw, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          INTEGER, INTENT(IN), OPTIONAL :: KL
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: C(:), R(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB        (input/output) REAL or COMPLEX rectangular array, shape (:,:)
!!           with size(AB,1) = kl + ku + 1 and size(AB,2) = n, where kl
!!           and ku are, respectively, the numbers of subdiagonals and
!!           superdiagonals in the band of A, and n is the order of A.
!!           On entry, the matrix A or its equilibration in band storage.
!!           The (kl + ku + 1) diagonals of A are stored in rows 1 to
!!           (kl + ku + 1) of AB, so that the j-th column of A is
!!           stored in the j-th column of AB as follows:
!!           AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl)
!!                                     1<=j<=n.
!!           The remaining elements in AB need not be set.
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during the previous call
!!           to LA GBSVX.
!!           On exit, if FACT = "E", the equilibrated version of A is
!!           stored in AB; otherwise, AB is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = n or shape (:) with size(B) = n.
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!           and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!           The solution matrix X .
!! KL        Optional (input) INTEGER.
!!           The number of subdiagonals in the band of A (KL = kl).
!!           The number of superdiagonals in the band is given by
!!           ku =  size(AB,1) - kl - 1.
!!           Default value: (size(AB,1) - 1) / 2.
!! AFB       Optional (input or output) REAL or COMPLEX rectangular array,
!!           shape (:,:) with size(AFB,1) = 2*kl+ku+1 and size(AFB,2)=n
!!           If FACT = "F" then AFB is an input argument that contains the
!!           details of the factorization of (the equilibrated) A returned
!!           by a previous call to LA_GBSVX.
!!           If FACT /= "F" then AFB is an output argument that contains
!!           the details of the factorization of (the equilibrated) A. U is
!!           an upper triangular band matrix with (kl + ku + 1) diagonals.
!!           These are stored in the first (kl + ku + 1) rows of AFB. The
!!           multipliers that arise during the factorization are stored in
!!           the remaining rows.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = n.
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A, returned by a previous call to LA_GBSVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the equilibrated)
!!           A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!             = "N": The matrix A will be copied to AFB and factored (no
!!                  equilibration).
!!             = "E": The matrix A will be equilibrated, then copied to
!!                  AFB and factored.
!!             = "F": AFB and IPIV contain the factored form of (the
!!                  equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!             = "N": A*X = B (No transpose)
!!             = "T": A^T*X = B (Transpose)
!!             = "C": A^H*X = B (Conjugate transpose)
!!           Default value: "N".
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!             = "N": No equilibration (always true if FACT = "N").
!!             = "R": Row equilibration, i.e., A has been premultiplied
!!                  by diag(R).
!!             = "C": Column equilibration, i.e., A has been postmultiplied
!!                  by diag(C).
!!             = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with
!!           size(R) = size(A,1).
!!           The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with
!!           size(C) = size(A,1).
!!           The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j), FERR(j) is an
!!           estimated upper bound for the magnitude of the largest element
!!           in (X(j)-XTRUE) divided by the magnitude of the largest
!!           element in X(j). The estimate is as reliable as the estimate
!!           for RCOND and is almost always a slight overestimate of the
!!           true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any element
!!           of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition is
!!           indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!             <= n: U(i,i) = 0. The factorization has been completed,
!!                 but the factor U is singular, so the solution could
!!                 not be computed.
!!             = n+1: U is nonsingular, but RCOND is less than machine
!!                 precision, so the matrix is singular to working
!!                 precision. Nevertheless, the solution and error
!!                 bounds are computed because the computed solution can
!!                 be more accurate than the value of RCOND would suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, S1AFB, S2AFB, &
              SC, SR, SFERR, SBERR, LD, LKL, LKU, LDA
   REAL(WP) :: LRCOND, MVR, MVC
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LC(:), LR(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAFB(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   LDA = SIZE(A,1); N = SIZE(A, 2); NRHS = SIZE(B, 2); LD = MAX(1,N)
   IF( PRESENT(KL) ) THEN; LKL = KL; ELSE; LKL = (LDA-1)/2; ENDIF
   LKU = LDA -LKL -1
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFB) )THEN; S1AFB = SIZE(AFB,1); S2AFB = SIZE(AFB,2)
   ELSE; S1AFB = 2*LKL+LKU+1; S2AFB = N; END IF
   IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
   IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
   ELSE; MVC = TINY(1.0_WP); END IF
   IF( PRESENT(R) )THEN; SR = SIZE(R); ELSE; SR = N; END IF
   IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND. &
       ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN; MVR = MINVAL(R)
   ELSE; MVR = TINY(1.0_WP); END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( LDA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( LKL < 0 .OR. LKU < 0 ) THEN; LINFO = -4
   ELSE IF( S1AFB /= 2*LKL+LKU+1 .OR. S2AFB /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN; LINFO = -10
   ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN; LINFO = -11
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -12
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -13
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFB) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -7
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -8
   ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR. &
          LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) &
              .AND. LSAME(LFACT,"F") ) .OR. &
         ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(R) ) .OR. &
         ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND. &
              .NOT.PRESENT(C) ) )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFB) ) THEN; ALLOCATE( LAFB(S1AFB,N), STAT=ISTAT )
      ELSE; LAFB => AFB; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(R) )THEN; ALLOCATE( LR(N), STAT=ISTAT )
         ELSE; LR => R; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(C) )THEN; ALLOCATE( LC(N), STAT=ISTAT )
         ELSE; LC => C; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GBSVX_F77( LFACT, LTRANS, N, LKL, LKU, NRHS, A, LDA, LAFB, S1AFB, &
                         LPIV, LEQUED, LR, LC, B, LD, X, LD, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AFB) ) DEALLOCATE( LAFB, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGBSVX_F95
      SUBROUTINE ZGBTRF_F95( A, K, M, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GBTRF_F77 => LA_GBTRF, LANGB_F77 => LA_LANGB, & !!((07-B-INT_LAPACK1.f90))
                                          GBCON_F77 => LA_GBCON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(IN), OPTIONAL :: K, M
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      COMPLEX(WP), INTENT( INOUT ) :: A( :, : )
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GBTRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV, &
                 LK, KU, LM
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      LD = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0
      IF( PRESENT(K) ) THEN; LK = K; ELSE; LK = (LD-1)/3; ENDIF
      IF( PRESENT(M) ) THEN; LM = M; ELSE; LM = N; ENDIF; MINMN = MIN(LM,N)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( N < 0 .OR. LD < 0 )THEN; LINFO = -1
      ELSE IF( LD - 2*LK -1 < 0 .OR. LK < 0 ) THEN; LINFO = -2
      ELSE IF( LM < 0 )THEN; LINFO = -3
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -4
      ELSE IF( PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -5
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -6
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( RWORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGB_F77( LNORM, MINMN, LK, KU, A, LD, RWORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(RWORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GBTRF_F77( LM, N, LK, KU, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(2*MINMN), RWORK(MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GBCON_F77( LNORM, MINMN, LK, KU, A, LD, LIPIV, &
                                     LANORM, RCOND, WORK, RWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE ZGBTRF_F95
SUBROUTINE ZGEEQU_F95( A, R, C, ROWCND, COLCND, AMAX, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEQU_F77 => LA_GEEQU                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT( OUT ), OPTIONAL :: AMAX, COLCND, ROWCND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT( IN ) :: A( :, : )
   REAL(WP), INTENT( OUT ) :: C( : ), R( : )
!---------------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GEEQU computes row and column scalings intended to equilibrate a
!! rectangle matrix A and reduce its condition number.  R returns the
!! row scale factors and C the column scale factors, chosen to try to
!! make the largest entry in each row and column of the matrix B with
!! elements B(i,j) = R(i) A(i,j) C(j) have absolute value 1.
!
!! R(i) and C(j) are restricted to be between SMLNUM = smallest safe
!! number and BIGNUM = largest safe number. Use of these scaling
!! factors is not guaranteed to reduce the condition number of A but
!! works well in practice.
!
!! Arguments
!! =========
!
!! SUBROUTINE LA_GEEQU ( A, R, C, ROWCND, COLCND, AMAX, INFO )
!!    <type>(<wp>), INTENT(IN) :: A(:,:)
!!    REAL(<wp>), INTENT( OUT ) :: R(:), C(:)
!!    REAL(<wp>), INTENT( OUT ), OPTIONAL :: ROWCND, COLCND, AMAX
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! ====================
!
!! A       (input) either REAL or COMPLEX array, shape (:,:).
!!         The matrix A, whose equilibration factors are to be computed.
!
!! R       (output) REAL array, shape (:), size(R) == size(A,1).
!!         If INFO = 0 or INFO > size(A,1), R contains the row
!!         scale factors for A.
!
!! C       (output) REAL array, shape (:), size(C) == size(A,2).
!!         If INFO = 0, C contains the column scale factors for A.
!
!! ROWCND  Optional (output) REAL.
!!         If INFO = 0 or INFO > size(A,1), ROWCND contains the ratio
!!         of the smallest R(i) to the largest R(i).  If ROWCND >= 0.1
!!         and AMAX is neither too large nor too small, it is not worth
!!         scaling by R.
!
!! COLCND  Optional (output) REAL.
!!         If INFO = 0, COLCND contains the ratio of the smallest
!!         C(i) to the largest C(i).  If COLCND >= 0.1, it is not
!!         worth scaling by C.
!
!! AMAX    Optional (output) REAL.
!!         Absolute value of largest matrix element.  If AMAX is very
!!         close to overflow or very close to underflow, the matrix
!!         should be scaled.
!
!! INFO    Optional (output) INTEGER
!!         If INFO is present
!!            = 0:  successful exit
!!            < 0:  if INFO = -k, the k-th argument had an illegal value
!!            > 0:  if INFO = k,  and k is
!!                  <= M:  the k-th row of A is exactly zero
!!                  >  M:  the (k-M)-th column of A is exactly zero
!!                         where M = size(A,1)
!!         If INFO is not present and an error occurs, then the program is
!!            terminated with an error message.
!
!-------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEQU"
!!  .. LOCAL SCALARS ..
   INTEGER :: LINFO, M, N
   REAL(WP) :: LAMAX, LCOLCND, LROWCND
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; M = SIZE(A, 1); N = SIZE(A, 2)
!!  .. TEST THE ARGUMENTS
   IF ( SIZE(R) /= M ) THEN; LINFO = -2
   ELSE IF ( SIZE(C) /= N ) THEN; LINFO = -3
   ELSE
!!     .. CALL LAPACK77 ROUTINE
      CALL GEEQU_F77( M, N, A, MAX(1,M), R, C, LROWCND, LCOLCND, LAMAX, LINFO )
      IF( PRESENT( ROWCND ) ) ROWCND = LROWCND
      IF( PRESENT( COLCND ) ) COLCND = LCOLCND
      IF( PRESENT( AMAX ) ) AMAX = LAMAX
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE ZGEEQU_F95
    SUBROUTINE ZGEES_F95( A, W, VS, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEES_F77 => LA_GEES                                !!((07-B-INT_LAPACK1.f90))
!!  use LA_EXTERNAL, ONLY: SELECT
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
   INTERFACE
      LOGICAL FUNCTION SELECT(W)
         use KND_LA_PRECISION, ONLY: WP => DP                                !!((05-B-KND_LA_PRECISION.f90))
         COMPLEX(WP), INTENT(IN) :: W
      END FUNCTION SELECT
   END INTERFACE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GEES computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! Schur factorization
!!                        A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left. The leading
!! columns of Z then form an orthonormal basis for the invariant subspace
!! corresponding to the selected eigenvalues.
!!      A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks are
!! standardized in the form
!!                       [ a  b ]
!!                       [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!! A complex matrix is in complex-Schur form if it is upper triangular.
!!
!! =========
!!
!!        SUBROUTINE LA_GEES( A, <w>, VS=vs, SELECT=select, &
!!                                   SDIM=sdim, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           <type>(<wp>), INTENT(OUT) :: <w(:)>
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!           INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!           END INTERFACE
!!           OPTIONAL :: SELECT
!!           INTEGER, INTENT(OUT), OPTIONAL :: SDIM, INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <w>    ::= WR, WI | W
!!           <w(:)> ::= WR(:), WI(:) | W(:)
!!           <w(j)> ::= WR(j) , WI(j) |  W(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the Schur form T.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues in the order in which they appear on
!!          the diagonal of the Schur form T.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VS       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VS,1) = size(A,1).
!!          The matrix Z of Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION.
!!          LOGICAL FUNCTION SELECT( <w(j)> )
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!          where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j) , WI(j) | W(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!             interface in the calling (sub)program.
!!          2. SELECT is called by LA_GEES for every computed eigenvalue
!!           w(j) (but only once for a complex conjugate pair when A is
!!           real). It is used to select the eigenvalues that will be
!!             ordered to the top left of the Schur form. The eigenvalue
!!           w(j) is selected if SELECT(w(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!           SELECT(w(j)) = .TRUE. after ordering, since ordering may
!!           change the value of complex eigenvalues (especially if the
!!           eigenvalue is ill-conditioned). In this case INFO is set to
!!           size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which
!!          SELECT=.TRUE. (If A is real, complex conjugate pairs for which
!!          SELECT=.TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of w contain
!!                    those eigenvalues which have converged. VS contains
!!                    the matrix which reduces A to its partially converged
!!                    Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                  problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                  in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!-------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEES"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
!!  .. LOCAL ARRAYS ..
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   COMPLEX(WP), TARGET :: LLVS(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LSDIM = 0
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(SDIM) .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      IF( ISTAT == 0 ) THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), RWORK(N),  STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VS) )THEN
          IF( PRESENT(SDIM) )THEN
             ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        VS, S1VS, WORK, LWORK, RWORK, BWORK, LINFO )
            ELSE
               CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        VS, S1VS, WORK, LWORK, RWORK, LLBWORK, LINFO )
            ENDIF
           ELSE
            IF( PRESENT(SDIM) )THEN
              ALLOCATE(BWORK(N),STAT=ISTAT)
              CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        LLVS, S1VS, WORK, LWORK, RWORK, BWORK, LINFO )
            ELSE
               CALL GEES_F77( LJOBVS, LSORT, SELECT, N, A, LD, LSDIM, W, &
                        LLVS, S1VS, WORK, LWORK, RWORK, LLBWORK, LINFO )
            ENDIF
           ENDIF

         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
!!      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   IF( PRESENT(SDIM) ) SDIM = LSDIM
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGEES_F95
SUBROUTINE ZGEESX_F95( A, W, VS, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEESX_F77 => LA_GEESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, SDIM
   REAL(WP), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VS(:,:)
!!  .. EXTERNAL ARGUMENTS ..
      INTERFACE
         FUNCTION SELECT(W)
            use KND_LA_PRECISION, ONLY: WP => DP                             !!((05-B-KND_LA_PRECISION.f90))
            COMPLEX(WP), INTENT(IN) :: W
            LOGICAL :: SELECT
         END FUNCTION SELECT
      END INTERFACE
   OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GEESX computes for a real/complex square matrix A, the
!! eigenvalues, the real-Schur/complex-Schur form T , and, optionally, the
!! matrix of Schur vectors Z, where Z is orthogonal/unitary. This gives the
!! factorization
!!                     A = Z*T*Z^H.
!! Optionally, it also orders the eigenvalues on the diagonal of the Schur
!! form so that selected eigenvalues are at the top left, computes a
!! reciprocal condition number for the average of the selected eigenvalues
!! and computes a reciprocal condition number for the right invariant
!! subspace corresponding to the selected eigenvalues. The leading columns
!! of Z form an orthonormal basis for this invariant subspace.
!! A real matrix is in real-Schur form if it is block upper triangular
!! with 1 by 1 and 2 by 2 blocks along the main diagonal. 2 by 2 blocks
!! are standardized in the form
!!                        [ a  b ]
!!                        [ c  a ]
!! where b*c < 0. The eigenvalues of such a block are a +/- Sqrt(b*c).
!!
!! =========
!!
!!       SUBROUTINE LA_GEESX( A, <w>, VS=vs, SELECT=select, SDIM=sdim, &
!!                              RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VS(:,:)
!!            INTERFACE
!!               LOGICAL FUNCTION SELECT(<w(j)>)
!!                  <type>(<wp>), INTENT(IN) :: <w(j)>
!!               END FUNCTION SELECT
!!            END INTERFACE
!!            OPTIONAL :: SELECT
!!            INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE, RCONDV
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the Schur form T .
!! <w>     (output) REAL or COMPLEX array, shape (:) with size(w) =
!!         size(A,1).
!!         The computed eigenvalues in the order in which they appear on
!!         the diagonal of the Schur form T.
!!         <w(:)> ::= WR(:), WI(:) | W(:),
!!         where
!!         WR(:), WI(:) are of REAL type (for the real and imaginary
!!         parts) and W(:) is of COMPLEX type.
!!         Note: If A is real, then a complex-conjugate pair appear
!!         consecutively, with the eigenvalue having the positive
!!         imaginary part appearing first.
!! VS      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VS,1) = size(A,1).
!!         The matrix Z of Schur vectors.
!! SELECT  Optional (input) LOGICAL FUNCTION
!!         LOGICAL FUNCTION SELECT( <w(j)>)
!!            <type>(<wp>), INTENT(IN) :: <w(j)>
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp> ::= KIND(1.0) | KIND(1.0D0)
!!            <w(j)> ::= WR(j), WI(j) | W(j)
!!         1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!         2. SELECT is called by LA_GEES for every computed eigenvalue
!!          <w(j)> (but only once for a complex conjugate pair when A
!!          is real). It is used to select the eigenvalues that will be
!!          ordered to the top left of the Schur form. The eigenvalue
!!          <w(j)> is selected if SELECT(<w(j)>) has the value .TRUE.
!!         3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<w(j)>) = .TRUE. after ordering, since ordering may
!!          change the value of complex eigenvalues (especially if the
!!          eigenvalue is ill-conditioned). In this case INFO is set to
!!          size(A,1) + 2 (see INFO below).
!!         Note: Select must be present if SDIM, RCONDE and RCONDF are
!!         desired.
!! SDIM    Optional (output) INTEGER.
!!         The number of eigenvalues (after sorting) for which
!!         SELECT = .TRUE. (If A is real, complex conjugate pairs for which
!!         SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE  Optional (output) REAL.
!!         The reciprocal condition number for the average of the selected
!!         eigenvalues.
!! RCONDV  Optional (output) REAL.
!!         The reciprocal condition number for the selected right
!!         invariant subspace.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!              <= n: the QR algorithm failed to compute all the
!!                    eigenvalues; elements 1:ilo-1 and i+1:n of <w>
!!                    contain those eigenvalues which have converged.
!!                    VS contains the matrix which reduces A to its
!!                    partially converged Schur form.
!!              = n+1: the eigenvalues could not be reordered because some
!!                    eigenvalues were not sufficiently separated (the
!!                    problem is very ill-conditioned).
!!              = n+2: after reordering, some leading complex eigenvalues
!!                    in the Schur form no longer satisfy SELECT = .TRUE.
!!                    This can be caused by ordinary roundoff or underflow
!!                    due to scaling.
!!              n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVS, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VS, S2VS, LSDIM
   REAL(WP) :: LRCONDE, LRCONDV
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   LOGICAL, POINTER :: BWORK(:)
   COMPLEX(WP), TARGET :: LLVS(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VS) )THEN; S1VS = SIZE(VS,1); S2VS = SIZE(VS,2); LJOBVS = "V"
   ELSE; S1VS = 1; S2VS = 1; LJOBVS = "N"; END IF
   IF( PRESENT(SDIM) .OR. PRESENT(SELECT) )THEN; LSORT = "S"; ELSE; LSORT = "N"; END IF
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VS) .AND. ( S1VS /= N .OR. S2VS /= N ) )THEN; LINFO = -3
   ELSE IF( LSAME(LSORT,"S") .AND. .NOT.PRESENT(SELECT) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      IF( LSAME(LSORT,"S") )THEN
        ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      ALLOCATE( RWORK(MAX(1,N)), STAT=ISTAT )
      IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 200; ENDIF

      LWORK = MAX(1, 2*N, N*N/2)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO = -100; GOTO 300; ENDIF
      IF (PRESENT (VS)) THEN
          CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, W, &
     &        VS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &        RWORK, BWORK, LINFO )
       ELSE
          CALL GEESX_F77( LJOBVS, LSORT, SELECT, LSENSE, N, A, LD, LSDIM, W, &
     &        LLVS, S1VS, LRCONDE, LRCONDV, WORK, LWORK, &
     &        RWORK, BWORK, LINFO )
      ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(SDIM) ) SDIM = LSDIM
      IF( PRESENT(RCONDE) ) RCONDE = LRCONDE
      IF( PRESENT(RCONDV) ) RCONDV = LRCONDV
      IF( LSAME(LSORT,"S") ) DEALLOCATE(BWORK, STAT=ISTAT1)

      DEALLOCATE(WORK, STAT=ISTAT)
300   DEALLOCATE(RWORK, STAT=ISTAT )
200   IF( LSAME(LSORT,"S")) DEALLOCATE(BWORK,STAT=ISTAT)
    ENDIF
100 CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGEESX_F95
SUBROUTINE ZGEEV_F95( A, W, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEV_F77 => LA_GEEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEV computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors. A
!! right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j).
!!
!! =========
!!
!!       SUBROUTINE LA_GEEV( A, <w>, VL=vl, VR=vr, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!            <type>(<wp>), INTENT(OUT) :: <w(:)>
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <w>    ::= WR, WI | W
!!            <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors were computed. Elements
!!          i+1 : n of <w> contain eigenvalues which have converged.
!!          n is the order of A
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
      LWORK = MAX( 1, 2*N, LWORK)
      ALLOCATE(WORK(LWORK), RWORK(MAX(1,2*N)), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            LWORK = MAX( 1, 2*N )
            ALLOCATE(WORK(LWORK), RWORK(MAX(1,2*N)), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(VL) )THEN
           IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        VL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        VL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
            ENDIF
           ELSE
            IF( PRESENT(VR) )THEN
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        LLVL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEEV_F77( LJOBVL, LJOBVR, N, A, LD, W, &
                        LLVL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
            ENDIF
           ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGEEV_F95
SUBROUTINE ZGEEVX_F95( A, W, VL, VR, BALANC, ILO, IHI, &
                       SCALE, ABNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEEVX_F77 => LA_GEEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, ILO, IHI
   REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: W(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: SCALE(:), RCONDE(:), RCONDV(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GEEVX computes for a real or complex square matrix A, the
!! eigenvalues and, optionally, the left and/or right eigenvectors.
!! Optionally, it also balances A and computes reciprocal condition
!! numbers for the  eigenvalues and right eigenvectors.
!! A right eigenvector v(j) of A satisfies
!!                   A * v(j) = lambda(j) * v(j)
!! where lambda(j) is its eigenvalue. A left eigenvector u(j) of A
!! satisffies
!!                   u(j)^H * A = lambda(j) * u(j)^H
!! where u(j)^H denotes the conjugate-transpose of u(j). The computed
!! eigenvectors are normalized to have Euclidean norm equal to 1 and
!! largest component real.
!!        Balancing A involves permuting its rows and columns to make
!! it more nearly upper triangular and then scaling rows and columns by
!! a diagonal similarity transformation to reduce the condition numbers
!! of the eigenvalues and eigenvectors.
!!        Computed reciprocal condition numbers pertain to the matrix
!! after balancing. Permuting does not change condition numbers (in
!! exact arithmetic), but scaling does.
!
!! =========
!!
!!    SUBROUTINE LA_GEEVX( A, <w>, VL=vl, VR=vr, BALANC=balanc, ILO=ilo, &
!!                     IHI=ihi, SCALE=scale, ABNRM=abnrm, RCONDE=rconde, &
!!                     RCONDV=rcondv, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <w(:)>
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!         INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!         REAL(<wp>), INTENT(OUT), OPTIONAL :: SCALE(:), ABNRM, &
!!               RCONDE(:), RCONDV(:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!         <w>    ::= WR, WI | W
!!         <w(:)> ::= WR(:), WI(:) | W(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the contents of A are destroyed.
!! <w>      (output) REAL or COMPLEX array, shape (:) with size(w) =
!!          size(A,1).
!!          The computed eigenvalues.
!!          <w(:)> ::= WR(:), WI(:) | W(:),
!!          where
!!          WR(:), WI(:) are of REAL type (for the real and imaginary
!!          parts) and W(:) is of COMPLEX type.
!!          Note: If A is real, then a complex-conjugate pair appear
!!          consecutively, with the eigenvalue having the positive
!!          imaginary part appearing first.
!! VL       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VL,1) = size(A,1).
!!          The left eigenvectors u(j) are stored in the columns of VL in
!!          the order of their eigenvalues. Each eigenvector is scaled so
!!          that the Euclidean norm is 1 and the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are
!!          stored in VL(:,j) and VL(:,j+1). Thus a complex conjugate pair
!!          is given by
!!            u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VR,1) = size(A,1).
!!          The right eigenvectors v(j) are stored in the columns of VR in
!!          the order of their eigenvalues.
!!          Each eigenvector is scaled so that the Euclidean norm is 1 and
!!          the largest component is real.
!!          Note: If A is real then complex eigenvectors, like their
!!          eigenvalues, occur in complex conjugate pairs. The real and
!!          imaginary parts of the first eigenvector of the pair are stored
!!          in VR(:,j) and VR(:,j+1). Thus a complex conjugate pair is
!!          given by
!!            v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC   Optional (input) CHARACTER(LEN=1).
!!          Indicates whether the input matrix should be permuted and/or
!!          diagonally scaled.
!!             = "N": Do not permute or scale;
!!             = "P": Permute but do not scale;
!!             = "S": Scale but do not permute;
!!             = "B": Both permute and scale.
!!           Default value: "N".
!! ILO,IHI  Optional (output) INTEGER.
!!          ILO and IHI are determined when A is balanced. The balanced
!!          A(i,j) = 0 if i > j and j = 1, ..., ILO-1 or
!!          i = IHI+1, ... , size(A,1).
!! SCALE    Optional (output) REAL array, shape (:) with size(SCALE) =
!!          size(A,1).
!!          Details of the permutations and scaling factors applied when
!!          balancing A. If P(j) is the index of the row and column
!!          interchanged with row and column j, and D(j) is the
!!          scaling factor applied to row and column j, then
!!          P(j) = SCALE(j), j = 1, ..., ILO-1 and j =IHI+1, ...,  n
!!          D(j) = SCALE(j), j = ILO, ... , IHI.
!! ABNRM    Optional (output) REAL.
!!          The l1 norm of the balanced matrix (the maximum of the sum
!!          of absolute values of elements of any column).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE) =
!!          size(A,1). RCONDE(j) is the reciprocal condition number of
!!          the j-th eigenvalue.
!! RCONDV   Optional (output) REAL array, shape (:), size(RCONDV) =
!!          size(A,1). RCONDV(j) is the reciprocal condition number of
!!          the j-th right eigenvector.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, the QR algorithm failed to compute all the
!!          eigenvalues and no eigenvectors or condition numbers were
!!          computed; elements 1:ILO-1 and i+1:n of <w> contain
!!          eigenvalues which have converged.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GEEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LBALANC, LJOBVL, LJOBVR, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, NN, &
              LILO, LIHI, SSCALE, SRCONDE, SRCONDV
   REAL(WP) :: LABNRM
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
   REAL(WP), POINTER :: LSCALE(:), LRCONDE(:), LRCONDV(:)
   COMPLEX(WP), POINTER :: LLVL(:,:), LLVR(:,:)
   COMPLEX(WP), POINTER :: WORK(:)

!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = N; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = N; LJOBVR = "N"; END IF
   IF( PRESENT(SCALE) )THEN; SSCALE = SIZE(SCALE); ELSE; SSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -4
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
                   LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -5
   ELSE IF( SSCALE /= N )THEN; LINFO = -8
   ELSE IF( SRCONDE /= N )THEN; LINFO = -10
   ELSE IF( SRCONDV /= N )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
      IF( PRESENT(SCALE) )THEN; LSCALE => SCALE
      ELSE
        ALLOCATE( LSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 100; END IF
      ENDIF
      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE
        ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 200; END IF
      ENDIF
      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE
        ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 300; END IF
      END IF
      ALLOCATE( RWORK(MAX(1,2*N)), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 400; END IF
      IF( LSAME(LSENSE,"N") .OR. LSAME(LSENSE,"E") )THEN; NN = 2*N
      ELSE IF( LSAME(LSENSE,"V") .OR. LSAME(LSENSE,"B") )THEN; NN = N*(N+2)
      ELSE; NN = 2*N; ENDIF
      IF (LSAME (LSENSE,"E") .OR. LSAME(LSENSE,"B") ) THEN
         LJOBVL = "V"; LJOBVR = "V"; S1VR=N; S1VL=N
      ENDIF
      IF (PRESENT (VL)) THEN; LLVL => VL
      ELSE; ALLOCATE (LLVL(N,N), STAT = ISTAT); ENDIF
      IF (PRESENT (VR)) THEN; LLVR => VR
      ELSE; ALLOCATE (LLVR(N,N), STAT = ISTAT); ENDIF
      LWORK = -1
      IF (PRESENT (VL)) THEN
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ENDIF
        ELSE
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&              LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&              LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, LINFO )
          ENDIF
         ENDIF
       LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
        DEALLOCATE(WORK, STAT=ISTAT1)
        LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN; LINFO =-100; GOTO 500; END IF
      END IF
      IF (PRESENT (VL)) THEN
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                VL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                VL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ENDIF
       ELSE
         IF (PRESENT(VR)) THEN
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                LLVL, S1VL, VR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ELSE
            CALL GEEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, W, &
&                LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LSCALE, LABNRM, &
&                LRCONDE, LRCONDV, WORK, LWORK, RWORK, LINFO )
         ENDIF
        ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO;
      IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM

      DEALLOCATE(WORK, STAT=ISTAT1)
500   DEALLOCATE(RWORK, STAT=ISTAT1)
400   IF( .NOT. PRESENT(RCONDV) ) DEALLOCATE( LRCONDV, STAT=ISTAT1 )
300   IF( .NOT. PRESENT(RCONDE) ) DEALLOCATE( LRCONDE, STAT=ISTAT1 )
200   IF( .NOT. PRESENT(SCALE) ) DEALLOCATE( LSCALE, STAT=ISTAT1 )
      IF (.NOT.PRESENT (VL)) DEALLOCATE(LLVL)
      IF (.NOT.PRESENT (VR)) DEALLOCATE(LLVR)
   ENDIF
100   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)

END SUBROUTINE ZGEEVX_F95
    SUBROUTINE ZGEGS_F95( A, B, ALPHA, BETA, VSL, VSR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGS_F77 => LA_GEGS                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGS computes for a pair of n-by-n real nonsymmetric matrices
!!  A, B: the generalized eigenvalues (alphar alpha, beta),
!!  the Schur form (A, B), and optionally left and/or right
!!  Schur vectors (VSL and VSR).
!
!!  (If only the generalized eigenvalues are needed, use the driver SGEGV
!!  instead.)
!
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!
!!  The (generalized) Schur form of a pair of matrices is the result of
!!  multiplying both matrices on the left by one orthogonal matrix and
!!  both on the right by another orthogonal matrix, these two orthogonal
!!  matrices being chosen so as to bring the pair of matrices into
!!  (real) Schur form.
!
!!  A pair of matrices A, B is in generalized real Schur form if B is
!!  upper triangular with non-negative diagonal and A is block upper
!!  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond
!!  to real generalized eigenvalues, while 2-by-2 blocks of A will be
!!  "standardized" by making the corresponding elements of B have the
!!  form:
!!          [  a  0  ]
!!          [  0  b  ]
!
!!  and the pair of corresponding 2-by-2 blocks in A and B will
!!  have a complex conjugate pair of generalized eigenvalues.
!
!!  The left and right Schur vectors are the columns of VSL and VSR,
!!  respectively, where VSL and VSR are the orthogonal matrices
!!  which reduce A and B to Schur form:
!
!!  Schur form of (A,B) = ( (VSL)**T A (VSR), (VSL)**T B (VSR) )
!
!! =========
!
!!   SUBROUTINE LA_GEGS( A, B, <alpha>, BETA, VSL, VSR, INFO )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose generalized
!!      eigenvalues and (optionally) Schur vectors are to be
!!      computed.
!!      On exit, the generalized Schur form of A.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      A should be less than the overflow threshold.
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) Schur vectors are
!!      to be computed.
!!      On exit, the generalized Schur form of B.
!!      Note: to avoid overflow, the Frobenius norm of the matrix
!!      B should be less than the overflow threshold.
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,
!!      j=1,...,n  and  BETA(j),j=1,...,n  are the diagonals of the
!!      complex Schur form (A,B) that would result if the 2-by-2
!!      diagonal blocks of the real Schur form of (A,B) were further
!!      reduced to triangular form using 2-by-2 complex unitary
!!      transformations.  If ALPHAI(j) is zero, then the j-th
!!      eigenvalue is real; if positive, then the j-th and (j+1)-st
!!      eigenvalues are a complex conjugate pair, with ALPHAI(j+1)
!!      negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VSL  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSL will contain the left Schur vectors. (See "Purpose", above.)
!
!! VSR  Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VSL,1) == SIZE(VSL,2) == n.
!!      VSR will contain the right Schur vectors. (See "Purpose", above.)
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  (A,B) are not in Schur
!!            form, but ALPHAR(j), ALPHAI(j), and BETA(j) should
!!            be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_GGBAK (computing VSL)
!!            =n+8: error return from LA_GGBAK (computing VSR)
!!            =n+9: error return from LA_LASCL (various places)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VSL, S2VSL, S1VSR, S2VSR, &
              SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   COMPLEX(WP), POINTER :: WORK(:), &
     &                    LALPHA(:), LBETA(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHA) )THEN; SALPHA = SIZE(ALPHA); ELSE; SALPHA = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHA) )THEN; LALPHA => ALPHA
      ELSE; ALLOCATE(LALPHA(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE( RWORK(MAX(1,3*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VSL, S1VSL, VSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ELSE
              CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ENDIF
          ELSE
            IF( PRESENT(VSR) )THEN
               CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVSL, S1VSL, VSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ELSE
               CALL GEGS_F77( LJOBVSL, LJOBVSR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVSL, S1VSL, LLVSR, S1VSR, WORK, LWORK, RWORK, LINFO )
            ENDIF
          ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGEGS_F95
    SUBROUTINE ZGEGV_F95( A, B, ALPHA, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GEGV_F77 => LA_GEGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!!  LA_GEGV computes for a pair of N-by-N complex nonsymmetric
!!  matrices A and B, the generalized eigenvalues (alpha, beta),
!!  and optionally, the left and/or right generalized eigenvectors
!!  (VL and VR).
!!  A generalized eigenvalue for a pair of matrices (A,B) is, roughly
!!  speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
!!  is singular.  It is usually represented as the pair (alpha,beta),
!!  as there is a reasonable interpretation for beta=0, and even for
!!  both being zero.  A good beginning reference is the book, "Matrix
!!  Computations", by G. Golub & C. van Loan (Johns Hopkins U. Press)
!!  A right generalized eigenvector corresponding to a generalized
!!  eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
!!  that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
!!  l such that l**H * (A - w B) = 0, where l**H is the
!!  conjugate-transpose of l.
!!  Note: this routine performs "full balancing" on A and B -- see
!!  "Further Details", below.
!
!! =========
!
!!   SUBROUTINE LA_GEGV( A, B, <alpha>, BETA, VL, VR, INFO )
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: <alpha">, BETA(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!   where
!!      <type>   ::= REAL | COMPLEX
!!      <wp>     ::= KIND(1.0) | KIND(1.0D0)
!!      <alpha>  ::= ALPHAR, ALPHAI | ALPHA
!!      <alpha"> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!
!! Arguments
!! =========
!
!! A    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(A,1) == SIZE(A,2) == n.
!!      On entry, the first of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of A on exit, see "Further
!!      Details", below.)
!
!! B    (input/output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(rBA,1) == SIZE(rBA,2) == n.
!!      On entry, the second of the pair of matrices whose
!!      generalized eigenvalues and (optionally) generalized
!!      eigenvectors are to be computed.
!!      On exit, the contents will have been destroyed.  (For a
!!      description of the contents of B on exit, see "Further
!!      Details", below.)
!
!! ALPHAR  Only for the real case. Optional (output) REAL array,
!! ALPHAI  shape (:), SIZE(ALPHA") == n. ALPHA ::= ALPHAR | ALPHAI
!! ALPHA   Only for the complex case. Optional (output) COMPLEX
!!         array, shape (:), SIZE(ALPHAI) == n.
!! BETA Optional (output) REAL / COMPLEX array, shape (:),
!!      SIZE(BETA) == n.
!!      On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,n, will
!!      be the generalized eigenvalues.  If ALPHAI(j) is zero, then
!!      the j-th eigenvalue is real; if positive, then the j-th and
!!      (j+1)-st eigenvalues are a complex conjugate pair, with
!!      ALPHAI(j+1) negative.
!!      Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
!!      may easily over- or underflow, and BETA(j) may even be zero.
!!      Thus, the USEr should avoid naively computing the ratio
!!      alpha/beta.  However, ALPHAR and ALPHAI will be always less
!!      than and usually comparable with norm(A) in magnitude, and
!!      BETA always less than and usually comparable with norm(B).
!
!! VL   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VL,1) == SIZE(VL,2) == n.
!!      The left generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! VR   Optional (output) REAL / COMPLEX array, shape (:,:),
!!      SIZE(VR,1) == SIZE(VR,2) == n.
!!      The right generalized eigenvectors.  (See "Purpose", above.)
!!      Real eigenvectors take one column,
!!      complex take two columns, the first for the real part and
!!      the second for the imaginary part.  Complex eigenvectors
!!      correspond to an eigenvalue with positive imaginary part.
!!      Each eigenvector will be scaled so the largest component
!!      will have abs(real part) + abs(imag. part) = 1, *except*
!!      that for eigenvalues with alpha=beta=0, a zero vector will
!!      be returned as the corresponding eigenvector.
!
!! INFO (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!!      = 1,...,n:
!!            The QZ iteration failed.  No eigenvectors have been
!!            calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
!!            should be correct for j=INFO+1,...,n.
!!      > n:  errors that usually indicate LAPACK problems:
!!            =n+1: error return from LA_GGBAL
!!            =n+2: error return from LA_GEQRF
!!            =n+3: error return from LA_ORMQR
!!            =n+4: error return from LA_ORGQR
!!            =n+5: error return from LA_GGHRD
!!            =n+6: error return from LA_HGEQZ (other than failed
!!                                            iteration)
!!            =n+7: error return from LA_TGEVC
!!            =n+8: error return from LA_GGBAK (computing VL)
!!            =n+9: error return from LA_GGBAK (computing VR)
!!            =n+10: error return from LA_LASCL (various calls)
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!! Further Details
!! ===============
!
!! Balancing
!! ---------
!
!! This driver calls SGGBAL to both permute and scale rows and columns
!! of A and B.  The permutations PL and PR are chosen so that PL*A*PR
!! and PL*B*R will be upper triangular except for the diagonal blocks
!! A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
!! possible.  The diagonal scaling matrices DL and DR are chosen so
!! that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
!! one (except for the elements that start out zero.)
!
!! After the eigenvalues and eigenvectors of the balanced matrices
!! have been computed, SGGBAK transforms the eigenvectors back to what
!! they would have been (in perfect arithmetic) if they had not been
!! balanced.
!
!! Contents of A and B on Exit
!! -------- -- - --- - -- ----
!
!! If any eigenvectors are computed (either VL or VR or both), then on
!! exit the arrays A and B will contain the real Schur form[*] of the
!! "balanced" versions of A and B. If no eigenvectors are computed,
!! then only the diagonal blocks will be correct.
!
!! [*] See LA_HGEQZ, LA_GEGS, or read the book "Matrix Computations",
!!     by Golub & van Loan, pub. by Johns Hopkins U. Press.
!--------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GEGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVL, LJOBVR
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, S1VL, S2VL, S1VR, S2VR, &
              SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1)
   COMPLEX(WP), POINTER :: WORK(:), LALPHA(:), LBETA(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ALPHA) )THEN; SALPHA = SIZE(ALPHA); ELSE; SALPHA = N; ENDIF
   IF( PRESENT(BETA) )THEN; SBETA = SIZE(BETA); ELSE; SBETA = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      IF( PRESENT(ALPHA) )THEN; LALPHA => ALPHA
      ELSE; ALLOCATE(LALPHA(N),STAT=ISTAT); ENDIF
      IF( ISTAT == 0 )THEN
         IF( PRESENT(BETA) )THEN; LBETA => BETA
         ELSE; ALLOCATE(LBETA(N),STAT=ISTAT); ENDIF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE( RWORK(MAX(1, 8*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 )THEN
         LWORK = MAX( 1, 2*N, LWORK); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK,STAT=ISTAT1)
            LWORK = MAX( 1, 2*N ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(VL) )THEN
          IF( PRESENT(VR) )THEN
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
             ELSE
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
             ENDIF
            ELSE
             IF( PRESENT(VR) )THEN
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, RWORK, LINFO )
             ELSE
               CALL GEGV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, LALPHA, &
                        LBETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, RWORK, LINFO )
             ENDIF
            ENDIF
         IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGEGV_F95
 SUBROUTINE ZGELS1_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "Z"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"C") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, 1, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGELS1_F95
 SUBROUTINE ZGELS_F95( A, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME, LA_WS_GELS                       !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELS_F77 => LA_GELS                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GELS computes the minimum-norm least squares solution to one
!! or more real or complex linear systems of the form A*x = b, A^T*x = b
!! or A^H*x = b using a QR or LQ factorization of A. Matrix A is
!! rectangular assumed to be of full rank. The vectors b and correspon-
!! ding solution vectors x are the columns of matrices denoted B and X,
!! respectively.
!!
!! ==========
!!
!!       SUBROUTINE LA_GELS( A, B, TRANS=trans, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX rectangular array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, if size(A,1) >= size(A,2), A is overwritten by
!!          details of its QR factorization. If size(A,1) < size(A,2), A
!!          is overwritten by details of its LQ factorization.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!          size(B) = max(size(A,1); size(A,2)).
!!          On entry, the matrix B.
!!          On exit, the solution matrix X. There are four cases:
!!          1. If TRANS = "N" and size(A,1) >= size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the least squares
!!             solution vector(s); the residual sum of squares for the
!!             solution vector in a column of B is given by the sum of
!!             squares of elements in rows size(A,2)+1 to size(A,1) of
!!             that column.
!!          2. If TRANS = "N" and size(A,1) < size(A,2), then rows 1
!!             to size(A,2) of B contain, columnwise, the minimum norm
!!             solution vector(s).
!!          3. If TRANS = "T" or TRANS = "C", and size(A,1)>=size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             minimum norm solution vector(s).
!!          4. If TRANS = "T" or TRANS = "C", and size(A,1) < size(A,2),
!!             then rows 1 to size(A,1) of B contain, columnwise, the
!!             least squares solution vector(s); the residual sum of
!!             squares for the solution vector in a column of B is given
!!             by the sum of squares of elements in rows size(A,1)+1 to
!!             size(A,2) of that column.
!! TRANS    Optional (input) CHARACTER(LEN=1).
!!          Specifies the form of the system of equations:
!!          = "N": Ax = b (No transpose)
!!          = "T": A^T*x = b (Transpose)
!!          = "C": A^H*x = b (Conjugate transpose)
!!          Default value: "N".
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!---------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GELS"
    CHARACTER(LEN=1), PARAMETER :: VER = "Z"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LTRANS
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, NRHS
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(TRANS) )THEN; LTRANS = TRANS; ELSE; LTRANS = "N"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR. LSAME(LTRANS,"C") ) )THEN; LINFO = -3
    ELSE
!!   .. CALCULATE THE OPTIMAL WORKSPACE ..
       LWORK = LA_WS_GELS( VER, M, N, NRHS, LTRANS )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 ); LWORK = MIN(M,N) + MAX(1,M,N,NRHS)
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELS_F77( LTRANS, M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         WORK, LWORK, LINFO )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGELS_F95
SUBROUTINE ZGELSD1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL, LRWORK
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
       SMLSIZ = ILAENV_F77( 9, "ZGELSD", " ", 0, 0, 0, 0 )
       NLVL = MAX(INT(LOG(DBLE(MAX(1,MN))/DBLE(SMLSIZ+1))/LOG(TWO)),0)
!! NEXT LINE SHOULD BE  LIWORK = 3 * MN * NLVL + 11 * MN, WHEN THE LAPACK CODE IS FIXED
       LIWORK = 2*(3 * MN * NLVL + 11 * MN)
       LRWORK = 8  * MN + 2*MN*SMLSIZ + 8*MN*NLVL + MN

       LRWORK = 25000
       ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF

       IF( PRESENT(RCOND) )THEN; LRCOND = RCOND
       ELSE; LRCOND = 100*EPSILON(1.0_WP); ENDIF
       IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
       IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
       ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N)) THEN; LINFO = -2
       ELSE IF( SS /= MN ) THEN; LINFO = -4
       ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
       ELSE
          IF( PRESENT(S) )THEN; LS => S
          ELSE
            ALLOCATE( LS(MN), STAT = ISTAT );
            IF (ISTAT /= 0) THEN ;
             LINFO=-200; GOTO 200; ENDIF
          END IF
          LWORK=-1

          CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &         LS, LRCOND, LRANK, WORKMIN, LWORK, RWORK, IWORKMIN, LINFO )
          LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED, WHEN THE LAPACK CODE IS FIXED.
          LWORK = 10 * LWORK
          ALLOCATE( WORK(LWORK), IWORK(LIWORK), STAT = ISTAT )
          IF (ISTAT /= 0) THEN;
            LINFO=-300; GOTO 300
          ENDIF

          CALL GELSD_F77( M, N, 1, A, MAX(1,M), B, SIZE(B,1), &
     &      LS, LRCOND, LRANK, WORK, LWORK, RWORK, IWORK, LINFO )

          IF( PRESENT(RANK) ) RANK = LRANK
          DEALLOCATE(WORK, IWORK, STAT = ISTAT)
300       IF (.NOT. PRESENT(S)) DEALLOCATE(LS, STAT = ISTAT)
        END IF
200     DEALLOCATE(RWORK, STAT = ISTAT)
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGELSD1_F95
SUBROUTINE ZGELSD_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSD_F77 => LA_GELSD,  ILAENV_F77 => ILAENV    !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSD"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, LWORK, N, M, MN, NRHS, LRANK, SS, &
     &  LIWORK, SMLSIZ, NLVL, LRWORK
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: LS(:)
      INTEGER, POINTER :: IWORK(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
      DOUBLE PRECISION  TWO
      PARAMETER       ( TWO = 2.0D0 )
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
       SMLSIZ = ILAENV_F77( 9, "ZGELSD", " ", 0, 0, 0, 0 )
       NLVL = MAX(INT(LOG(DBLE(MAX(1,MN))/DBLE(SMLSIZ+1))/LOG(TWO)),0)
!! NEXT LINE SHOULD BE  LIWORK = 3 * MN * NLVL + 11 * MN, WHEN THE LAPACK CODE IS FIXED
       LIWORK = 2*(3 * MN * NLVL + 11 * MN)
       LRWORK = 8  * MN + 2*MN*SMLSIZ + 8*MN*NLVL + MN*NRHS

       LRWORK = 25000
       ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF

       IF( PRESENT(RCOND) )THEN; LRCOND = RCOND
       ELSE; LRCOND = 100*EPSILON(1.0_WP); ENDIF
       IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
       IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
       ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
       ELSE IF( SS /= MN ) THEN; LINFO = -4
       ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
       ELSE
          IF( PRESENT(S) )THEN; LS => S
          ELSE
            ALLOCATE( LS(MN), STAT = ISTAT );
            IF (ISTAT /= 0) THEN ;
             LINFO=-200; GOTO 200; ENDIF
          END IF
          LWORK=-1

          CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &         LS, LRCOND, LRANK, WORKMIN, LWORK, RWORK, IWORKMIN, LINFO )
          LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED, WHEN THE LAPACK CODE IS FIXED.
          LWORK = 10 * LWORK
          ALLOCATE( WORK(LWORK), IWORK(LIWORK), STAT = ISTAT )
          IF (ISTAT /= 0) THEN;
            LINFO=-300; GOTO 300
          ENDIF

          CALL GELSD_F77( M, N, NRHS, A, MAX(1,M), B, SIZE(B,1), &
     &      LS, LRCOND, LRANK, WORK, LWORK, RWORK, IWORK, LINFO )

          IF( PRESENT(RANK) ) RANK = LRANK
          DEALLOCATE(WORK, IWORK, STAT = ISTAT)
300       IF (.NOT. PRESENT(S)) DEALLOCATE(LS, STAT = ISTAT)
        END IF
200     DEALLOCATE(RWORK, STAT = ISTAT)
100     CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGELSD_F95
 SUBROUTINE ZGELSS1_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "Z"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: RWORK(:), LS(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = 1; MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          ALLOCATE( RWORK( MAX(1, 5*MIN(M,N) -4)), STAT = ISTAT )
       END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 2*MIN(M,N) + MAX( M, N, NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGELSS1_F95
 SUBROUTINE ZGELSS_F95( A, B, RANK, S, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LA_WS_GELSS                             !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSS_F77 => LA_GELSS                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
    REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: S(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!
!!       LA_GELSS and LA_GELSD compute the minimum-norm least squares
!! solution to one or more real or complex linear systems A*x = b using
!! the singular value decomposition of A. Matrix A is rectangular and may
!! be rank-deficient. The vectors b and corresponding solution vectors x
!! are the columns of matrices denoted B and X , respectively.
!!       The effective rank of A is determined by treating as zero those
!! singular values which are less than RCOND times the largest singular
!! value. In addition to X , the routines also return the right singular
!! vectors and, optionally, the rank and singular values of A.
!!       LA_GELSD combines the singular value decomposition with a divide
!! and conquer technique. For large matrices it is often much faster than
!! LA_GELSS but uses more workspace.
!!
!! ==========
!!
!!        SUBROUTINE LA_GELSS / LA_GELSD( A, B, RANK=rank, S=s, &
!!                                          RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!             INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, the first min(size(A,1), size(A,2)) rows of A are
!!         overwritten with its right singular vectors, stored rowwise.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1), size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution in a column of B is given by
!!         the sum of squares of elements in rows size(A,2)+1:size(A,1)
!!         of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the number of singular values
!!         of A which are greater than the product RCOND*sigma1 , where
!!         sigma1 is the greatest singular value.
!! S       Optional (output) REAL array, shape (:) with size(S) =
!!         min(size(A,1), size(A,2)).
!!         The singular values of A in decreasing order.
!!         The condition number of A in the 2-norm is
!!         K2(A)= sigma1/sigma(min(size(A,1),size(A,2)) .
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A.
!!         Singular values sigma(i)<=RCOND*sigma1  are treated as zero.
!!         Default value: 10*max(size(A,1), size(A,2))*EPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm for computing the SVD failed to converge;
!!         if INFO = i,i off-diagonal elements of an intermediate
!!         bidiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSS"
    CHARACTER(LEN=1), PARAMETER :: VER = "Z"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SS
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    REAL(WP), POINTER :: RWORK(:), LS(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(S) )THEN; SS = SIZE(S); ELSE; SS =MN; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SS /= MN ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
       IF( PRESENT(S) )THEN; LS => S
       ELSE; ALLOCATE( LS(MN), STAT = ISTAT ); END IF
       IF( ISTAT == 0 ) THEN
          ALLOCATE( RWORK( MAX(1, 5*MIN(M,N) -4)), STAT = ISTAT )
       END IF
       IF( ISTAT == 0 ) THEN
          LWORK = LA_WS_GELSS( VER, M, N, NRHS )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT /= 0 ) THEN
             DEALLOCATE( WORK, STAT=ISTAT1 )
             LWORK = MAX( 1, 2*MIN(M,N) + MAX( M, N, NRHS ) )
             ALLOCATE( WORK(LWORK), STAT = ISTAT )
             IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF
       END IF
       IF ( ISTAT == 0 ) THEN
          CALL GELSS_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                         LS, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
       ELSE; LINFO = -100; END IF
       IF( PRESENT(RANK) ) RANK = LRANK
       DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGELSS_F95
 SUBROUTINE ZGELSX1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    COMPLEX(WP), POINTER :: WORK(:)
    REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
        LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE
         ALLOCATE( LJPVT(N), STAT = ISTAT )
         IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 100; END IF
         LJPVT = 0
       END IF
       LWORK = 2*MAX( 1, MIN(M,N) + MAX( N,2*MIN(M,N) + 1 ) )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 200; END IF
       ALLOCATE( RWORK(MAX(1,2*N)), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 300; END IF

       CALL GELSX_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
                      LJPVT, LRCOND, LRANK, WORK, RWORK, LINFO )

       IF( PRESENT(RANK) ) RANK = LRANK
!!       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(RWORK, STAT = ISTAT1 )
300    DEALLOCATE(WORK, STAT = ISTAT1 )
200    IF (.NOT. PRESENT(JPVT)) DEALLOCATE(LJPVT, STAT = ISTAT1 )
     END IF
100 CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGELSX1_F95
 SUBROUTINE ZGELSX_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GELSX_F77 => LA_GELSX                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: RANK
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
    REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GELSX computes the minimum-norm solution to a real linear least
!! squares problem:
!!     minimize || A * X - B ||
!! using a complete orthogonal factorization of A.  A is an m-by-n
!! matrix which may be rank-deficient.
!! Several right hand side vectors b and solution vectors x can be
!! handled in a single call; they are stored as the columns of the
!! M-by-NRHS right hand side matrix B and the n-by-nrhs solution
!! matrix X.
!! The routine first computes a QR factorization with column pivoting:
!!     A * P = Q * [ R11 R12 ]
!!                 [  0  R22 ]
!! with R11 defined as the largest leading submatrix whose estimated
!! condition number is less than 1/RCOND.  The order of R11, RANK,
!! is the effective rank of A.
!! Then, R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal transformations from the right, arriving at the
!! complete orthogonal factorization:
!!    A * P = Q * [ T11 0 ] * Z
!!                [  0  0 ]
!! The minimum-norm solution is then
!!    X = P * Z" [ inv(T11)*Q1"*B ]
!!               [        0       ]
!! where Q1 consists of the first RANK columns of Q.
!
!
!! Arguments
!! =========
!
!!  SUBROUTINE LA_GELSX( A, B, RANK, JPVT, RCOND, INFO )
!!    <type>(<wp>), INTENT( INOUT ) :: A( :, : ), <rhs>
!!    INTEGER, INTENT(IN), OPTIONAL :: RANK
!!    INTEGER, INTENT(OUT), OPTIONAL :: JPVT(:)
!!    REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A    (input/output) Deither REAL or COMPLEX array, shape (:,:),
!!      SIZE(A,1) == m, SIZE(A,2) == n.
!!      On entry, the m-by-n matrix A.
!!      On exit, A has been overwritten by details of its
!!      complete orthogonal factorization.
!!      INFO = -1 if SIZE(A,1) < 0 or SIZE(A,2) < 0
!
!! B    Optional (input/output) either REAL or COMPLEX array, shape either
!!      (:,:) or (:), size(B,1) or size(B) == size(A,1). SIZE(B,2) == nrhs.
!!      On entry, the m-by-nrhs right hand side matrix B.
!!      On exit, the n-by-nrhs solution matrix X.
!!      If m >= n and RANK = n, the residual sum-of-squares for
!!      the solution in the i-th column is given by the sum of
!!      squares of elements n+1:m in that column.
!!      INFO = -2 if SIZE(B,1) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                    and if shape of B is (:,:) or
!!                if SIZE(B) /= max(SIZE(A,1), SIZE(A,2)) or SIZE(B,2) < 0
!!                   and if shape of B is (:)
!
!! RANK Optional (output) INTEGER
!!      The effective rank of A, i.e., the order of the submatrix
!!      R11.  This is the same as the order of the submatrix T11
!!      in the complete orthogonal factorization of A.
!
!! JPVT Optional (input/output) INTEGER array, shape (:), SIZE(JPVT) == n
!!      On entry, if JPVT(i) .ne. 0, the i-th column of A is an
!!      initial column, otherwise it is a free column.  Before
!!      the QR factorization of A, all initial columns are
!!      permuted to the leading positions; only the remaining
!!      free columns are moved as a result of column pivoting
!!      during the factorization.
!!      On exit, if JPVT(i) = k, then the i-th column of A*P
!!      was the k-th column of A.
!!      INFO = -4 if SIZE(S) /= SIZE(A,2)
!
!! RCOND Optional (input) REAL
!!      RCOND is used to determine the effective rank of A, which
!!      is defined as the order of the largest leading triangular
!!      submatrix R11 in the QR factorization with pivoting of A,
!!      whose estimated condition number < 1/RCOND.
!
!! INFO    (output) INTEGER
!!      = 0:  successful exit
!!      < 0:  if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!--------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSX"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
    REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LJPVT(:)
    COMPLEX(WP), POINTER :: WORK(:)
    REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
    MN = MIN(M,N)
    IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
       LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
    IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( SJPVT /= N ) THEN; LINFO = -4
    ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
    ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
       ELSE
         ALLOCATE( LJPVT(N), STAT = ISTAT )
         IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 100; END IF
         LJPVT = 0
       END IF
       LWORK = 2*MAX( 1, MIN(M,N) + MAX( N,2*MIN(M,N) + NRHS ) )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 200; END IF
       ALLOCATE( RWORK(MAX(1,2*N)), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN; LINFO = -200; GOTO 300; END IF

       CALL GELSX_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
                      LJPVT, LRCOND, LRANK, WORK, RWORK, LINFO )

       IF( PRESENT(RANK) ) RANK = LRANK
!!       IF( PRESENT(JPVT) ) JPVT = LJPVT
       DEALLOCATE(RWORK, STAT = ISTAT1 )
300    DEALLOCATE(WORK, STAT = ISTAT1 )
200    IF (.NOT. PRESENT(JPVT)) DEALLOCATE(LJPVT, STAT = ISTAT1 )
     END IF
100 CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGELSX_F95
      SUBROUTINE ZGELSY1_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      COMPLEX(WP), POINTER :: WORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
         LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= MAX(1,M,N)) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF

        ALLOCATE(RWORK(2*N), STAT=ISTAT)
        IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, RWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, 1, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE ZGELSY1_F95
      SUBROUTINE ZGELSY_F95( A, B, RANK, JPVT, RCOND, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GELSY_F77 => LA_GELSY                           !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: RANK
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(IN), OPTIONAL :: RCOND
!!   .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: JPVT(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GELSY computes the minimum-norm least squares solution to one
!! or more real or complex linear systems A*x = b using a complete
!! orthogonal factorization of A. Matrix A is rectangular and may be
!! rankdeficient. The vectors b and corresponding solution vectors x are
!! the columns of matrices denoted B and X, respectively.
!!     The routine computes a QR factorization of A with column pivoting:
!!           A * P = Q * [ R11 R12 ]
!!                       [  0  R22 ]
!! where R11 is the largest leading submatrix whose estimated condition
!! number is less than 1/RCOND. The order of R11, RANK, is the effective
!! rank of A. R22 is considered to be negligible, and R12 is annihilated
!! by orthogonal (unitary) transformations from the right, yielding the
!! complete orthogonal (unitary) factorization
!!           A * P = Q * [ T11  0  ] * Z
!!                     [  0   0  ]
!! The minimum-norm least squares solution is then
!!           x = P * Z^H [ T11^-1 * Q1^H * b ]
!!                     [        0          ]
!! where Q1 consists of the first RANK columns of Q.
!!
!! =========
!!
!!          SUBROUTINE LA_GELSY( A, B, RANK=rank, &
!!                     JPVT= jpvt, RCOND= rcond, INFO= info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!              INTEGER, INTENT(OUT), OPTIONAL :: RANK
!!              INTEGER, INTENT(INOUT), OPTIONAL :: JPVT(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been overwritten by details of its complete
!!         orthogonal factorization.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = max(size(A,1),size(A,2)) or shape (:) with
!!         size(B) = max(size(A,1), size(A,2)).
!!         On entry, the matrix B.
!!         On exit, rows 1 to size(A,2) contain the solution matrix X .
!!         If size(A,1) >= size(A,2) and RANK = size(A,2), the residual
!!         sum-of-squares for the solution vector in a column of B is
!!         given by the sum of squares of elements in rows size(A,2)+1 :
!!         size(A,1) of that column.
!! RANK    Optional (output) INTEGER.
!!         The effective rank of A, i.e., the order of the submatrix R11.
!!         This is the same as the order of the submatrix T11 in the
!!         complete orthogonal factorization of A.
!! JPVT    Optional (input/output) INTEGER array, shape (:) with
!!         size(JPVT) = size(A,2).
!!         On entry, if JPVT(i) /= 0, the i-th column of A is an initial
!!         column, otherwise it is a free column.
!!         Before the QR factorization of A, all initial columns are
!!         permuted to the leading positions; only the remaining free
!!         columns are moved as a result of column pivoting during the
!!         factorization.
!!         On exit, if JPVT(i) = k, then the i-th column of the matrix
!!         product A*P was the k-th column of A.
!! RCOND   Optional (input) REAL.
!!         RCOND is used to determine the effective rank of A. This is
!!         defined as the order of the largest leading triangular
!!         submatrix R11 in the QR factorization of A, with pivoting,
!!         whose estimated condition number < 1/RCOND.
!!         Default value: 10*max(size(A,1),size(A,2))*BEPSILON(1.0_<wp>),
!!         where <wp> is the working precision.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GELSY"
!!   .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, LWORK, N, M, MN, NRHS, LRANK, SJPVT
      REAL(WP) :: LRCOND
!!   .. LOCAL POINTERS ..
      INTEGER, POINTER :: LJPVT(:)
      COMPLEX(WP), POINTER :: WORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
!!   .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX, MIN, EPSILON
!!   .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); NRHS = SIZE(B,2)
      MN = MIN(M,N)
      IF( PRESENT(RCOND) )THEN; LRCOND = RCOND; ELSE
          LRCOND = 100*EPSILON(1.0_WP) ; ENDIF
      IF( PRESENT(JPVT) )THEN; SJPVT = SIZE(JPVT); ELSE; SJPVT = N; ENDIF
!!   .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= MAX(1,M,N) .OR. NRHS < 0 ) THEN; LINFO = -2
      ELSE IF( SJPVT /= N ) THEN; LINFO = -4
      ELSE IF( LRCOND <= 0.0_WP ) THEN; LINFO = -5
      ELSE
        IF( PRESENT(JPVT) )THEN; LJPVT => JPVT
        ELSE; ALLOCATE( LJPVT(N), STAT = ISTAT ); LJPVT = 0; END IF

        ALLOCATE(RWORK(2*N), STAT=ISTAT)
        IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
          LWORK = -1
          CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORKMIN, LWORK, RWORK, LINFO )
          LWORK = WORKMIN(1)
          IF( ISTAT == 0 ) THEN
            ALLOCATE( WORK(LWORK), STAT = ISTAT )
            IF( ISTAT /= 0 ) CALL ERINFO( -200, SRNAME, LINFO )
          END IF

          IF ( ISTAT == 0 ) THEN
            CALL GELSY_F77( M, N, NRHS, A, MAX(1,M), B, MAX(1,M,N), &
     &      LJPVT, LRCOND, LRANK, WORK, LWORK, RWORK, LINFO )
          ELSE; LINFO = -100; END IF
            IF( PRESENT(RANK) ) RANK = LRANK
            IF( PRESENT(JPVT) ) JPVT = LJPVT
            DEALLOCATE(WORK, RWORK, STAT = ISTAT1 )
          END IF
          CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
        END SUBROUTINE ZGELSY_F95
SUBROUTINE ZGERFS1_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(IN) :: A(:,:), AF(:,:)
   COMPLEX(WP), INTENT(IN) :: B(:)
   COMPLEX(WP), INTENT(INOUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: N, LINFO, ISTAT, ISTAT1, LD
   REAL(WP) :: LFERR, LBERR
!!  .. LOCAL ARRAYS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); ISTAT = 0; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N ) THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, 1, A, LD, AF, LD, IPIV, &
                    B, LD, X, LD, LFERR, LBERR, WORK, RWORK, LINFO )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGERFS1_F95
SUBROUTINE ZGERFS_F95(A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GERFS_F77 => LA_GERFS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN), TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(IN) :: A(:,:), AF(:,:), B(:,:)
   COMPLEX(WP), INTENT(INOUT) :: X(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GERFS improves the computed solution X of a system of linear
!! equations   A X = B  or  A^T X = B
!! and provides error bounds and backward error estimates for
!! the solution. LA_GERFS uses the LU factors computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GERFS (A, AF, IPIV, B, X, TRANS, FERR, BERR, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:), AF(:,:), <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    <type>(<wp>), INTENT(INOUT) :: <sol>
!!    REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!!    <sol>  ::= X(:,:) | X(:)
!!    <err>  ::= FERR(:), BERR(:) | FERR, BERR
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The original matrix A.
!
!! AF    (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(AF,1) == size(AF,2) == size(A,1).
!!       The factors L and U from the factorization A = PLU
!!       as computed by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       The right hand side vector(s) of matrix B for
!!       the system of equations AX = B.
!
!! X     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(X,1) or size(X) == size(A,1).
!!       On entry, the solution matrix X, as computed by LA_GETRS.
!!       On exit, the improved solution matrix X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!       of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! FERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(FERR) == size(X,2).
!!       The estimated forward error bound for each solution vector
!!       X(j) (the j-th column of the solution matrix X).
!!       If XTRUE is the true solution corresponding to X(j), FERR(j)
!!       is an estimated upper bound for the magnitude of the largest
!!       element in (X(j) - XTRUE) divided by the magnitude of the
!!       largest element in X(j).  The estimate is as reliable as
!!       the estimate for RCOND, and is almost always a slight
!!       overestimate of the true error.
!
!! BERR  Optional (output) either REAL array of shape (:) or REAL
!!       scalar. If it is an array, size(BERR) == size(X,2).
!!       The componentwise relative backward error of each solution
!!       vector X(j) (i.e., the smallest relative change in
!!       any element of A or B that makes X(j) an exact solution).
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!
!! Internal Parameters
!! ===================
!
!! ITMAX is the maximum number of steps of iterative refinement.
!! It is set to 5 in the LAPACK77 subroutines
!! -----------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GERFS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SFERR, SBERR
!!  .. LOCAL ARRAYS, POINTERS ..
   REAL(WP), POINTER :: RWORK(:)
   REAL(WP), POINTER :: LFERR(:), LBERR(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(AF, 1) /= N .OR. SIZE(AF, 2) /= N )THEN; LINFO = -2
   ELSE IF ( SIZE( IPIV ) /= N ) THEN; LINFO = -3
   ELSE IF ( SIZE(B, 1) /= N ) THEN; LINFO = -4
   ELSE IF ( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS ) THEN; LINFO = -5
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -6
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -7
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -8
   ELSE IF ( N > 0 ) THEN
      IF( .NOT.PRESENT(FERR) ) THEN
         ALLOCATE( LFERR(NRHS), STAT=ISTAT )
      ELSE; LFERR => FERR; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) ) THEN
            ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN; ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT ); END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL GERFS_F77( LTRANS, N, NRHS, A, MAX(1,N), AF, MAX(1,N), &
                         IPIV, B, MAX(1,N), X, MAX(1,N), LFERR, &
                         LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGERFS_F95
SUBROUTINE ZGESDD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESDD_F77 => LA_GESDD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESDD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, JOBZ
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, S1U, S2U, S1VT, S2VT, &
&             MN, LRWORK
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLVT(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   COMPLEX(WP), ALLOCATABLE :: W1(:,:), W2(:,:)
   REAL(WP), POINTER :: RWORK(:)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)

   IF( PRESENT(JOB) )THEN; LJOBZ = JOB; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF(.NOT. (LSAME(LJOBZ, "N") .OR. LSAME(LJOBZ,"U") .OR. LSAME(LJOBZ, "V"))) THEN ; LINFO = -6
   ELSE
        LWORK = MAX(1, 2*MN*MN+2*MN+MAX(M,N))
        LWORK = 5*LWORK

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF( ISTAT == 0 ) THEN
          ALLOCATE(IWORK(5*(8*MIN(M,N))), STAT=ISTAT)
          IF (ISTAT == 0 ) THEN
         LRWORK = (5*MIN(M,N)*MIN(M,N) + 7*MIN(M,N))
!! NEXT LINE SHOULD BE REMOVED WHEN LAPACK IS FIXED
         LRWORK = 5*LRWORK
         ALLOCATE(RWORK(LRWORK), STAT = ISTAT)
         IF( ISTAT == 0 ) THEN
           IF (.NOT.PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
             ALLOCATE(W1(M,M), W2(N,N), STAT=ISTAT)
             IF (ISTAT == 0) THEN
               IF (.NOT. LSAME(LJOBZ, "N")) THEN
                 JOBZ = "S"
               ELSE
                 JOBZ = "N"
               ENDIF
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
               SELECT CASE(LJOBZ)
                 CASE ("U")
                   A(1:MN, 1:MN) = W1(1:MN, 1:MN)
                 CASE ("V")
                   A(1:MN, 1:MN) = W2(1:MN, 1:MN)
               END SELECT
               DEALLOCATE(W1, W2)
             ELSE
               LINFO = -100
             END IF
           ELSE IF (.NOT. PRESENT(U) .AND. PRESENT(VT)) THEN
             JOBZ = "A"
             ALLOCATE(W1(M,M), STAT=ISTAT)
             IF (ISTAT == 0) THEN
              IF (PRESENT (VT)) THEN
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                VT, MAX(1, S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
              ELSE
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, W1, MAX(1,M), &
&                LLVT, MAX(1, S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
             ENDIF
               IF (LSAME(LJOBZ, "U")) THEN
                 A(1:M, 1:MN) = W1(1:M, 1:MN)
               END IF
               DEALLOCATE(W1)
             ELSE
               LINFO = -100
             END IF
           ELSE IF (PRESENT(U) .AND. .NOT. PRESENT(VT)) THEN
             JOBZ = "A"
             ALLOCATE(W2(N,N), STAT=ISTAT)
             IF (ISTAT == 0) THEN
              IF (PRESENT (U)) THEN
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
              ELSE
               CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                W2, MAX(1,N), WORK, LWORK, RWORK, IWORK, LINFO )
              ENDIF
               IF (LSAME(LJOBZ, "V")) A(1:MN, 1:N) = W2(1:MN, 1:N)
               DEALLOCATE(W2)
             ELSE
               LINFO = -100
             END IF
           ELSE
             JOBZ = "A"
             IF (PRESENT (VT)) THEN
               IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                    VT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                    VT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ENDIF
             ELSE
               IF (PRESENT (U)) THEN
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, U, MAX(1,S1U), &
&                    LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ELSE
                  CALL GESDD_F77(JOBZ, M, N, A, LD, S, LLU, MAX(1,S1U), &
&                    LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, IWORK, LINFO )
               ENDIF
             ENDIF
             IF (PRESENT(WW)) WW = WORK(1)
           ENDIF
           DEALLOCATE(RWORK, STAT=ISTAT)
         ELSE
           LINFO = -100
         END IF
         DEALLOCATE(IWORK, STAT=ISTAT)
       ELSE
         LINFO = -100
       END IF
       DEALLOCATE(WORK, STAT=ISTAT)
     ENDIF
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
    END SUBROUTINE ZGESDD_F95
      SUBROUTINE ZGESV1_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!     .. PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN; LINFO = -1
      ELSE IF( SIZE( B ) /= SIZE(A,1) ) THEN; LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN; LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN; LPIV => IPIV
         ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
         IF ( ISTAT == 0 ) THEN
!!        .. CALL LAPACK77 ROUTINE ..
            CALL GESV_F77( SIZE(A,1), 1, A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)),         &
                           LINFO )
         ELSE; LINFO = -100; END IF
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE(LPIV, STAT = ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE ZGESV1_F95
      SUBROUTINE ZGESV_F95( A, B, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESV_F77 => LA_GESV                             !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GESV"
!!     .. LOCAL SCALARS ..
      INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV
!!     .. "Local Pointers" ..
      INTEGER, POINTER :: LPIV(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; ISTAT = 0
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = SIZE(A,1)
      END IF
!!     .. "Test the arguments" ..
      IF( SIZE( A, 2 ) /= SIZE(A,1) .OR. SIZE(A,1) < 0 ) THEN
         LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= SIZE(A,1) .OR. SIZE(B,2) < 0 ) THEN
         LINFO = -2
      ELSE IF( SIPIV /= SIZE(A,1) )THEN
            LINFO = -3
      ELSE IF ( SIZE(A,1) > 0 ) THEN
         IF( PRESENT(IPIV) )THEN
            LPIV => IPIV
         ELSE
            ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT )
         END IF
         IF ( ISTAT == 0 ) THEN
!!        .. "Call LAPACK77 routine" ..
            CALL GESV_F77( SIZE(A,1), SIZE(B,2), A, MAX(1,SIZE(A,1)), LPIV, B, MAX(1,SIZE(A,1)), &
                           LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            DEALLOCATE(LPIV, STAT = ISTAT1 )
         END IF
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE ZGESV_F95
SUBROUTINE ZGESVD_F95( A, S, U, VT, WW, JOB, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GESVD_F77 => LA_GESVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), OPTIONAL, INTENT(IN) :: JOB
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL :: WW(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), VT(:,:)
!----------------------------------------------------------------------
!!
!!  Purpose
!!  =======
!!
!!       LA_GESVD and LA_GESDD compute the singular values and,
!! optionally, the left and/or right singular vectors from the singular
!! value decomposition  (SVD) of a real or complex m by n matrix A. The
!! SVD of A is written
!!                    A = U * SIGMA * V^H
!! where SIGMA is an  m by n matrix which is zero except for its
!! min(m, n) diagonal elements, U is an m by m orthogonal (unitary)
!! matrix, and V is an n by n orthogonal (unitary) matrix. The diagonal
!! elements of SIGMA , i.e., the values
!!
!!      sigma(i)= SIGMA(i,i), i = 1, 2,..., min(m, n)
!! are the singular values of A; they are real and non-negative, and are
!! returned in descending order. The first min(m, n) columns of U and V
!! are the left and right singular vectors of A, respectively.
!! LA_GESDD solves the same problem as LA_GESVD but uses a divide and
!! conquer method if singular vectors are desired. For large matrices it
!! is usually much faster than LA_GESVD when singular vectors are
!! desired, but uses more workspace.
!!
!! Note: The routine returns V^H , not V .
!!
!! ========
!!
!!    SUBROUTINE LA_GESVD / LA_GESDD( A, S, U=u, VT=vt, &
!!              WW=ww, JOB=job, INFO=info )
!!      <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!      REAL(<wp>), INTENT(OUT) :: S(:)
!!      <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), VT(:,:)
!!      REAL(<wp>), INTENT(OUT), OPTIONAL :: WW(:)
!!      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOB
!!      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!      <type> ::= REAL | COMPLEX
!!      <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:, :) with
!!        size(A, 1) = m and size(A, 2) = n.
!!        On entry, the matrix A.
!!        On exit, if JOB = "U" and U is not present, then A is
!!        overwritten with the first min(m, n) columns of U (the left
!!        singular vectors, stored columnwise).
!!        If JOB = "V" and VT is not present, then A is overwritten with
!!        the first min(m, n) rows of V^H (the right singular vectors,
!!        stored rowwise).
!!        In all cases the original contents of A are destroyed.
!! S      (output) REAL array, shape (:) with size(S) = min(m, n).
!!        The singular values of A, sorted so that S(i) >= S(i+1).
!! U      Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(U, 1) = m  and size(U, 2) = m or min(m, n).
!!        If size(U, 2) = m, U contains the m by m matrix U .
!!        If size(U; 2) = min(m, n), U contains the first min(m, n)
!!        columns of U (the left singular vectors, stored columnwise).
!! VT     Optional (output) REAL or COMPLEX array, shape (:, :) with
!!        size(VT, 1) = n or min(m, n) and size(VT, 2) = n.
!!        If size(VT, 1) = n , VT contains the n by n matrix V^H .
!!        If size(VT, 1) = min(m, n), VT contains the first min(m, n)
!!        rows of V^H (the right singular vectors, stored rowwise).
!! WW     Optional (output) REAL array, shape (:) with size(WW) =
!!        min(m, n) - 1
!!        If INFO > 0, WW contains the unconverged superdiagonal elements
!!        of an upper bidiagonal matrix B whose diagonal is in SIGMA (not
!!        necessarily sorted). B has the same singular values as A.
!!        Note: WW is a dummy argument for LA_GESDD.
!! JOB    Optional (input) CHARACTER(LEN=1).
!!        = "N": neither columns of U nor rows of V^H are returned in
!!          array A.
!!        = "U": if U is not present, the first min(m, n) columns of U
!!          (the left singular vectors) are returned in array A;
!!        = "V": if VT is not present, the first min(m, n) rows of V^H
!!          (the right singular vectors) are returned in array A;
!!        Default value: "N".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: The algorithm did not converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOB
   CHARACTER(LEN=1) :: LJOBU, LJOBVT
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, M, LINFO, LD, ISTAT, ISTAT1, S1U, S2U, S1VT, S2VT, &
              NN, MN, SWW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLVT(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MIN, MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2)
   LD = MAX(1,M); MN = MIN(M,N)
   IF( PRESENT(JOB) )THEN; LJOB = JOB; ELSE; LJOB = "N"; ENDIF
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2)
   ELSE; S1U = 1; S2U = 1; END IF
   IF( PRESENT(VT) )THEN; S1VT = SIZE(VT,1); S2VT = SIZE(VT,2)
   ELSE; S1VT = 1; S2VT = 1; END IF
   IF( PRESENT(WW) )THEN; SWW = SIZE(WW); ELSE; SWW = MN-1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( S ) /= MN )THEN; LINFO = -2
   ELSE IF( PRESENT(U) .AND. ( S1U /= M .OR. &
            ( S2U /= M .AND. S2U /= MN ) ) )THEN; LINFO = -3
   ELSE IF( PRESENT(VT) .AND. ( ( S1VT /= N .AND. S1VT /= MN ) &
            .OR. S2VT /= N ) )THEN; LINFO = -4
   ELSE IF( SWW /= MN-1 .AND. MN > 0 ) THEN; LINFO = -5
   ELSE IF( PRESENT(JOB) .AND. ( .NOT. ( LSAME(LJOB,"U") .OR. &
            LSAME(LJOB,"V") .OR. LSAME(LJOB,"N") ) .OR. &
            LSAME(LJOB,"U") .AND. PRESENT(U) .OR. &
            LSAME(LJOB,"V") .AND. PRESENT(VT)) )THEN; LINFO = -6
   ELSE
      IF( PRESENT(U) )THEN
         IF( S2U == M )THEN; LJOBU = "A"; ELSE; LJOBU = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"U") ) THEN; LJOBU = "O"
         ELSE; LJOBU = "N"; ENDIF
      ENDIF
      IF( PRESENT(VT) )THEN
         IF( S1VT == N )THEN; LJOBVT = "A"; ELSE; LJOBVT = "S"; ENDIF
      ELSE; IF( LSAME(LJOB,"V") )THEN; LJOBVT = "O"
         ELSE; LJOBVT = "N"; ENDIF
      ENDIF
        ALLOCATE( RWORK( MAX(1, 5*MIN(M,N))), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
        LWORK = -1
        IF( PRESENT(U) ) THEN
        IF ( PRESENT(VT) )THEN
        CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
&             VT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ENDIF
         ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             VT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
 &             LLVT, MAX(1,S1VT), WORKMIN, LWORK, RWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = WORKMIN(1)
!! THE NEXT LINE SHOULD BE REMOVED
         LWORK = LWORK + 1
         ALLOCATE(WORK(LWORK), STAT = ISTAT)
         IF( ISTAT /= 0 )THEN
           DEALLOCATE(WORK,STAT=ISTAT1)
         NN = 2*MIN(M,N)+MAX(M,N)
         LWORK = MAX( 1, NN); ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT == 0) CALL ERINFO( -200, SRNAME, LINFO )
         END IF
      END IF
      IF( ISTAT == 0 ) THEN
          IF( PRESENT(U) ) THEN
            IF ( PRESENT(VT) )THEN
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
              VT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
            ELSE
              CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, U, MAX(1,S1U), &
&             LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
            ENDIF
          ELSE
           IF ( PRESENT(VT) )THEN
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
&             VT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
           ELSE
             CALL GESVD_F77( LJOBU, LJOBVT, M, N, A, LD, S, LLU, MAX(1,S1U), &
&             LLVT, MAX(1,S1VT), WORK, LWORK, RWORK, LINFO )
           ENDIF
         ENDIF
         LWORK = INT(WORK(1)+1)
         IF( LINFO > 0 .AND. PRESENT(WW) ) WW(1:MN-1) = RWORK(1:MN-1)
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGESVD_F95
      SUBROUTINE ZGESVX1_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,    &
                              RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
      COMPLEX(WP), INTENT(OUT) :: X(:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL :: FERR, BERR
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SC, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC, LFERR, LBERR
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), RWORK(:)
      COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
      ELSE; LEQUED="N"; END IF
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
      IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE; S1AF = N; S2AF = N; END IF
      IF( ( PRESENT(C) ) )THEN; SC = SIZE(C); ELSE; SC = N; END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN; MVC = MINVAL(C)
      ELSE; MVC = TINY(1.0_WP); END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B) /= N )THEN
         LINFO = -2
      ELSE IF( SIZE(X) /= N )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( .NOT.PRESENT(IPIV) )THEN
            ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE
            LPIV => IPIV
         END IF
         IF( .NOT.PRESENT(R) )THEN
            ALLOCATE( LR(N), STAT=ISTAT )
         ELSE
            LR => R
         END IF
         IF( .NOT.PRESENT(C) )THEN
            ALLOCATE( LC(N), STAT=ISTAT )
         ELSE
            LC => C
         END IF
            ALLOCATE(WORK(2*N), RWORK(2*N), STAT=ISTAT )
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( PRESENT(FERR) ) FERR = LFERR
         IF( PRESENT(BERR) ) BERR = LBERR
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
         DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE ZGESVX1_F95
      SUBROUTINE ZGESVX_F95( A, B, X, AF, IPIV, FACT, TRANS, EQUED, R, C, FERR, BERR, RCOND,     &
                             RPVGRW, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GESVX_F77 => LA_GESVX                           !!((07-B-INT_LAPACK1.f90))
!!     .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!     .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
      CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, RPVGRW
!!     .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: X(:,:)
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
      REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: C(:), R(:)
      COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESVX computes the solution to a real or complex linear system of
!! equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square matrix and X and B are rectangular matrices or vectors.
!!    LA_GESVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, return
!! the pivot growth factor, and compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_GESVX ( A, B, X, AF=af, IPIV=ipiv, FACT=fact, &
!!                  TRANS=trans, EQUED=equed, R=r, C=c, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, RPVGRW=rpvgrw, &
!!                  INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!          INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, &
!!                                       TRANS
!!          CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: R(:), C(:)
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND, RPVGRW
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A         (input/output) REAL or COMPLEX square array, shape (:,:).
!!           On entry, the matrix A or its equilibration:
!!           If FACT = "F" and EQUED /= "N" then A has been equilibrated
!!           by the scaling factors in R and/or C during a previous call
!!           to LA_GESVX.
!!           On exit, if FACT = "E", then the equilibrated version of A
!!           is stored in A; otherwise, A is unchanged.
!! B         (input/output) REAL or COMPLEX array, shape (:,:) with
!!           size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!           On entry, the matrix B.
!!           On exit, the scaled version of B if the system has been
!!           equilibrated; otherwise, B is unchanged.
!! X         (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!           size(A,1) and size(X,2) = size(B,2), or shape (:) with
!!           size(X) = size(A,1).
!!           The solution matrix X .
!! AF        Optional (input or output) REAL or COMPLEX square array,
!!           shape (:,:) with the same size as A.
!!           If FACT = "F" then AF is an input argument that contains the
!!           factors L and U of (the equilibrated) A returned by a
!!           previous call to LA_GESVX.
!!           If FACT /= "F" then AF is an output argument that contains
!!           the factors L and U of (the equilibrated) A.
!! IPIV      Optional (input or output) INTEGER array, shape (:) with
!!           size(IPIV) = size(A,1).
!!           If FACT = "F" then IPIV is an input argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A, returned by a previous call to LA_GESVX.
!!           If FACT /= "F" then IPIV is an output argument that contains
!!           the pivot indices from the factorization of (the
!!           equilibrated) A.
!! FACT      Optional (input) CHARACTER(LEN=1).
!!           Specifies whether the factored form of the matrix A is
!!           supplied on entry, and, if not, whether the matrix A should
!!           be equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF and IPIV contain the factored form of (the
!!                 equilibrated) A.
!!           Default value: "N".
!! TRANS     Optional (input) CHARACTER(LEN=1).
!!           Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!! EQUED     Optional (input or output) CHARACTER(LEN=1).
!!           Specifies the form of equilibration that was done.
!!           EQUED is an input argument if FACT = "F", otherwise it is an
!!           output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "R": Row equilibration, i.e., A has been premultiplied by
!!                 diag(R).
!!            = "C": Column equilibration, i.e., A has been postmultiplied
!!                 by diag(C).
!!            = "B": Both row and column equilibration.
!!           Default value: "N".
!! R         Optional (input or output) REAL array, shape (:) with size(R)
!!           = size(A,1). The row scale factors for A.
!!           R is an input argument if FACT = "F" and EQUED = "R" or "B".
!!           R is an output argument if FACT = "E" and EQUED = "R" or "B".
!! C         Optional (input or output) REAL array, shape (:) with size(C)
!!           = size(A,1). The column scale factors for A.
!!           C is an input argument if FACT = "F" and EQUED = "C" or "B".
!!           C is an output argument if FACT = "E" and EQUED = "C" or "B".
!! FERR      Optional (output) REAL array of shape (:), with size(FERR) =
!!           size(X,2), or REAL scalar.
!!           The estimated forward error bound for each solution vector
!!           X(j) (the j-th column of the solution matrix X). If XTRUE is
!!           the true solution corresponding to X(j) , FERR(j) is an
!!           estimated upper bound for the magnitude of the largest
!!           element in (X(j)-XTRUE) divided by the magnitude of the
!!           largest element in X(j). The estimate is as reliable as the
!!           estimate for RCOND and is almost always a slight
!!           overestimate of the true error.
!! BERR      Optional (output) REAL array of shape (:), with size(BERR) =
!!           size(X,2), or REAL scalar.
!!           The componentwise relative backward error of each solution
!!           vector X(j) (i.e., the smallest relative change in any
!!           element of A or B that makes X(j) an exact solution).
!! RCOND     Optional (output) REAL.
!!           The estimate of the reciprocal condition number of (the
!!           equilibrated) A. If RCOND is less than the machine precision,
!!           the matrix is singular to working precision. This condition
!!           is indicated by a return code of INFO > 0.
!! RPVGRW    Optional (output) REAL.
!!           The reciprocal pivot growth factor ||A||inf = ||U||inf. If
!!           RPVGRW is much less than 1, then the stability of the LU
!!           factorization of the (equilibrated) matrix A could be poor.
!!           This also means that the solution X , condition estimator
!!           RCOND, and forward error bound FERR could be unreliable. If
!!           the factorization fails with 0 < INFO <= size(A,1), then
!!           RPVGRW contains the reciprocal pivot growth factor for the
!!           leading INFO columns of A.
!! INFO      Optional (output) INTEGER
!!           = 0: successful exit.
!!           < 0: if INFO = -i, the i-th argument had an illegal value.
!!           > 0: if INFO = i, and i is
!!               <= n: U(i,i) = 0. The factorization has been completed,
!!                    but the factor U is singular, so the solution could
!!                  not be computed.
!!               = n+1: U is nonsingular, but RCOND is less than machine
!!                  precision, so the matrix is singular to working
!!                  precision. Nevertheless, the solution and error
!!                    bounds are computed because the computed solution
!!                  can be more accurate than the value of RCOND would
!!                  suggest.
!!           If INFO is not present and an error occurs, then the program
!!           is terminated with an error message.
!----------------------------------------------------------------------
!!     .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GESVX"
!!     .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LFACT, LTRANS, LEQUED
      INTEGER :: ISTAT, ISTAT1, LD, LINFO, N, NRHS, S1AF, S2AF, SBERR, SC, SFERR, SIPIV, SR
      REAL(WP) :: LRCOND, MVR, MVC
!!     .. LOCAL POINTERS ..
      INTEGER, POINTER :: LPIV(:)
      REAL(WP),  POINTER :: LC(:), LR(:), LFERR(:), LBERR(:), RWORK(:)
      COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!     .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE, MINVAL, TINY
!!     .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
      LD = MAX(1,N)
      IF( PRESENT(RCOND) ) RCOND = 1.0_WP
      IF( PRESENT(RPVGRW) ) RPVGRW = 1.0_WP
      IF( PRESENT(FACT) )THEN
         LFACT = FACT
      ELSE
         LFACT="N"
      END IF
      IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN
         LEQUED = EQUED
      ELSE
         LEQUED="N"
      END IF
      IF( PRESENT(IPIV) )THEN
         SIPIV = SIZE(IPIV)
      ELSE
         SIPIV = N
      END IF
      IF( PRESENT(AF) )THEN
         S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
      ELSE
         S1AF = N; S2AF = N
      END IF
      IF( ( PRESENT(C) ) )THEN
         SC = SIZE(C)
      ELSE
         SC = N
      END IF
      IF( ( PRESENT(C) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) )THEN
         MVC = MINVAL(C)
      ELSE
         MVC = TINY(1.0_WP)
      END IF
      IF( PRESENT(R) )THEN
         SR = SIZE(R)
      ELSE
         SR = N
      END IF
      IF( ( PRESENT(R) .AND. LSAME(LFACT,"F") ) .AND.                   &
     &    ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) )THEN
         MVR = MINVAL(R)
      ELSE
         MVR = TINY(1.0_WP)
      END IF
      IF( PRESENT(FERR) )THEN
         SFERR = SIZE(FERR)
      ELSE
         SFERR = NRHS
      END IF
      IF( PRESENT(BERR) )THEN
         SBERR = SIZE(BERR)
      ELSE
         SBERR = NRHS
      END IF
      IF(PRESENT(TRANS))THEN
         LTRANS = TRANS
      ELSE
         LTRANS="N"
      END IF
!!     .. TEST THE ARGUMENTS
      IF( SIZE(A, 2) /= N .OR. N < 0 )THEN
         LINFO = -1
      ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN
         LINFO = -2
      ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN
         LINFO = -3
      ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN
         LINFO = -4
      ELSE IF( SIPIV /= N )THEN
         LINFO = -5
      ELSE IF( SR /= N .OR. MVR <= 0.0_WP )THEN
         LINFO = -9
      ELSE IF( SC /= N .OR. MVC <= 0.0_WP )THEN
         LINFO = -10
      ELSE IF( SFERR /= NRHS )THEN
         LINFO = -11
      ELSE IF( SBERR /= NRHS )THEN
         LINFO = -12
      ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR.    &
     &                 LSAME(LFACT,"E") ) ) .OR.                        &
     &    ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND.             &
     &      PRESENT(IPIV) ) ) )THEN
         LINFO = -6
      ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR.    &
     &               LSAME(LTRANS,"C") ) )THEN
         LINFO = -7
      ELSE IF( ( .NOT.( LSAME(LEQUED,"N") .OR. LSAME(LEQUED,"R") .OR.   &
     &       LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") )                 &
     &           .AND. LSAME(LFACT,"F") ) .OR.                          &
     &      ( ( LSAME(LEQUED,"R") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(R) ) .OR.                                 &
     &      ( ( LSAME(LEQUED,"C") .OR. LSAME(LEQUED,"B") ) .AND.        &
     &           .NOT.PRESENT(C) ) )THEN
         LINFO = -8
      ELSE IF ( N > 0 )THEN
         IF( .NOT.PRESENT(AF) ) THEN
            ALLOCATE( LAF(LD,N), STAT=ISTAT )
         ELSE
            LAF => AF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(IPIV) )THEN
               ALLOCATE( LPIV(N), STAT=ISTAT )
            ELSE
               LPIV => IPIV
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(R) )THEN
               ALLOCATE( LR(N), STAT=ISTAT )
            ELSE
               LR => R
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(C) )THEN
               ALLOCATE( LC(N), STAT=ISTAT )
            ELSE
               LC => C
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(FERR) )THEN
               ALLOCATE( LFERR(NRHS), STAT=ISTAT )
            ELSE
               LFERR => FERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            IF( .NOT.PRESENT(BERR) )THEN
               ALLOCATE( LBERR(NRHS), STAT=ISTAT )
            ELSE
               LBERR => BERR
            END IF
         END IF
         IF( ISTAT == 0 )THEN
            ALLOCATE(WORK(2*N), RWORK(2*N), STAT=ISTAT )
         END IF
         IF( ISTAT == 0 )THEN
!!           .. CALL LAPACK77 ROUTINE
            CALL GESVX_F77( LFACT, LTRANS, N, NRHS, A, LD, LAF, LD, LPIV, LEQUED, LR, LC, B, LD, &
                            X, LD, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
         ELSE
            LINFO = -100
         END IF
         IF( .NOT.PRESENT(R) ) DEALLOCATE( LR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(C) ) DEALLOCATE( LC, STAT=ISTAT1 )
         IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
         IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
         IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
         IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
         IF( PRESENT(RPVGRW) ) RPVGRW=RWORK(1)
         IF( PRESENT(RCOND) ) RCOND=LRCOND
         IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
         DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
      END IF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE ZGESVX_F95
      SUBROUTINE ZGETRF_F95( A, IPIV, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GETRF_F77 => LA_GETRF, LANGE_F77 => LA_LANGE, & !!((07-B-INT_LAPACK1.f90))
                                          GECON_F77 => LA_GECON
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      REAL(WP), INTENT( OUT ), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT( OUT ), OPTIONAL, TARGET :: IPIV( : )
      COMPLEX(WP), INTENT( INOUT ) :: A( :, : )
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GESV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square matrix and X and B are
!! rectangular matrices or vectors. Gaussian elimination with row
!! interchanges is used to factor A as A = P*L*U , where P is a permutation
!! matrix, L is unit lower triangular, and U is upper triangular. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!       SUBROUTINE LA_GESV( A, B, IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        On exit, the factors L and U from the factorization A = P*L*U;
!!        the unit diagonal elements of L are not stored.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X .
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        The pivot indices that define the permutation matrix P; row i of
!!        the matrix was interchanged with row IPIV(i).
!! INFO   Optional (output) INTEGER
!!        = 0 : successful exit.
!!        < 0 : if INFO = -i, the i-th argument has an illegal value.
!!        > 0 : if INFO = i, then U(i,i) = 0. The factorization has been
!!        completed, but the factor U is singular, so the solution could
!!        not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRF"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: LINFO, M, N, LD, ISTAT, ISTAT1, MINMN, LWORK, SIPIV
      REAL(WP) :: LANORM
!!  .. LOCAL POINTERS ..
      INTEGER, POINTER :: LIPIV(:)
      REAL(WP), POINTER :: RWORK(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC PRESENT, MAX, MIN, SIZE, TINY
!!  .. EXECUTABLE STATEMENTS ..
      M = SIZE(A,1); N = SIZE(A,2); LINFO = 0; ISTAT = 0; MINMN = MIN(M,N)
      LD = MAX(1,M)
      IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = MINMN; ENDIF
      IF ( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
      IF( M < 0 .OR. N < 0 .OR. PRESENT(RCOND) .AND. M /= N )THEN; LINFO = -1
      ELSE IF( SIPIV /= MINMN )THEN; LINFO = -2
      ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
               ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
                                       .AND. LNORM /= "1" ) ) THEN; LINFO = -4
      ELSE IF( M > 0 .AND. N > 0 ) THEN
         IF( PRESENT(RCOND) .AND. M == N ) THEN
!!        .. COMPUTE THE NORM OF THE MATRIX A
            IF( LNORM == "I" ) THEN; LWORK = MINMN; ELSE; LWORK = 1; END IF
            ALLOCATE( RWORK(LWORK), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               LANORM = LANGE_F77( LNORM, MINMN, MINMN, A, LD, RWORK )
            ELSE
               LINFO = -100
            END IF
            DEALLOCATE(RWORK, STAT=ISTAT1)
         END IF
         IF( LINFO == 0 ) THEN
            IF( PRESENT(IPIV) )THEN; LIPIV => IPIV
            ELSE; ALLOCATE( LIPIV( MINMN ), STAT=ISTAT ); ENDIF
            IF( ISTAT /= 0 )LINFO = -100
         END IF
         IF( LINFO == 0 ) THEN
!!           .. COMPUTE THE LU FACTORS OF THE MATRIX A
            CALL GETRF_F77( M, N, A, LD, LIPIV, LINFO )
            IF( .NOT. PRESENT(IPIV) )DEALLOCATE( LIPIV, STAT=ISTAT )
            IF( PRESENT(RCOND) ) THEN
!!              .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
               IF( LANORM <= TINY(1.0_WP) .OR. M /= N .OR. LINFO /= 0 ) THEN
                  RCOND = 0.0_WP
               ELSE
                  ALLOCATE(WORK(2*MINMN), RWORK(2*MINMN), STAT=ISTAT)
                  IF( ISTAT == 0 )THEN
                     CALL GECON_F77( LNORM, MINMN, A, LD, LANORM, &
                                     RCOND, WORK, RWORK, LINFO )
                  ELSE
                     LINFO = -100
                  END IF
                  DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
               END IF
            END IF
         END IF
      ELSE IF( PRESENT(RCOND) ) THEN
         IF( M == N )THEN
            RCOND = 1.0_WP
         ELSE
            RCOND = 0.0_WP
         END IF
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
      END SUBROUTINE ZGETRF_F95
SUBROUTINE ZGETRI_F95( A, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRI_F77 => LA_GETRI, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRI computes the inverse of a matrix using the LU factorization
!! computed by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRI (A, IPIV, INFO)
!!    <type>(<wp>), INTENT(INOUT)  :: A(:,:)
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! =====================
!
!! A      (input/output) either REAL or COMPLEX square array, shape (:,:),
!!        size(A,1) == size(A,2).
!!        On entry contains the factors L and U from the factorization
!!           A = PLU as computed by LA_GETRF.
!!        On exit, if INFO = 0, the inverse of the original matrix A.
!
!! IPIV   (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!        The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i of
!!        the matrix was interchanged with row IPIV(i).
!
!! INFO   Optional (output) INTEGER.
!!        If INFO is present
!!           = 0: successful exit
!!           < 0: if INFO = -k, the k-th argument had an illegal value
!!           > 0: if INFO = k, U(k,k) is exactly zero.  The matrix is
!!               singular and its inverse could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!           terminated with an error message.
!-----------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRI"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZGETRI"
!!  .. LOCAL SCALARS ..
   INTEGER    :: LINFO, N, LD, LWORK, ISTAT, ISTAT1, NB
!!  .. LOCAL ARRAY ..
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LINFO = 0; LD = MAX(1,N); ISTAT = 0
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N )THEN; LINFO = -2
   ELSE IF( N > 0 )THEN
!!     DETERMINE THE WORK SPACE.
      NB = ILAENV_F77( 1, BSNAME, " ", N, -1, -1, -1 )
      IF( NB < 1 .OR. NB >= N )THEN; NB = 1; END IF
      LWORK = MAX( N*NB, 1 )
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT1)
         LWORK = MAX(1,N); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( LINFO == 0 )THEN
         CALL GETRI_F77( N, A, LD, IPIV, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      DEALLOCATE(WORK, STAT=ISTAT1)
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGETRI_F95
SUBROUTINE ZGETRS1_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = 1; LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE ZGETRS1_F95
SUBROUTINE ZGETRS_F95( A, IPIV, B, TRANS, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GETRS_F77 => LA_GETRS                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(IN) :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_GETRS solves a system of linear equations
!!    A X = B, A^T X = B or  A^H X = B
!! with a general square matrix A using the LU factorization computed
!! by LA_GETRF.
!
!! Arguments
!! =========
!! SUBROUTINE LA_GETRS (A, IPIV, B, TRANS, INFO)
!!    <type>(<wp>), INTENT(IN)  :: A(:,:)
!!    <type>(<wp>), INTENT(INOUT) :: <rhs>
!!    INTEGER, INTENT(IN) :: IPIV(:)
!!    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS
!!    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!    <type> ::= REAL | COMPLEX
!!    <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!    <rhs>  ::= B(:,:) | B(:)
!
!! =====================
!
!! A     (input) either REAL or COMPLEX square array,
!!       shape (:,:), size(A,1) == size(A,2).
!!       The factors L and U from the factorization A = PLU as computed
!!       by LA_GETRF.
!
!! IPIV  (input) INTEGER array, shape (:), size(IPIV) == size(A,1).
!!       The pivot indices from LA_GETRF; for 1<=i<=size(A,1), row i
!!       of the matrix was interchanged with row IPIV(i).
!
!! B     (input/output) either REAL or COMPLEX rectangular array,
!!       shape either (:,:) or (:), size(B,1) or size(B) == size(A,1).
!!       On entry, the right hand side vector(s) of matrix B for
!!          the system of equations AX = B.
!!       On exit, if there is no error, the matrix of solution
!!          vector(s) X.
!
!! TRANS Optional (input) CHARACTER*1
!!       If TRANS is present, it specifies the form of the system
!!          of equations:
!!          = "N":  A X = B    (No transpose)
!!          = "T":  A^T X = B  (Transpose)
!!          = "C":  A^H X = B  (Conjugate transpose = Transpose)
!!       otherwise TRANS = "N" is assumed.
!
!! INFO  Optional (output) INTEGER.
!!       If INFO is present
!!          = 0: successful exit
!!          < 0: if INFO = -k, the k-th argument had an illegal value
!!       If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!---------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GETRS"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LTRANS
   INTEGER    :: LINFO, NRHS, N, LD
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A, 1); NRHS = SIZE(B,2); LD = MAX(1,N)
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( IPIV ) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( B, 1 ) /= N ) THEN; LINFO = -3
   ELSE IF(.NOT.LSAME(LTRANS,"N") .AND. .NOT.LSAME(LTRANS,"T").AND. &
           .NOT.LSAME(LTRANS,"C"))THEN; LINFO = -4
   ELSE
!!  .. CALL LAPACK77 ROUTINE
      CALL GETRS_F77( LTRANS, N, NRHS, A, LD, IPIV, B, LD, LINFO )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO )
END SUBROUTINE ZGETRS_F95
       SUBROUTINE ZGGES_F95( A, B, ALPHA, BETA, VSL, VSR, SELECT, SDIM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  DP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGES_F77 => LA_GGES                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT( ALPHA, BETA)
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      COMPLEX(WP), INTENT(IN) :: ALPHA, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGES computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!
!! =========
!!
!!           SUBROUTINE LA_GGES( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGES for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGES"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHA, SBETA
      INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
        REAL(WP), POINTER :: RWORK(:)
      LOGICAL, POINTER :: BWORK(:)
      LOGICAL, TARGET :: LLBWORK(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHA = SIZE(ALPHA)
   IF (PRESENT (SELECT)) THEN
      LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
       ELSE IF( SALPHA /= N )THEN; LINFO = -3
       ELSE IF( SBETA /= N )THEN; LINFO = -4
       ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N) )THEN; LINFO = -5
       ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6

       ELSE IF( N >= 0 )THEN
       IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 500; ENDIF
       ELSE; BWORK => LLBWORK; END IF

       ALLOCATE(RWORK(8*N), STAT = ISTAT)
       IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 100; ENDIF


!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
        LWORK = -1
        IF( PRESENT(VSL) )THEN
           IF( PRESENT(VSR) )THEN
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ELSE
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ENDIF
         ELSE
           IF( PRESENT(VSR) )THEN
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ELSE
               CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                  LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                  WORKMIN, LWORK, RWORK, BWORK,  LINFO )
           ENDIF
         ENDIF
        LWORK = WORKMIN(1)

        ALLOCATE(WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-100; GOTO 400; ENDIF

        IF( PRESENT(VSL) )THEN
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ENDIF
        ELSE
          IF( PRESENT(VSR) )THEN
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ELSE
              CALL GGES_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 WORK, LWORK, RWORK, BWORK,  LINFO )
          ENDIF
        ENDIF
          IF (PRESENT(SDIM)) SDIM = LSDIM

          DEALLOCATE(WORK)
400       DEALLOCATE(RWORK)
100       IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK)
        ENDIF
500     CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGGES_F95
SUBROUTINE ZGGESX_F95( A, B,  ALPHA, &
&   BETA, VSL, VSR, SELECT, SDIM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGESX_F77 => LA_GGESX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VSL(:,:), VSR(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: RCONDE(2), RCONDV(2)
!!  .. FUNCTIONAL ARGUMENTS ..
      INTERFACE
      LOGICAL FUNCTION SELECT(ALPHA, BETA)
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      COMPLEX(WP), INTENT(IN) :: ALPHA, BETA
      END FUNCTION SELECT
      END INTERFACE
      OPTIONAL :: SELECT
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGESX computes for a pair of n by n real or complex matrices
!! (A, B) the (generalized) real or complex Schur form, the generalized
!! eigenvalues in the form of scalar pairs (alpha,beta), and, optionally,
!! the left and/or right Schur vectors.
!!      If A and B are real then the real-Schur form is computed,
!! otherwise the complex-Schur form is computed. The real-Schur form is a
!! pair of real matrices (S,T) such that 1) S has block upper triangular
!! form, with 1 by 1 and 2 by 2 blocks along the main diagonal, 2) T has
!! upper triangular form with nonnegative elements on the main diagonal,
!! and 3) S = Q^T*A*Z and T = Q^T*B*Z, where Q and Z are orthogonal
!! matrices. The 2 by 2 blocks of S are "standardized" by making the
!! corresponding elements of T have the form
!!                        [ a  0 ]
!!                        [ 0  b ]
!! The complex-Schur form is a pair of matrices (S,T) such that 1) S has
!! upper triangular form, 2) T has upper triangular form with nonnegative
!! elements on the main diagonal, and 3) S = Q^H*A*Z and T = Q^H*B*Z,
!! where Q and Z are unitary matrices.
!!       In both cases the columns of Q and Z are called, respectively,
!! the left and right (generalized) Schur vectors.
!! A generalized eigenvalue of the pair (A,B) is, roughly speaking, a
!! scalar of the form lambda = alpha/beta such that the matrix
!! A -lambda*B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       LA_GGESX also computes two reciprocal condition numbers for the
!! average of the selected eigenvalues and reciprocal condition numbers
!! for the right and left deflating subspaces corresponding to the
!! selected eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_GGESX( A, B, <alpha>, BETA, VSL=vsl, &
!!                      VSR=vsr, SELECT=select, SDIM=sdim,
!!                      RCONDE=rconde, RCONDV=rcondv, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!              <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: VSL(:,:), VSR(:,:)
!!              INTERFACE
!!                 LOGICAL FUNCTION SELECT(<alpha(j)> , BETA(j))
!!                     <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!                 END FUNCTION SELECT
!!              END INTERFACE
!!              OPTIONAL :: SELECT
!!              INTEGER, INTENT(OUT), OPTIONAL :: SDIM
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: RCONDE(2), RCONDV(2)
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type>     ::= REAL | COMPLEX
!!              <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!              <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!              <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!              <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A.
!!          On exit, the matrix S.
!! B        (input/output) REAL or COMPLEX square array, shape (:,:) with
!!          size(B,1) = size(A,1).
!!          On entry, the matrix B.
!!          On exit, the matrix T .
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!          size(A,1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!          size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A,B) are the
!!          scalars lambda(j) = alpha(j)/beta(j). These quotients may
!!          easily over- or underflow, and beta(j) may even be zero. Thus,
!!          the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!            lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!            lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!          ALPHAI(j)/BETA(j) = -( ALPHAI(j+1)/BETA(j+1))
!! VSL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSL,1) = size(A,1).
!!          The left Schur vectors.
!! VSR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(VSR,1) = size(A,1).
!!          The right Schur vectors.
!! SELECT   Optional (input) LOGICAL FUNCTION
!!          LOGICAL FUNCTION SELECT( <alpha(j)> , BETA(j))
!!             <type>(<wp>), INTENT(IN) :: <alpha(j)> , BETA(j)
!!          where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!             <alpha(j)> ::= ALPHAR(j) , ALPHAI(j) | ALPHA(j)
!!          1. SELECT must be declared as EXTERNAL or as an explicit
!!          interface in the calling (sub)program.
!!          2. SELECT is called by LA_GGESX for every computed eigenvalue
!!          (<alpha(j)> , BETA(j)) (but only once for a complex conjugate
!!          pair when A and B are real). It is used to select the
!!          eigenvalues that will be ordered to the top left of the Schur
!!          form. The eigenvalue (<alpha(j)>, BETA(j)) is selected if
!!          SELECT(<alpha(j)>, BETA(j)) has the value .TRUE.
!!          3. A selected complex eigenvalue may no longer satisfy
!!          SELECT(<alpha(j)>, BETA(j)) = .TRUE. after ordering, since
!!          ordering may change the value of complex eigenvalues
!!          (especially if the eigenvalue is ill-conditioned); in this case
!!          INFO is set to size(A,1) + 2 (see INFO below).
!!          Note: Select must be present if SDIM is desired.
!! SDIM     Optional (output) INTEGER.
!!          The number of eigenvalues (after sorting) for which SELECT =
!!          .TRUE. (If A and B are real, then complex conjugate pairs for
!!          which SELECT = .TRUE. for either eigenvalue count as 2).
!! RCONDE   Optional (output) REAL array, shape (:) with size(RCONDE)=2.
!!          The reciprocal condition numbers for the average of the
!!          selected eigenvalues.
!! RCONDV   Optional (output) REAL array, shape (:) with size(RCONDV)=2.
!!          The reciprocal condition numbers for the left and right
!!          deflating subspaces corresponding to the selected
!!          eigenvalues.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!            <= n: the QZ iteration failed. The matrix pair (A,B) has not
!!             been reduced to Schur form, but (<alpha(j)>,BETA(j))
!!             should be correct for j = INFO + 1,..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: after reordering, roundoff changed values of some
!!             complex eigenvalues so that leading eigenvalues in the
!!             Schur form no longer satisfy SELECT = .TRUE. This can be
!!             caused by ordinary roundoff or underflow due to scaling.
!!            = n+3: the reordering failed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGESX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBVSL, LJOBVSR, LSORT, LSENSE
   INTEGER, SAVE :: LWORK = 0
   INTEGER :: N, LINFO, LDA, LDB, ISTAT, S1VSL, S2VSL, S1VSR, S2VSR, &
     &  SALPHA, SBETA, LIWORK
   INTEGER :: LSDIM
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLVSL(1,1), LLVSR(1,1)
   REAL(WP), TARGET :: LLRCONDE(2), LLRCONDV(2)
   COMPLEX(WP), POINTER :: WORK(:)
   LOGICAL, POINTER :: BWORK(:)
   INTEGER, POINTER :: IWORK(:)
   LOGICAL, TARGET :: LLBWORK(1)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LDA = MAX(1,N); LDB = MAX(1,SIZE(B,1))
   SALPHA = SIZE(ALPHA)
   IF  (PRESENT (SELECT)) THEN
     LSORT = "S"; ELSE ; LSORT = "N"; ENDIF
   SBETA = SIZE(BETA)
   IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
   ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
   ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF
   IF( .NOT. LSAME(LSENSE,"N") ) LSORT = "S"
   IF( PRESENT(VSL) )THEN; S1VSL = SIZE(VSL,1); S2VSL = SIZE(VSL,2); LJOBVSL = "V"
   ELSE; S1VSL = 1; S2VSL = 1; LJOBVSL = "N"; END IF
   IF( PRESENT(VSR) )THEN; S1VSR = SIZE(VSR,1); S2VSR = SIZE(VSR,2); LJOBVSR = "V"
   ELSE; S1VSR = 1; S2VSR = 1; LJOBVSR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
      ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
     ELSE IF( SALPHA /= N )THEN; LINFO = -3
     ELSE IF( SBETA /= N )THEN; LINFO = -4
     ELSE IF( PRESENT(VSL) .AND. ( S1VSL /= N .OR. S2VSL /= N ) )THEN; LINFO = -5
     ELSE IF( PRESENT(VSR) .AND. ( S1VSR /= N .OR. S2VSR /= N ) )THEN; LINFO = -6

   ELSE IF( N >= 0 )THEN
      IF(LSAME(LSORT,"S")) THEN;  ALLOCATE(BWORK(N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-101; GOTO 100; ENDIF
      ELSE; BWORK => LLBWORK; END IF

      ALLOCATE(RWORK(8*N),STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-103; GOTO 300; ENDIF

      IF ( LSAME (LSENSE, "N")) THEN
        LWORK =  2 * N
      ELSE
        LWORK = MAX( 2*N, N*N/2+1 )
      ENDIF
      ALLOCATE (WORK(LWORK), STAT=ISTAT)
        IF (ISTAT /= 0) THEN ; LINFO=-105; GOTO 500; ENDIF
      LIWORK = N+2
      ALLOCATE (IWORK(LIWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN ; LINFO=-106; GOTO 600; ENDIF

        IF (PRESENT (RCONDV)) THEN
          IF (PRESENT(RCONDE)) THEN
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ELSE
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, RCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ENDIF
        ELSE
          IF (PRESENT(RCONDE)) THEN
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 RCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ELSE
            IF (PRESENT (VSR)) THEN
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), VSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ELSE
              IF (PRESENT (VSL)) THEN
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, VSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ELSE
                CALL GGESX_F77( LJOBVSL, LJOBVSR, LSORT, SELECT, LSENSE, N, A, LDA, B, LDB, &
&                 LSDIM, ALPHA, BETA, LLVSL, MAX(1,S1VSL), LLVSR, MAX(1,S1VSR), &
&                 LLRCONDE, LLRCONDV, WORK, LWORK, RWORK, IWORK, LIWORK, BWORK, LINFO )
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        IF (PRESENT(SDIM)) SDIM = LSDIM

        DEALLOCATE(IWORK, STAT=ISTAT)
600     DEALLOCATE(WORK, STAT=ISTAT)
500     DEALLOCATE(RWORK, STAT=ISTAT)
300     IF(LSAME(LSORT,"S")) DEALLOCATE(BWORK, STAT=ISTAT)

    ENDIF
100   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGGESX_F95
      SUBROUTINE ZGGEV_F95( A, B, ALPHA, BETA, VL, VR, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEV_F77 => LA_GGEV                             !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
       COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!! LA_GGEV computes for a pair of n by n real or complex matrices (A,B)
!! the generalized eigenvalues in the form of scalar pairs (alpha, beta)
!! and, optionally, the left and/or right generalized eigenvectors.
!!       A generalized eigenvalue of the pair (A,B) is, roughly
!! speaking, a scalar of the form  lambda=alpha/beta such that the matrix
!! A-lambda*B is singular. It is usually represented as the pair
!! (alpha; beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!       A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector v such that (A-lambda*B)*v=0. A left
!! generalized eigenvector is a vector u such that u^H*(A-lambda*B)=0,
!! where u^H is the conjugate-transpose of u.
!!       The computation is based on the (generalized) real or complex
!! Schur form of (A,B). (See LA_GGES for details of this form.)
!!
!! =========
!!
!!     SUBROUTINE LA_GGEV( A, B, <alpha>, BETA, VL=vl, &
!!                 VR=vr, INFO=info )
!!         <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!         <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!         <type>     ::= REAL | COMPLEX
!!         <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!         <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!         <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         On exit, A has been destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B.
!!         On exit, B has been destroyed.
!! <alpha> (output) REAL or COMPLEX array, shape (:) with size(alpha) =
!!         size(A,1).
!!         The values of alpha.
!!         alpha(:) ::= ALPHAR(:), ALPHAI(:) | ALPHA(:),
!!         where
!!         ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!         imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA    (output) REAL or COMPLEX array, shape (:) with size(BETA) =
!!         size(A,1).
!!         The values of beta.
!!         Note: The generalized eigenvalues of the pair (A,B) are the
!!         scalars lambda(j)=alpha(j)/beta(j). These quotients may easily
!!         over- or underflow, and beta(j) may even be zero. Thus, the
!!         USEr should avoid computing them naively.
!!         Note: If A and B are real then complex eigenvalues occur in
!!         complex conjugate pairs. Each pair is stored consecutively.
!!         Thus a complex conjugate pair is given by
!!             lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!             lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!         where
!!             ALPHAI(j)/BETA(j) = -(ALPHAI(j+1)/BETA(j+1))
!! VL      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VL,1) = size(A,1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag:part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!            <= n: The QZ iteration failed. No eigenvectors have been
!!                  calculated, but (alpha(j), BETA(j)) should be
!!                  correct for j = INFO+1, ..., n.
!!            = n+1: another part of the algorithm failed.
!!            = n+2: a failure occurred during the computation of the
!!                  generalized eigenvectors.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!-----------------------------------------------------------------------

!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GGEV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHA, SBETA
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
     REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHA = SIZE(ALPHA)
   SBETA = SIZE(BETA)
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2

       ELSE IF( SALPHA /= N )THEN; LINFO = -3
       ELSE IF( SBETA /= N )THEN; LINFO = -4
       ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
       ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
       ELSE IF( N > 0 )THEN

       ALLOCATE(RWORK(8*N),STAT=ISTAT)
       IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 200; ENDIF

!! .. DETERMINE THE WORKSPACE ..
!! .. QUERING THE SIZE OF WORKSPACE ..
      LWORK = -1
      IF (PRESENT (VL)) THEN
         IF (PRESENT (VR)) THEN
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, VL, S1VL, VR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ELSE
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, VL, S1VL, LLVR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ENDIF
       ELSE
         IF (PRESENT (VR)) THEN
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, LLVL, S1VL, VR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ELSE
              CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&               BETA, LLVL, S1VL, LLVR, S1VR, WORKMIN, LWORK, RWORK,  LINFO )
         ENDIF
       ENDIF
      LWORK = WORKMIN(1)
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
         IF (PRESENT (VR)) THEN
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, VL, S1VL, VR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ELSE
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, VL, S1VL, LLVR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ENDIF
      ELSE
         IF (PRESENT (VR)) THEN
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, LLVL, S1VL, VR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ELSE
             CALL GGEV_F77( LJOBVL, LJOBVR, N, A, LD, B, LD, ALPHA, &
&                BETA, LLVL, S1VL, LLVR, S1VR, WORK, LWORK, &
&                RWORK, LINFO )
         ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      DEALLOCATE(WORK)
200  DEALLOCATE(RWORK)
     ENDIF
100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGGEV_F95
      SUBROUTINE ZGGEVX_F95( A, B, ALPHA, BETA, VL, VR, &
     &  BALANC, ILO, IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: GGEVX_F77 => LA_GGEVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
      INTEGER, INTENT(OUT), OPTIONAL :: ILO,IHI
      REAL(WP), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!  .. ARRAY ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: LSCALE(:), RSCALE(:), &
     &  RCONDE(:), RCONDV(:)
      COMPLEX(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: VL(:,:), VR(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGEVX computes for a pair of n-by-n real or complex matrices
!! (A, B) the generalized eigenvalues in the form of scalar pairs
!! (alpha; beta) and, optionally, the left and/or right generalized
!! eigenvectors.
!!      A generalized eigenvalue of the pair (A; B) is, roughly speaking,
!! a scalar of the form lambda = alpha / beta such that the matrix
!! A - lambda * B is singular. It is usually represented as the pair
!! (alpha, beta), as there is a reasonable interpretation of the case
!! beta = 0 (even if alpha = 0).
!!      A right generalized eigenvector corresponding to a generalized
!! eigenvalue lambda is a vector  v  such that ( A - lambda*B)* v = 0.
!! A left generalized eigenvector is a vector u such that
!! u^H*(A-lambda*B) = 0, where u^H is the conjugate-transpose of u.
!!      The computation is based on the (generalized) real or complex
!! Schur form of (A, B). (See LA_GGES for details of this form.)
!!      Optionally, LA_GGEVX also computes a balancing transformation
!! (to improve the conditioning of the eigenvalues and eigenvectors),
!! reciprocal condition numbers for the eigenvalues, and reciprocal
!! condition numbers for the right eigenvectors. The balancing
!! transformation consists of a permutation of rows and columns and/or a
!! scaling of rows and columns.
!!
!! ==========
!!
!!    SUBROUTINE LA_GGEVX( A, B, <alpha>, BETA, VL=vl, &
!!          VR=vr, BALANC=balanc, ILO=ilo, IHI=ihi, &
!!          LSCALE=lscale, RSCALE=rscale, ABNRM=abnrm, &
!!          BBNRM=bbnrm, RCONDE=rconde, RCONDV=rcondv, &
!!          INFO=info )
!!        <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!        <type>(<wp>), INTENT(OUT) :: <alpha(:)>, BETA(:)
!!        <type>(<wp>), INTENT(OUT), OPTIONAL :: VL(:,:), VR(:,:)
!!        CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: BALANC
!!        INTEGER, INTENT(OUT), OPTIONAL :: ILO, IHI
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: LSCALE(:),
!!             RSCALE(:), RCONDE(:), RCONDV(:)
!!        REAL(<wp>), INTENT(OUT), OPTIONAL :: ABNRM, BBNRM
!!        INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!        <type>     ::= REAL | COMPLEX
!!        <wp>       ::= KIND(1.0) | KIND(1.0D0)
!!        <alpha>    ::= ALPHAR, ALPHAI | ALPHA
!!        <alpha(:)> ::= ALPHAR(:), ALPHAI(:) | ALPHA(:)
!!
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:, :).
!!          On entry, the matrix A.
!!          On exit, A has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then A contains
!!          the first part of the real/complex Schur form of the
!!          "balanced" versions of the matrix pair (A, B).
!! B        (input/output) REAL or COMPLEX square array, shape (:, :)
!!          with size(B, 1) = size(A, 1).
!!          On entry, the matrix B.
!!          On exit, B has been overwritten. If the left, the right or
!!          both generalized eigenvectors are computed, then B contains
!!          the second part of the real/complex Schur form of the "bal-
!!          anced" versions of the matrix pair (A, B).
!! <alpha>  (output) REAL or COMPLEX array, shape (:) with
!!          size(<alpha>) = size(A, 1).
!!          The values of alpha.
!!          <alpha(:)> ::= ALPHAR(:), ALPHAI(:) |  ALPHA(:),
!!          where
!!          ALPHAR(:), ALPHAI(:) are of REAL type (for the real and
!!          imaginary parts) and ALPHA(:) is of COMPLEX type.
!! BETA     (output) REAL or COMPLEX array, shape (:) with
!!          size(BETA) = size(A,1).
!!          The values of beta.
!!          Note: The generalized eigenvalues of the pair (A, B) are the
!!          scalars lambda(j) = alpha(j) / beta(j) . These quotients
!!          may easily over- or underflow, and beta(j) may even be zero.
!!          Thus, the USEr should avoid computing them naively.
!!          Note: If A and B are real then complex eigenvalues occur in
!!          complex conjugate pairs. Each pair is stored consecutively.
!!          Thus a complex conjugate pair is given by
!!                 lambda(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
!!                 lambda(j+1) = (ALPHAR(j+1) + i*ALPHAI(j+1))/BETA(j+1)
!!          where
!!              ALPHAI(j)/BETA(j)= - (ALPHAI(j+1)/BETA(j+1))
!! VL       Optional (output) REAL or COMPLEX square array, shape (:, :)
!!          with  size(VL, 1) = size(A, 1).
!!         The left generalized eigenvectors u(j) are stored in the
!!         columns of VL in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!             |realpart| + |imag.part| = 1,
!!         except that for eigenvalues with alpha = beta = 0, a zero
!!         vector is returned as the corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VL(:,j) and VL(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         u(j) = VL(:,j) + i*VL(:,j+1), u(j+1) = VL(:,j) - i*VL(:,j+1)
!! VR      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(VR,1) = size(A,1).
!!         The right generalized eigenvectors v(j) are stored in the
!!         columns of VR in the order of their eigenvalues. Each
!!         eigenvector is scaled so the largest component has
!!         | realpart | + | imag.part | = 1,except that for eigenvalues
!!         with alpha = beta = 0, a zero vector is returned as the
!!         corresponding eigenvector.
!!         Note: If A and B are real then complex eigenvectors, like
!!         their eigenvalues, occur in complex conjugate pairs. The real
!!         and imaginary parts of the first eigenvector of the pair are
!!         stored in VR(:,j) and VR(:,j+1) . Thus a complex conjugate
!!         pair is given by
!!         v(j) = VR(:,j) + i*VR(:,j+1), v(j+1) = VR(:,j) - i*VR(:,j+1)
!! BALANC  Optional (input) CHARACTER(LEN=1).
!!         Specifies the balance option to be performed.
!!            = "N": do not permute or scale;
!!            = "P": permute only;
!!            = "S": scale only;
!!            = "B": both permute and scale.
!!         Default value: "N".
!!         Note: Computed reciprocal condition numbers will be for the
!!         matrices after balancing. Permuting does not change condition
!!         numbers (in exact arithmetic), but scaling does.
!! ILO,IHI Optional (output) INTEGER.
!!         ILO and IHI are integer values such that on exit A(i,j) = 0
!!         and B(i,j) = 0 if i > j and j =1,...,ILO-1 or
!!         i = IHI+1,...,n.
!!         If BALANC = "N" or "S", then ILO = 1 and IHI = n.
!! LSCALE  Optional (output) REAL array, shape (:) with size(LSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to
!!         the left side of A and B. If PL(j) is the index of the row
!!         interchanged with row j, and DL(j) is the scaling factor
!!         applied to row j, then
!!                 PL(j) = LSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!               DL(j) = LSCALE(j),  j = ILO, ..., IHI
!! RSCALE  Optional (output) REAL array, shape (:), size(RSCALE) =
!!         size(A, 1).
!!         Details of the permutations and scaling factors applied to the
!!         right side of A and B. If PR(j) is the index of the column
!!         interchanged with column j, and DR(j) is the scaling factor
!!         applied to column j, then
!!                PR(j) = RSCALE(j),  j = 1,...,ILO-1 and IHI+1,..., n
!!         and
!!                DR(j) = RSCALE(j),  j = ILO, ..., IHI
!! ABNRM   Optional (output) REAL.
!!         The l1 norm of A after balancing.
!! BBNRM   Optional (output) REAL.
!!         The l 1 norm of B after balancing.
!! RCONDE  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The reciprocal condition numbers of the eigenvalues.
!! RCONDV  Optional (output) REAL array, shape (:) with size(RCONDE) =
!!         size(A, 1).
!!         The estimated reciprocal condition numbers of the right
!!         eigenvectors. If the eigenvalues cannot be reordered to
!!         compute RCONDV(j) then RCONDV(j) is set to 0. This can only
!!         occur when the true value would be very small.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!           <= n: The QZ iteration failed. No eigenvectors have been
!!                 calculated, but (alpha(j) , BETA(j) ) should be
!!          correct for j = INFO + 1,..., n.
!!             = n+1: another part of the algorithm failed.
!!             = n+2: a failure occurred during the computation of the
!!                 generalized eigenvectors.
!!         If INFO is not present and an error occurs, then the program
!!       is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGEVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBVL, LJOBVR, LBALANC, LSENSE
      INTEGER, SAVE :: LWORK = 0
      INTEGER :: N, LINFO, LD, ISTAT, S1VL, S2VL, S1VR, S2VR, &
     &  SALPHA, SBETA, LILO, LIHI, SRCONDE, SRCONDV, SLSCALE, SRSCALE
      REAL(WP) :: LABNRM, LBBNRM
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLVL(1,1), LLVR(1,1), WORKMIN(1)
      REAL(WP), POINTER :: LRCONDE(:), LRCONDV(:), LLSCALE(:), LRSCALE(:)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
      INTEGER, POINTER :: IWORK(:)
      LOGICAL, POINTER :: BWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A,1); LD = MAX(1,N)
   SALPHA = SIZE(ALPHA); SBETA = SIZE(BETA)
   IF( PRESENT(BALANC) )THEN; LBALANC = BALANC; ELSE; LBALANC = "N"; ENDIF
   IF( PRESENT(LSCALE) )THEN; SLSCALE = SIZE(LSCALE); ELSE; SLSCALE = N; ENDIF
   IF( PRESENT(RSCALE) )THEN; SRSCALE = SIZE(RSCALE); ELSE; SRSCALE = N; ENDIF
   IF( PRESENT(RCONDE) )THEN; SRCONDE = SIZE(RCONDE); ELSE; SRCONDE = N; ENDIF
   IF( PRESENT(RCONDV) )THEN; SRCONDV = SIZE(RCONDV); ELSE; SRCONDV = N; ENDIF
   IF( PRESENT(VL) )THEN; S1VL = SIZE(VL,1); S2VL = SIZE(VL,2); LJOBVL = "V"
   ELSE; S1VL = 1; S2VL = 1; LJOBVL = "N"; END IF
   IF( PRESENT(VR) )THEN; S1VR = SIZE(VR,1); S2VR = SIZE(VR,2); LJOBVR = "V"
   ELSE; S1VR = 1; S2VR = 1; LJOBVR = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 .OR. SIZE(A,2) /= N )THEN; LINFO = -1
   ELSE IF( SIZE(B,1) /= N .OR. SIZE(B,2) /= N )THEN; LINFO = -2
   ELSE IF( SALPHA /= N )THEN; LINFO = -3
   ELSE IF( SBETA /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(VL) .AND. ( S1VL /= N .OR. S2VL /= N ) )THEN; LINFO = -5
   ELSE IF( PRESENT(VR) .AND. ( S1VR /= N .OR. S2VR /= N ) )THEN; LINFO = -6
   ELSE IF( .NOT.( LSAME(LBALANC,"N") .OR. LSAME(LBALANC,"P") .OR. &
     &  LSAME(LBALANC,"S") .OR. LSAME(LBALANC,"B") ) )THEN; LINFO = -7
   ELSE IF( SLSCALE /= N )THEN; LINFO = -10
   ELSE IF( SRSCALE /= N )THEN; LINFO = -11
   ELSE IF( SRCONDE /= N )THEN; LINFO = -14
   ELSE IF( SRCONDV /= N )THEN; LINFO = -15
   ELSE IF( N > 0 )THEN
      IF( PRESENT(RCONDE).AND.PRESENT(RCONDV) )THEN; LSENSE = "B"
      ELSE IF( PRESENT(RCONDE) )THEN; LSENSE = "E"
      ELSE IF( PRESENT(RCONDV) )THEN; LSENSE = "V"; ELSE; LSENSE = "N"; ENDIF

      ALLOCATE(RWORK(6*N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1100; ENDIF

      ALLOCATE(BWORK(N), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 1000; ENDIF

      ALLOCATE(IWORK(N+6), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 900; ENDIF

      IF( PRESENT(LSCALE) )THEN; LLSCALE => LSCALE
      ELSE; ALLOCATE( LLSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 800; ENDIF
      END IF

      IF( PRESENT(RSCALE) )THEN; LRSCALE => RSCALE
      ELSE; ALLOCATE( LRSCALE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 700; ENDIF
      END IF

      IF( PRESENT(RCONDV) )THEN; LRCONDV => RCONDV
      ELSE; ALLOCATE( LRCONDV(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 600; ENDIF
      END IF

      IF( PRESENT(RCONDE) )THEN; LRCONDE => RCONDE
      ELSE; ALLOCATE( LRCONDE(N), STAT=ISTAT )
        IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 500; ENDIF
      END IF

      LWORK = -1
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
      ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&             BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM, &
&             LRCONDE, LRCONDV, WORKMIN, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
      ENDIF
!! NEXT LINE SHOULD BE LWORK = WORKMIN(1)
      LWORK = 5*WORKMIN(1)

      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF (ISTAT /= 0) THEN; LINFO=-100; GOTO 100; ENDIF
      IF (PRESENT (VL)) THEN
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, VL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, VL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
       ELSE
        IF (PRESENT (VR)) THEN
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, LLVL, S1VL, VR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ELSE
           CALL GGEVX_F77( LBALANC, LJOBVL, LJOBVR, LSENSE, N, A, LD, B, LD, ALPHA, &
&            BETA, LLVL, S1VL, LLVR, S1VR, LILO, LIHI, LLSCALE, LRSCALE, LABNRM, LBBNRM,&
&            LRCONDE, LRCONDV, WORK, LWORK, RWORK, IWORK, BWORK, LINFO )
        ENDIF
       ENDIF
      IF( LINFO == 0 ) LWORK = INT(WORK(1)+1)

      IF( PRESENT(ILO) ) ILO = LILO
      IF( PRESENT(IHI) ) IHI = LIHI
      IF( PRESENT(ABNRM) ) ABNRM = LABNRM
      IF( PRESENT(BBNRM) ) BBNRM = LBBNRM

      DEALLOCATE(WORK)
100  IF (.NOT. PRESENT(RCONDE)) DEALLOCATE(LRCONDE)
500  IF (.NOT. PRESENT(RCONDV)) DEALLOCATE(LRCONDV)
600  IF (.NOT. PRESENT(RSCALE)) DEALLOCATE(LRSCALE)
700  IF (.NOT. PRESENT(LSCALE)) DEALLOCATE(LLSCALE)
800  DEALLOCATE (IWORK)
900  DEALLOCATE (BWORK)
1000  DEALLOCATE (RWORK)
     ENDIF
1100  CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGGEVX_F95
SUBROUTINE ZGGGLM_F95( A, B, D, X, Y, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGGLM_F77 => LA_GGGLM                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:), D(:)
    COMPLEX(WP), INTENT(OUT) :: X(:), Y(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_GGGLM solves the general (Gauss-Markov) linear model (GLM)
!! problem:
!!      min ||y||2  subject to d=A*x + B*y
!!       x
!! where A and B are real or complex rectangular matrices and d is a real
!! or complex vector. Further, A is n by m, B is n by p, and d is n by 1,
!! and it is assumed that m <= n <= m+p, rank(A) = m, rank(A, B) = n.
!! These conditions ensure that the GLM problem has unique solution
!! vectors x and y. The problem is solved using the generalized QR
!! factorization of A and B.
!!        If matrix B is square and nonsingular, then the GLM problem is
!! equivalent to the weighted linear least squares problem
!!         min ||B^-1 * (d-A*x)||2
!!          x
!!
!! =========
!!
!!       SUBROUTINE LA_GGGLM( A, B, D, X, Y, INFO=info )
!!           <type>(<wp>), INTENT( INOUT ) :: A( :, : ), B(:,:), D(:)
!!           <type>(<wp>), INTENT( OUT ) :: X(:), Y(:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(A,1) = n and size(A,2) = m.
!!       On entry, the matrix A.
!!       On exit, the contents of A are destroyed.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n and size(B,2) = p.
!!       On entry, the matrix B.
!!       On exit, the contents of B are destroyed.
!! D     (input/output) REAL or COMPLEX array, shape (:) with
!!       size(D) = n.
!!       On entry, the vector d.
!!       On exit, the contents of D are destroyed.
!! X     (output) REAL or COMPLEX array, shape (:) with size(X) = m.
!!       The solution vector x.
!! Y     (output) REAL or COMPLEX array, shape (:) with size(Y) = p.
!!       The solution vector y.
!! INFO  Optional (output) INTEGER.
!!       = 0: successful exit
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGGLM"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); M = SIZE(A,2); P = SIZE(B,2)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < M ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P < N-M .OR. SIZE(B,1) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(D) /= N ) THEN; LINFO = -3
    ELSE IF( SIZE(X) /= M ) THEN; LINFO = -4
    ELSE IF( SIZE(Y) /= P ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGGLM_F77( N, M, P, A, MAX(1,N), B, MAX(1,N), &
                          D, X, Y, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT( WORK(1) )
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGGGLM_F95
SUBROUTINE ZGGLSE_F95( A, B, C, D, X, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GGLSE_F77 => LA_GGLSE                             !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:), C(:), D(:)
    COMPLEX(WP), INTENT(OUT) :: X(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_GGLSE solves the linear equality-constrained least squares
!! (LSE) problem:
!!      min || c - A*x||2 subject to B*x = d,
!! where A and B are real or complex rectangular matrices and c and d are
!! real or complex vectors. Further, A is m by n, B is p by n, c is m by 1
!! and d is p by 1, and it is assumed that
!!       p <= n <=  m + p, rank(B) = p,  rank [ A ] = n.
!!                                            [ B ]
!! These conditions ensure that the LSE problem has a unique solution x.
!! This is obtained using the generalized RQ factorization of the matrices
!! B and A.
!!
!! =========
!!
!!        SUBROUTINE LA_GGLSE( A, B, C, D, X, INFO=info )
!!          <type>(<wp>), INTENT( INOUT ) :: A(:,:), B(:,:), C(:), D(:)
!!          <type>(<wp>), INTENT( OUT ) :: X(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(A,1) = m and size(A,2) = n.
!!         On entry, the matrix A.
!!         On exit, the contents of A are destroyed.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = p and size(B,2) = n.
!!         On entry, the matrix B.
!!         On exit, the contents of B are destroyed.
!! C       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(C) = m.
!!         On entry, the vector c.
!!         On exit, the residual sum of squares for the solution is given
!!         by the sum of squares of elements n-p+1 to m.
!! D       (input/output) REAL or COMPLEX array, shape (:) with
!!         size(D) = p.
!!         On entry, The vectors d.
!!         On exit, the contents of D are destroyed.
!! X       (output) REAL or COMPLEX array, shape (:) with size(X) = n.
!!         The solution vector x.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGLSE"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, ISTAT, ISTAT1, N, M, MN, P
!!   .. LOCAL SAVE SCALARS ..
    INTEGER, SAVE :: LWORK = 0
!!   .. LOCAL POINTERS ..
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, MAX, MIN
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
    MN = MIN(M,N)
!!   .. TEST THE ARGUMENTS
    IF( M < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( P < 0 .OR. P > N .OR. P < N-M .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
    ELSE IF( SIZE(C) /= M ) THEN; LINFO = -3
    ELSE IF( SIZE(D) /= P ) THEN; LINFO = -4
    ELSE IF( SIZE(X) /= N ) THEN; LINFO = -5
    ELSE
       LWORK = MAX( 1, M + N + P , LWORK )
       ALLOCATE( WORK(LWORK), STAT = ISTAT )
       IF( ISTAT /= 0 ) THEN
          DEALLOCATE( WORK, STAT=ISTAT1 )
          LWORK = MAX( 1, M + N + P )
          ALLOCATE( WORK(LWORK), STAT = ISTAT )
          IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
       END IF
       IF ( ISTAT == 0 ) THEN
!!      .. CALL LAPACK77 ROUTINE
          CALL GGLSE_F77( M, N, P, A, MAX(1,M), B, MAX(1,P), &
                          C, D, X, WORK, LWORK, LINFO )
          IF( LINFO == 0 ) LWORK = INT(WORK(1))
       ELSE; LINFO = -100; END IF
       DEALLOCATE(WORK, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZGGLSE_F95
SUBROUTINE ZGGSVD_F95( A, B, ALPHA, BETA, K, L, U, V, Q, IWORK, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO                                           !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GGSVD_F77 => LA_GGSVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, K, L
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: ALPHA(:), BETA(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: U(:,:), V(:,:), Q(:,:)
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IWORK(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_GGSVD computes the generalized singular values and, optionally,
!! the transformation matrices from the generalized singular value
!! decomposition (GSVD) of a real or complex matrix pair (A,B), where A
!! is m by n and B is p by n. The GSVD of (A,B) is written
!!       A = U * SIGMA1(0, R)*Q^H , B = V * SIGMA2(0, R)*Q^H
!! where U , V and Q are orthogonal (unitary) matrices of dimensions m by m,
!! p by p and n by n, respectively. Let l be the rank of B and r the rank of
!! the (m + p) * n matrix ( A )
!!                        ( B )
!! , and let k = r-l. Then SIGMA1 and SIGMA2 are m*(k + l) and p * (k + l)
!! "diagonal" matrices, respectively, and R is a (k + l) * (k + l)
!! nonsingular triangular matrix. The detailed structure of SIGMA1 ,SIGMA2
!! and R depends on the sign of (m - k - l) as follows:
!!       The case m-k-l>=0:
!!
!!                               k   l
!!                      k      ( I   0 )
!!        SIGMA1 =      l      ( 0   C )
!!                    m-k-l    ( 0   0 )
!!
!!
!!                           k   l
!!       SIGMA2 =    l   ( 0   S )
!!                 p - l ( 0   S )
!!
!!
!!                          n-k-l   k     l
!!          (0, R) =   k   (  0    R11   R12  )
!!                     l   (  0     0    R22  )
!!
!! where C^2 + S^2 = I . We define
!! alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i=1,2,...,l
!! beta(1) = beta(2) = ... = beta(k) = 0, beta(k+i) = s(i i), i=1,2,...,l
!!
!! The case m-k-l < 0:
!!
!!                                k    m-k    k+l-m
!!            SIGMA1 =    k    (  I     0       0   )
!!                       m-k   (  0     C       0   )
!!
!!
!!                              k    m-k     k+l-m
!!                        m-k   ( 0     S        0  )
!!            SIGMA2 =   k+l-m  ( 0     0        I  )
!!                        p-l   ( 0     0        0  )
!!
!!
!!                                  n-k-l    k     m-k   k+l-m
!!                         k      (   0     R11    R12    R13  )
!!              (0,R) =   m-k     (   0      0     R22    R23  )
!!                       k+l-m    (   0      0      0     R33  )
!!
!! where C^2 + S^2 = I . We define
!!  alpha(1)=alpha(2)=...=alpha(k) = 1, alpha(k+i)=c(i i), i =1,2,...,m-k,
!!  alpha(m+1) = alpha(m+2)=...= alpha(k+l) = 0
!!  beta(1)=beta(2)= ... =beta(k)=0, beta(k+i)=s(i i), i=1,2,...,m-k,
!!  beta(m+1) = beta(m+2) = ... = beta(k+l) = 1
!!
!! In both cases the generalized singular values of the pair (A,B) are the
!! ratios
!!  sigma(i) = alpha(i)/beta(i), i = 1,2, ... ,k+l
!!
!! The first k singular values are infinite. The finite singular values
!! are real and nonnegative.
!!     LA_GGSVD computes the real (nonnegative) scalars alpha(i), beta(i),
!! i=1,2,..., k+l , the matrix R, and, optionally, the transformation
!! matrices U , V and Q.
!!
!! =========
!!
!!      SUBROUTINE LA_GGSVD( A, B, ALPHA, BETA, K=k, L=l, &
!!                       U=u, V=v, Q=q, IWORK=iwork, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: ALPHA(:), BETA(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: K, L
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: U(:,:), V(:,:), Q(:,:)
!!          INTEGER, INTENT(IN), OPTIONAL :: IWORK(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(A,1) = m and size(A,2) = n.
!!        On entry, the matrix A.
!!        On exit, A contains the triangular matrix R, or part of R, as
!!        follows:
!!        If m-k-l >= 0, then R is stored in A(1:k+l,n-k-l+1:n).
!!        If m-k-l < 0, then the matrix
!!                  ( R11     R12    R13 )
!!                (  0      R22    R23 )
!!        is stored in A(1:m,n-k-l+1:n).
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = p and size(B,2) = n.
!!        On entry, the matrix B.
!!        On exit, if m-k-l < 0, then R33 is stored in
!!        B(m-k+1:l,n+m-k-l+1:n).
!! ALPHA  (output) REAL array, shape (:) with size(ALPHA) = n
!!        The real scalars alpha(i) , i = 1, 2,..., k+l.
!! BETA   (output) REAL array, shape (:) with size(BETA) = n.
!!        The real scalars beta(i) , i = 1, 2, ..., k+l.
!!        Note: The generalized singular values of the pair (A,B) are
!!        sigma(i) = ALPHA(i)/BETA(i), i = 1, 2, ...,  k+l.
!!        If k + l < n, then ALPHA(k+l+1:n) = BETA(k+l+1:n) = 0.
!! K, L   Optional (output) INTEGER.
!!        The dimension parameters k and l.
!! U      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(U,1) = m.
!!        The matrix U .
!! V      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(V,1) = p.
!!        The matrix V .
!! Q      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Q,1) = n.
!!        The matrix Q.
!! IWORK  Optional (output) INTEGER array, shape(:) with size(IWORK) = n.
!!        IWORK contains sorting information. More precisely, the loop
!!             for i = k + 1, min(m, k + l)
!!                   swap ALPHA(i) and ALPHA(IWORK(i))
!!             end
!!        will sort ALPHA so that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(n).
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = 1, the algorithm failed to converge.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GGSVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBU, LJOBV, LJOBQ
   INTEGER :: M, N, P, LINFO, ISTAT, ISTAT1, S1U, S2U, S1V, S2V, &
              S1Q, S2Q, LK, LL
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLU(1,1), LLV(1,1), LLQ(1,1)
   INTEGER, POINTER :: LIWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; M = SIZE(A,1); N = SIZE(A,2); P = SIZE(B,1)
   IF( PRESENT(U) )THEN; S1U = SIZE(U,1); S2U = SIZE(U,2); LJOBU = "U"
   ELSE; S1U = 1; S2U = 1; LJOBU = "N"; END IF
   IF( PRESENT(V) )THEN; S1V = SIZE(V,1); S2V = SIZE(V,2); LJOBV = "V"
   ELSE; S1V = 1; S2V = 1; LJOBV = "N"; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2); LJOBQ = "Q"
   ELSE; S1Q = 1; S2Q = 1; LJOBQ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( M < 0 .OR. N < N )THEN; LINFO = -1
   ELSE IF( SIZE(B,2) /= N .OR. P < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( ALPHA ) /= N )THEN; LINFO = -3
   ELSE IF( SIZE( BETA ) /= N )THEN; LINFO = -4
   ELSE IF( PRESENT(U) .AND. ( S1U /= MAX(1,M) .OR.  S2U /= M ) )THEN; LINFO = -7
   ELSE IF( PRESENT(V) .AND. ( S1V /= MAX(1,P) .OR.  S2V /= P ) )THEN; LINFO = -8
   ELSE IF( PRESENT(Q) .AND. ( S1Q /= MAX(1,N) .OR.  S2Q /= N ) )THEN; LINFO = -9
   ELSE
    IF (PRESENT(IWORK)) THEN
      LIWORK => IWORK
    ELSE
      ALLOCATE( LIWORK(MAX(1,N)), STAT=ISTAT )
    ENDIF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( RWORK(MAX(1,2*N)), STAT=ISTAT )
      END IF
      IF( ISTAT == 0 ) THEN
         ALLOCATE( WORK( MAX(1,MAX(3*N,M,P)+N) ), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(U) )THEN
           IF( PRESENT(V) )THEN
             IF( PRESENT(Q) )THEN
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ELSE
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ENDIF
               ELSE
                IF( PRESENT(Q) )THEN
                   CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ELSE
                  CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, U, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                ENDIF
               ENDIF
               ELSE
                 IF( PRESENT(V) )THEN
                   IF( PRESENT(Q) )THEN
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ELSE
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        V, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ENDIF
                  ELSE
                   IF( PRESENT(Q) )THEN
                      CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), Q, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ELSE
                     CALL GGSVD_F77( LJOBU, LJOBV, LJOBQ, M, N, P, LK, LL, A, MAX(1,M), &
                         B, MAX(1,P), ALPHA, BETA, LLU, MAX(1,S1U), &
                        LLV, MAX(1,S1V), LLQ, MAX(1,S1Q), WORK, RWORK, LIWORK, LINFO )
                   ENDIF
                  ENDIF
                 ENDIF
         IF( PRESENT(K) ) K = LK
         IF( PRESENT(L) ) L = LL
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
      IF (.NOT. PRESENT(IWORK)) DEALLOCATE(LIWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZGGSVD_F95
 SUBROUTINE ZGTSV1_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, 1, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZGTSV1_F95
 SUBROUTINE ZGTSV_F95( DL, D, DU, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: GTSV_F77 => LA_GTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: DL(:), D(:), DU(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_GTSV computes the solution to a real or complex linear system of
!! equations A*X = B, where A is a square tridiagonal matrix and X and B
!! are rectangular matrices or vectors. The LU decomposition is used to
!! factor the matrix A as A = L*U , where L is a product of permutation
!! and unit lower bidiagonal matrices and U is upper triangular with
!! nonzeros in only the main diagonal and first two superdiagonals.
!! The factored form of A is then used to solve the above system.
!!
!! Note: The system A^T*X = B may be solved by interchanging the order of
!! the arguments DU and DL.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSV( DL, D, DU, B, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: DL(:), D(:), DU(:), <rhs>
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs> ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! DL    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1, where n is the order of A.
!!       On entry, the subdiagonal of A.
!!       On exit, the n-2 elements of the second superdiagonal of U in
!!       DL(1),..., DL(n-2).
!! D     (input/output) REAL or COMPLEX array, shape (:) with size(D) = n.
!!       On entry, the diagonal of A.
!!       On exit, the diagonal of U .
!! DU    (input/output) REAL or COMPLEX array, shape (:) with
!!       size(DL) = n-1.
!!       On entry, the superdiagonal of A.
!!       On exit, the first superdiagonal of U .
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = n or shape (:) with size(B) = n.
!!       On entry, the matrix B.
!!       On exit, the solution matrix X .
!! INFO  Optional (output) INTEGER
!!       = 0: successful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, then U(i,i) = 0. The factorization has not been
!!       completed unless i = n. The factor U is singular, so the solution
!!       could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_GTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( SIZE( DL ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -1
    ELSE IF( N < 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
       CALL GTSV_F77( N, NRHS, DL, D, DU, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZGTSV_F95
SUBROUTINE ZGTSVX1_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                            IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0 ) THEN; LINFO = -3
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -4
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0 ) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, 1, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGTSVX1_F95
SUBROUTINE ZGTSVX_F95(DL, D, DU, B, X, DLF, DF, DUF, DU2, &
                           IPIV, FACT, TRANS, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: GTSVX_F77 => LA_GTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: TRANS, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: DL(:), D(:), DU(:), B(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: DLF(:), DF(:), DUF(:), DU2(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_GTSVX computes the solution to a real or complex linear system
!! of equations of the form A*X = B, A^T*X = B or A^H*X = B, where A is a
!! square tridiagonal matrix and X and B are rectangular matrices or
!! vectors.
!!     LA_GTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_GTSVX( DL, D, DU, B, X, DLF=dlf, DF=df, DUF=duf, &
!!               DU2=du2, IPIV=ipiv, FACT=fact, TRANS=trans, FERR=ferr, &
!!               BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(IN) :: DL(:), D(:), DU(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: DLF(:), DF(:), &
!!                                                   DUF(:), DU2(:)
!!           INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT, TRANS
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! DL     (input) REAL or COMPLEX array, shape (:) with size(DL) = n-1.
!!        The subdiagonal of A.
!! D      (input) REAL or COMPLEX array, shape (:) with size(D) = n.
!!        The diagonal of A.
!! DU     (input) REAL or COMPLEX array, shape (:) with size(DU) = n-1.
!!        The superdiagonal of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        The matrix B.
!! X      (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!        and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!        The solution matrix X .
!! DLF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DLF)= n-1.
!!        If FACT = "F" then DLF is an input argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!!        If FACT = "N" then DLF is an output argument that contains the
!!        multipliers that define the matrix L from the LU factorization
!!        of A.
!! DF     Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DF)= n.
!!        If FACT = "F" then DF is an input argument that contains the
!!        diagonal of the matrix U .
!!        If FACT = "N" then DF is an output argument that contains the
!!        diagonal of the matrix U .
!! DUF    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DUF) = n-1.
!!        If FACT = "F" then DUF is an input argument that contains the
!!        first superdiagonal of U.
!!        If FACT = "N" then DUF is an output argument that contains the
!!        first superdiagonal of U.
!! DU2    Optional (input or output) REAL or COMPLEX array, shape (:) with
!!        size(DU2) = n-2.
!!        If FACT = "F", then DU2 is an input argument that contains the
!!        second superdiagonal of U.
!!        If FACT = "N", then DU2 is an output argument that contains the
!!        second superdiagonal of U.
!! IPIV   Optional (input or output) INTEGER array, shape (:) with
!!        size(IPIV) = n.
!!        If FACT = "F" then IPIV is an input argument that contains the
!!        pivot indices from the LU factorization of A.
!!        If FACT = "N", then IPIV is an output argument that contains the
!!        pivot indices from the LU factorization of A; row i of the
!!        matrix was interchanged with row IPIV(i). IPIV(i) will always
!!        be either i or i+1; IPIV(i) = i indicates a row interchange was
!!        not required.
!! FACT   Optional (input) CHARACTER(LEN=1).
!!        Specifies whether the factored form of A is supplied on entry.
!!            = "N": The matrix will be copied to DLF, DF and DUF and
!!                 factored.
!!            = "F": DLF, DF, DUF, DU2 and IPIV contain the factored form
!!                 of A.
!!        Default value: "N".
!! TRANS  Optional (input) CHARACTER(LEN=1).
!!        Specifies the form of the system of equations:
!!            = "N": A*X = B (No transpose)
!!            = "T": A^T*X = B (Transpose)
!!            = "C": A^H*X = B (Conjugate transpose)
!!        Default value: "N".
!! FERR   Optional (output) REAL array of shape (:), with size(FERR) =
!!        size(X,2), or REAL scalar.
!!        The estimated forward error bound for each solution vector X(j)
!!        (the j-th column of the solution matrix X). If XTRUE is the true
!!        solution corresponding to X(j) , FERR(j) is an estimated upper
!!        bound for the magnitude of the largest element in (X(j)-XTRUE)
!!        divided by the magnitude of the largest element in X(j). The
!!        estimate is as reliable as the estimate for RCOND and is almost
!!        always a slight overestimate of the true error.
!! BERR   Optional (output) REAL array of shape (:), with size(BERR) =
!!        size(X,2), or REAL scalar.
!!        The componentwise relative backward error of each solution
!!        vector X(j) (i.e.,the smallest relative change in any element of
!!        A or B that makes X(j) an exact solution).
!! RCOND  Optional (output) REAL.
!!        The estimate of the reciprocal condition number of the matrix A.
!!        If RCOND is less than the machine precision, the matrix is
!!        singular to working precision. This condition is indicated by
!!        a return code of INFO > 0.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, and i is
!!           <= n: U(i,i) = 0. The factorization has not been completed
!!               unless i = n. The factor U is singular, so the solution
!!               could not be computed.
!!           = n+1: U is nonsingular, but RCOND is less than machine
!!               precision, meaning that the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!                 error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_GTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LTRANS
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SIPIV, SDLF, SDF, SDUF, SDU2, &
              SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LDLF(:), LDF(:), LDUF(:), LDU2(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(DLF) )THEN; SDLF = SIZE(DLF); ELSE; SDLF = N-1; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(DUF) )THEN; SDUF = SIZE(DUF); ELSE; SDUF = N-1; END IF
   IF( PRESENT(DU2) )THEN; SDU2 = SIZE(DU2); ELSE; SDU2 = N-2; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(TRANS))THEN; LTRANS = TRANS; ELSE; LTRANS="N"; END IF
!!  PRINT *, LINFO, ISTAT, N, NRHS, LFACT, SIPIV, SDLF, SDF, SDUF, SDU2, SFERR, SBERR, LTRANS
!!  .. TEST THE ARGUMENTS
   IF( SIZE( DL ) /= N-1 .AND. N/=0 ) THEN; LINFO = -1
   ELSE IF( N < 0 ) THEN; LINFO = -2
   ELSE IF( SIZE( DU ) /= N-1 .AND. N/=0) THEN; LINFO = -3
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -4
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -5
   ELSE IF( SDLF /= N-1 .AND. N/=0) THEN; LINFO = -6
   ELSE IF( SDF /= N ) THEN; LINFO = -7
   ELSE IF( SDUF /= N-1 .AND. N/=0 ) THEN; LINFO = -8
   ELSE IF( SDU2 /= N-2 .AND. N>1 ) THEN; LINFO = -9
   ELSE IF( SIPIV /= N )THEN; LINFO = -10
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -13
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -14
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") ) ) .OR. &
       ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(DF) .AND. PRESENT(IPIV) ) ) )THEN
      LINFO = -11
   ELSE IF( .NOT.( LSAME(LTRANS,"N") .OR.  LSAME(LTRANS,"T") .OR. &
                  LSAME(LTRANS,"C") ) )THEN; LINFO = -12
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN
         ALLOCATE( LDLF(N-1),LDF(N),LDUF(N-1),LDU2(N-2), STAT=ISTAT )
      ELSE; LDLF => DLF; LDF => DF; LDUF => DUF; LDU2 => DU2; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE( WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL GTSVX_F77( LFACT, LTRANS, N, NRHS, DL, D, DU, LDLF, LDF, LDUF, &
                         LDU2, LPIV, B, N, X, N, LRCOND, LFERR, LBERR, &
                         WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DLF) ) DEALLOCATE( LDLF, LDF, LDUF, LDU2, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZGTSVX_F95
SUBROUTINE ZHBEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBEV_F77 => LA_HBEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HBEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,N)), RWORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
            CALL HBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, RWORK, LINFO )
         ELSE
            CALL HBEV_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, RWORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHBEV_F95
SUBROUTINE ZHBEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBEVD_F77 => LA_HBEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBEV and LA_SBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in band form.
!!     LA_HBEV and LA_HBEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in band form.
!!     LA_SBEVD and LA_HBEVD use a divide and conquer algorithm. They are
!! much faster than LA_SBEV and LA_HBEV for large matrices but use more
!! workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBEV / LA_HBEV / LA_SBEVD /
!!                  LA_HBEVD( AB, W, UPLO=uplo, Z=z, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!             REAL(<wp>), INTENT(OUT) :: W(:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!             <type> ::= REAL | COMPLEX
!!             <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and
!!        size(AB,2) = n, where kd is the number of subdiagonals or
!!        superdiagonals in the band and n is the order of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                    1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                    1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The eigenvalues in ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:) with
!!        size(Z,1) = n.
!!        The columns of Z contain the orthonormal eigenvectors of A in
!!        the order of the eigenvalues.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i off-diagonal elements of an intermediate
!!             tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, KD, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LRWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0, &
                    LRWORKN = 0, LRWORKV = 0
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1)); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
      IF( LSAME(LJOBZ,"N") )THEN
         LWORK = MAX( 1, N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
         LRWORK = MAX( 1, N, LIWORKN )
      ELSE
         LWORK = MAX( 1, 2*N**2, LWORKV )
         LRWORK = MAX(1+5*N+2*N**2, LWORKV)
         LIWORK = MAX( 3+5*N, LIWORKV )
      END IF
      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE( WORK, RWORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX(1,N)
            LRWORK = MAX(1,N); LIWORK = 1
         ELSE; LRWORK = 1+5*N+2*N**2
           LWORK = MAX(1, 2*N**2); LIWORK = 3+5*N; END IF
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
            CALL HBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, Z, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
            CALL HBEVD_F77( LJOBZ, LUPLO, N, KD, A, LD, W, LLZ, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ENDIF
         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN
               LWORKN = INT(WORK(1)+1); LRWORKN = INT(RWORK(1)+1)
               LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)+1); LRWORKV = INT(RWORK(1)+1)
               LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHBEVD_F95
SUBROUTINE ZHBEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: HBEVX_F77 => LA_HBEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBEVX / LA_HBEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! band matrix A. Eigenvalues and eigenvectors can be selected by
!! specifying either a range of values or a range of indices for the
!! desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SBEVX / LA_HBEVX( AB, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 Q=q, ABSTOL=abstol, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AB(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!            INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!            INTEGER, INTENT(OUT), OPTIONAL :: M
!!            INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!            REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL j COMPLEX
!!            <wp> ::= KIND(1.0) j KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!        of subdiagonals or superdiagonals in the band and n is the order
!!        of A.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix A in band storage. The kd + 1 diagonals of A
!!        are stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!        On exit, AB is overwritten by values generated during the
!!        reduction of A to a tridiagonal matrix T . If UPLO = "U" the
!!        first superdiagonal and the diagonal of T are returned in rows
!!        kd and kd + 1 of AB. If UPLO = "L", the diagonal and first
!!        subdiagonal of T are returned in the first two rows of AB.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U" : Upper triangle of A is stored;
!!        = "L" : Lower triangle of A is stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX array, shape (:,:) with
!!        size(Z,1) = n and size(Z,2) = M.
!!        The first M columns of Z contain the orthonormal eigenvectors of
!!        the matrix A corresponding to the selected eigenvalues, with the
!!        i-th column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). If an eigenvector fails to converge, then
!!        that column of Z contains the latest approximation to the
!!        eigenvector, and the index of the eigenvector is returned in
!!        IFAIL.
!!        Note: The USEr must ensure that at least M columns are supplied
!!        in the array Z. When the exact value of M is not known in
!!        advance, an upper bound must be used. In all cases M<=n.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0<=M<=size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) = n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional (output) REAL or COMPLEX square array, shape(:,:) with
!!        size(Q,1) = n.
!!        The n by n unitary matrix used in the reduction to tridiagonal
!!        form. This is computed only if Z is present.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|, |b|),
!!        where <wp> is the working precision. If ABSTOL<=0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing A to tridiagonal form. Eigenvalues will be computed most
!!        accurately when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBEVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, S1Q, S2Q, KD
   INTEGER, TARGET :: ISTAT1(1)
   COMPLEX(WP), TARGET :: LLZ(1,1), LLQ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:), LQ(:,:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A,2); LD = MAX(1,SIZE(A,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1 ) .AND. N>0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
         IF( ISTAT == 0 )THEN
            IF( PRESENT(Q) )THEN; LQ => Q
            ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
         END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), RWORK(MAX(1,7*N)), WORK(MAX(1,N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
                 CALL HBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                 LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                 RWORK, IWORK, LIFAIL, LINFO )
            ELSE
                 CALL HBEVX_F77( LJOBZ, LRANGE, LUPLO, N, KD, A, LD, LQ, S1Q, LVL, LVU, &
     &                 LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                 RWORK, IWORK, LIFAIL, LINFO )
           ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, RWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHBEVX_F95
SUBROUTINE ZHBGV_F95( A, B, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBGV_F77 => LA_HBGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HBGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KA, KB, &
              LDA, LDB
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; KA = SIZE(A,1)-1; N = SIZE(A,2); LDA = MAX(SIZE(A,1),1)
   ISTAT = 0; KB = SIZE(B,1)-1; LDB = MAX(SIZE(B,1),1)
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KA < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( KB < 0 .OR. SIZE(B,2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,N)), RWORK(MAX(1,3*N)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
            CALL HBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, Z, S1Z, &
                        WORK, RWORK, LINFO )
          ELSE
            CALL HBGV_F77( LJOBZ, LUPLO, N, KA, KB, A, LDA, B, LDB, W, LLZ, S1Z, &
                        WORK, RWORK, LINFO )
          ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO,ISTAT)
END SUBROUTINE ZHBGV_F95
SUBROUTINE ZHBGVD_F95( AB, BB, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP =>  DP                                     !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HBGVD_F77 => LA_HBGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SBGV, LA_SBGVD, LA_HBGV and LA_HBGVD compute all eigenvalues and,
!! optionally, all eigenvectors of the generalized eigenvalue problem
!!                    A*z = lambda*B*z,
!! where A and B are real symmetric in the cases of LA_SBGV and LA_SBGVD
!! and complex Hermitian in the cases of LA_HBGV and LA_HBGVD. Matrix B
!! is positive definite. Matrices A and B are stored in a band format.
!!    LA_SBGVD and LA_HBGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SBGV and
!! LA_HBGV for large matrices but use more workspace.
!!
!! =========
!!
!!         SUBROUTINE LA_SBGV / LA_SBGVD / LA_HBGV / LA_HBGVD( AB, BB, &
!!                                        W, UPLO=uplo, Z=z, INFO=info )
!!               <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!               REAL(<wp>), INTENT(OUT) :: W(:)
!!               CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!               <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!               INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!               <type> ::= REAL | COMPLEX
!!               <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!         of subdiagonals or superdiagonals in the band and n is the
!!         order of A and B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The ka + 1 diagonals of
!!         A are stored in the rows of AB so that the j-th column of A
!!         is stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                  1<=j<=n.
!!         On exit, the contents of AB are destroyed.
!! BB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!         of subdiagonals or superdiagonals in the band of B.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix B in band storage. The kb + 1 diagonals of
!!         B are stored in the rows of BB so that the j-th column of B
!!         is stored in the j-th column of BB as follows:
!!         if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                  1<=j<=n
!!         if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                  1<=j<=n.
!!         On exit, the factor S from the split Cholesky factorization
!!         B = S^H*S.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The matrix Z of eigenvectors, normalized so that Z^H*B*Z = I.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!            <= n: if INFO = i, i off-diagonal elements of an
!!             intermediate tridiagonal form did not converge to
!!             zero.
!!            > n: if INFO = n+i, for 1<=i<=n, then the leading minor of
!!             order i of B is not positive definite. The factorization
!!             of B could not be completed and no eigenvalues or
!!             eigenvectors were computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, ISTAT, ISTAT1, S1Z, S2Z, KAB, KBB, &
          LDAB, LDBB, LWORK, LIWORK, LRWORK, IWORKMIN(1)
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
  REAL(WP), TARGET :: RWORKMIN(1)
  REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; KAB = SIZE(AB,1)-1; N = SIZE(AB,2); LDAB = MAX(SIZE(AB,1),1)
      ISTAT = 0; KBB = SIZE(BB,1)-1; LDBB = MAX(SIZE(BB,1),1)
      IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
      ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
        IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
          IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
          ELSE IF( KBB < 0 .OR. SIZE(BB,2) /= N ) THEN; LINFO = -2
          ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
          ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
          ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
          ELSE IF( N > 0 )THEN
            LIWORK = -1
            LRWORK = -1
            LWORK = -1
            IF (PRESENT (Z)) THEN
             CALL HBGVD_F77(LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &           LDBB, W, Z, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, &
     &           IWORKMIN, LIWORK, LINFO )
             ELSE
               CALL HBGVD_F77(LJOBZ, LUPLO, N, KAB, KBB, AB, LDAB, BB, &
     &           LDBB, W, LLZ, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, &
     &           IWORKMIN, LIWORK, LINFO )
             ENDIF
             LWORK = WORKMIN(1)
             LRWORK = RWORKMIN(1)
             LIWORK = IWORKMIN(1)
!! THEN NEXT 3 LINES SHOULD BE REMOVED WHEN THE BUG IS FIXED IN LAPACK77
            LWORK = 2 * LWORK + 1
            LRWORK =2 * LRWORK + 1
            LIWORK =2 * LIWORK + 1

            ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF (PRESENT (Z)) THEN
                CALL HBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB,LDAB, BB, &
     &            LDBB, W, Z, S1Z,  WORK, LWORK, RWORK, LRWORK, IWORK, &
     &            LIWORK, LINFO )
              ELSE
                CALL HBGVD_F77( LJOBZ, LUPLO, N, KAB, KBB, AB,LDAB, BB, &
     &            LDBB, W, LLZ, S1Z,  WORK, LWORK, RWORK, LRWORK, IWORK, &
     &            LIWORK, LINFO )
              ENDIF
            ELSE; LINFO = -100; ENDIF
            DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
          ENDIF
          CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHBGVD_F95
SUBROUTINE ZHBGVX_F95( AB, BB,  W, UPLO, Z, VL, VU, IL, IU, &
      &         M, IFAIL, Q,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP =>  DP                                  !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HBGVX_F77 => LA_HBGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:), Q(:,:)
      COMPLEX(WP), INTENT(INOUT) :: AB(:,:), BB(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SBGVX and LA_HBGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of the generalized eigenvalue problem
!!                      A*z = lambda*B*z,
!! where A and B are real symmetric in the case of LA_SBGVX and complex
!! Hermitian in the case of LA_HBGVX. In both cases B is positive
!! definite. Matrices A and B are stored in a band format. Eigenvalues
!! and eigenvectors can be selected by specifying either a range of
!! values or a range of indices for the desired eigenvalues.
!!
!! =========
!!
!!           SUBROUTINE LA_SBGVX / LA_HBGVX( AB, BB, W, UPLO=uplo, Z=z, &
!!                   VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, Q=q, &
!!                   ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: AB(:,:), BB(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              <type>(<wp>), INTENT(OUT), OPTIONAL :: Q(:,:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!           where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = ka + 1 and size(AB,2) = n, where ka is the number
!!        of subdiagonals or superdiagonals in the band of A and n is
!!        the order of A and B.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of A in band storage. The ka + 1 diagonals of A are
!!        stored in the rows of AB so that the j-th column of A is
!!        stored in the j-th column of AB as follows:
!!        if UPLO = "U", AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka),
!!                                                   1<=j<=n.
!!        On exit, the contents of AB are destroyed.
!! BB     (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(BB,1) = kb + 1 and size(BB,2) = n, where kb is the number
!!        of subdiagonals or superdiagonals in the band of B.
!!        On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!        triangle of matrix B in band storage. The kb + 1 diagonals of
!!        B are stored in the rows of BB so that the j-th column of B
!!        is stored in the j-th column of BB as follows:
!!        if UPLO = "U", BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j,
!!                                                   1<=j<=n
!!        if UPLO = "L", BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb),
!!                                                   1<=j<=n.
!!        On exit, the factor S from the split Cholesky factorization
!!                     B = S^H*S.
!! W      (output) REAL array, shape (:) with size(W) = n.
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangles of A and B are stored;
!!            = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! Z      Optional (output) REAL or COMPLEX square array, shape (:,:)
!!        with size(Z,1) = n.
!!        The first M columns of Z contain the orthonormal eigenvectors
!!        corresponding to the selected eigenvalues, with the i-th
!!        column of Z containing the eigenvector associated with the
!!        eigenvalue in W(i). The eigenvectors are normalized so that
!!        Z^H*B*Z = I . If an eigenvector fails to converge, then that
!!        column of Z contains the latest approximation to the
!!        eigenvector and the index of the eigenvector is returned in
!!        IFAIL.
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL)=n.
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: If Z is present then IFAIL should also be present.
!! Q      Optional, (Output) REAL or COMPLEX square array, shape(:,:)
!!        with size(Q,1) = n.
!!        If Z is present, the matrix used in the reduction of
!!        A*z = lambda*B*z to tridiagonal form.
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An
!!        approximate eigenvalue is accepted as converged when it is
!!        determined to lie in an interval [a,b] of width less than or
!!        equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal
!!        form. Eigenvalues will be computed most accurately when ABSTOL
!!        is set to twice the underflow threshold
!!                   2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: the algorithm failed to converge or matrix B is not
!!           positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i,
!!             then i eigenvectors failed to converge. Their indices
!!             are stored in array IFAIL.
!!           > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!             minor of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!        If INFO is not present and an error occurs, then the program
!!        is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HBGVX"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDAB, LDBB, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, S1Q, S2Q, KAB, KBB
      INTEGER, TARGET :: ISTAT1(1)
      COMPLEX(WP), TARGET :: LLZ(1,1), LLQ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:), LQ(:,:)
      REAL(WP), POINTER :: RWORK (:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KAB = SIZE(AB,1)-1; KBB = SIZE(BB,1)-1
   N = SIZE(AB,2); LDAB = MAX(1,SIZE(AB,1))
   LDBB = MAX(1, SIZE(BB,1))
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(Q) )THEN; S1Q = SIZE(Q,1); S2Q = SIZE(Q,2)
   ELSE; S1Q = N; S2Q = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
   ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
      ELSE; LRANGE = "A" ; END IF

      IF( KAB < 0 .OR. N < 0 ) THEN; LINFO = -1
      ELSE  IF (KBB < 0) THEN; LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
      ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -5
      ELSE IF( LVU < LVL )THEN; LINFO = -6
      ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &    (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -7
      ELSE IF( LRANGE == "I" .AND. ( LIU.LT.MIN( N, LIL ) .OR. LIU.GT.N)) THEN; LINFO = -8
      ELSE IF( N < LIU )THEN; LINFO = -9
      ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
      ELSE IF( S1Q /= N .OR. S2Q /= N .OR. PRESENT(Q).AND..NOT.PRESENT(Z) )THEN; LINFO = -11
      ELSE IF( N > 0 )THEN
          IF( PRESENT(Z) ) THEN; LJOBZ = "V"
            IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
            ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
            IF( ISTAT == 0 )THEN
              IF( PRESENT(Q) )THEN; LQ => Q
              ELSE; ALLOCATE( LQ(N,N), STAT=ISTAT ); END IF
            END IF
          ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; LQ => LLQ; S1Q =1; ENDIF
!! .. DETERMINE THE WORKSPACE
          IF( ISTAT == 0 ) THEN
            ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,N)), RWORK(MAX(1,7*N)), STAT=ISTAT)
            IF( ISTAT == 0 )THEN
              IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
              ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
              IF (PRESENT (Z))  THEN
                CALL HBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z,&
     &            S1Z, WORK, RWORK, IWORK, LIFAIL, LINFO )
              ELSE
                 CALL HBGVX_F77( LJOBZ, LRANGE, LUPLO, N, KAB, KBB, AB, LDAB, &
     &            BB, LDBB, LQ, S1Q, LVL, LVU, LIL, LIU, LABSTOL, LM, W, LLZ,&
     &            S1Z, WORK, RWORK, IWORK, LIFAIL, LINFO )
              ENDIF
                  IF( PRESENT(M) ) M = LM
                ELSE; LINFO = -100; END IF
                END IF
        IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
        IF( PRESENT(Z) .AND. .NOT.PRESENT(Q) ) DEALLOCATE( LQ, STAT=ISTAT1(1) )
        DEALLOCATE(IWORK, WORK, RWORK,  STAT=ISTAT1(1))
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHBGVX_F95


SUBROUTINE ZHEEV_F95( A, W, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEV_F77 => LA_HEEV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEEV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LWORK, NB
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; ISTAT = 0; LD = MAX(1,N)
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      END IF
     LWORK = (1+NB)*N
      ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         LWORK = 2*N-1
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( ISTAT == 0 ) ALLOCATE( RWORK(MAX(1,3*N-2)), STAT=ISTAT )
!
      IF( LINFO == 0 )THEN
         CALL HEEV_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, RWORK, LINFO )
      ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHEEV_F95
SUBROUTINE ZHEEVD_F95( A, W, JOBZ, UPLO, INFO )
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEVD_F77 => LA_HEEVD                              !!((07-B-INT_LAPACK1.f90))
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEV and LA_SYEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A.
!!      LA_HEEV and LA_HEEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A.
!!      LA_SYEVD and LA_HEEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYEV and
!! LA_HEEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYEV / LA_HEEV / LA_SYEVD / LA_HEEVD( A, W, &
!!                       JOBZ=jobz, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the columns of A contain the orthonormal
!!        eigenvectors of the matrix A in the order of the eigenvalues.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The eigenvalues in ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value
!!        > 0: if INFO = i, then i off-diagonal elements of an
!!        intermediate tridiagonal form did not converge to zero.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: N, LINFO, LD, ISTAT, ISTAT1, LIWORK, LMWORK, LWORK, LRWORK
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), TARGET :: WORKMIN(1)
   REAL(WP), TARGET :: RWORKMIN(1)
   INTEGER, TARGET :: IWORKMIN(1)
   INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE( A, 1 ); LINFO = 0; LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
       LWORK = -1
       LRWORK = -1
       LIWORK = -1
       CALL HEEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORKMIN, LWORK, &
     &  RWORKMIN, LRWORK, IWORKMIN, LIWORK,  LINFO )
       LWORK = WORKMIN(1)
       LRWORK = RWORKMIN(1)
       LIWORK = IWORKMIN(1)
      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         IF( LSAME(LJOBZ,"V") )THEN
           LMWORK = 1+6*N+2*N**2
         ELSE
           LMWORK = 2*N+1
         END IF
         DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
         LWORK = LMWORK
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
!
      IF( LINFO == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEEVD_F77( LJOBZ, LUPLO, N, A, LD, W, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK,  LINFO )
      ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHEEVD_F95
SUBROUTINE ZHEEVR_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, M, ISUPPZ,  ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: HEEVR_F77 => LA_HEEVR                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: ISUPPZ(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!       LA_SYEVR / LA_HEEVR compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!       LA_SYEVR and LA_HEEVR use a relatively robust representation
!! (RRR) algorithm. It is usually the fastest algorithm of all and uses
!! the least workspace.
!!
!! ========
!!
!!        SUBROUTINE LA SYEVR / LA HEEVR( A, W, JOBZ=jobz, &
!!                 UPLO=uplo, VL=vl, VU=vu, IL=il, IU=iu, M=m, &
!!                 ISUPPZ= isuppz, ABSTOL=abstol, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!           INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!           INTEGER, INTENT(OUT), OPTIONAL :: M
!!           INTEGER, INTENT(OUT), OPTIONAL :: ISUPPZ(:)
!!           REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A.
!!         On exit:
!!         If JOBZ = "V", then the first M columns of A contain the
!!         orthonormal eigenvectors of the matrix A corresponding to the
!!         selected eigenvalues, with the i-th column of A containing the
!!         eigenvector associated with the eigenvalue in W(i).
!!         If JOBZ = "N", the upper triangle (if UPLO = "U") or the lower
!!         triangle (if UPLO = "L") of A, including the diagonal, is
!!         destroyed.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The first M elements contain the selected eigenvalues in
!!         ascending order.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!         = "N": Computes eigenvalues only;
!!         = "V": Computes eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! VL,VU   Optional (input) REAL.
!!         The lower and upper bounds of the interval to be searched for
!!         eigenvalues. VL < VU.
!!         Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!         <wp> ::= KIND(1.0) | KIND(1.0D0).
!!         Note: Neither VL nor VU may be present if IL and/or IU is
!!         present.
!! IL,IU   Optional (input) INTEGER.
!!         The indices of the smallest and largest eigenvalues to be
!!         returned. The IL-th through IU-th eigenvalues will be found.
!!            1 <= IL <= IU <= size(A,1).
!!         Default values: IL = 1 and IU = size(A,1).
!!         Note: Neither IL nor IU may be present if VL and/or VU is
!!         present.
!!         Note: All eigenvalues are calculated if none of the arguments
!!         VL, VU, IL and IU are present.
!! M       Optional (output) INTEGER.
!!         The total number of eigenvalues found. 0 <= M <= size(A,1).
!!         Note: If IL and IU are present then M = IU-IL+1.
!! ISUPPZ  Optional (output) INTEGER array, shape (:) with
!!         size(ISUPPZ) = 2*max(1,M).
!!         The support of the eigenvectors in A, i.e., the indices
!!         indicating the nonzero elements. The i-th eigenvector is
!!         nonzero only in elements ISUPPZ(2i-1) through ISUPPZ(2i) .
!!         Note: ISUPPZ must be absent if JOBZ = "N".
!! ABSTOL  Optional (input) REAL.
!!         The absolute error tolerance for the eigenvalues. An
!!         approximate eigenvalue is accepted as converged when it is
!!         determined to lie in an interval [a, b] of width less than or
!!         equal to ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!         where <wp> is the working precision. If ABSTOL <= 0, then
!!         EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!         ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!         reducing A to tridiagonal form.
!!         Default value: 0.0_<wp>.
!!         Note: Eigenvalues are computed most accurately if ABSTOL is set
!!         to LA_LAMCH(1.0_<wp>,"Safe minimum"), not zero.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVR"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, ISTAT, &
     &  LIWORK, SISUPPZ, NN, LRWORK
      INTEGER:: IWORKMIN(1)
      COMPLEX(WP) :: WORKMIN(1)
      REAL(WP), POINTER :: RWORK(:)
      REAL(WP) :: RWORKMIN(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LISUPPZ(:)
      COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
      N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
      NN=2*MAX(1,N)
      IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
      IF( PRESENT(ISUPPZ) )THEN; SISUPPZ = SIZE(ISUPPZ); ELSE; SISUPPZ = NN; END IF
      IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U";  END IF
      IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL);  ENDIF
      IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
      IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
      IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS ..
        IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
        ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
        ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN; LINFO = -3
        ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
        ELSE IF( LVU < LVL )THEN; LINFO = -5
        ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. (PRESENT(IL) .OR. PRESENT(IU)) )THEN
          LINFO = -6
        ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0)THEN; LINFO = -7
        ELSE IF( N < LIU )THEN; LINFO = -8
        ELSE IF( SISUPPZ /= NN .OR. PRESENT(ISUPPZ).AND.LSAME(LJOBZ,"N"))THEN; LINFO = -10
        ELSE IF( N > 0 )THEN
          IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
            LRANGE = "V"; LM = N
          ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
            LRANGE = "I"; LM = LIU-LIL+1
          ELSE
            LRANGE = "A"; LM = N
          END IF
          IF ( LSAME(LJOBZ,"V") ) THEN
              LDZ=N; LZ=LM
          ELSE
              LDZ=1; LZ=1
          ENDIF
          ALLOCATE (Z(LDZ,LZ), STAT=ISTAT)
!!  .. QUERING THE SIZE OF WORKSPACE ..
             LWORK = -1
             LRWORK = -1
             LIWORK = -1
                CALL HEEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &             LIL, LIU, LABSTOL, LM, W, Z, LDZ, IWORKMIN, &
     &             WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, LIWORK, LINFO )
!! THE NEXT  LINE SHOULD BE
!!           LWORK = WORKMIN(1) WHEN  THE LAPACK IS FIXED
            LWORK = 10*WORKMIN(1)+10000
            LRWORK = RWORKMIN(1)
            LIWORK = IWORKMIN(1)
            DEALLOCATE(Z)

            ALLOCATE(IWORK(LIWORK), RWORK(LRWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 100; ENDIF
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF (ISTAT /=0) THEN ; LINFO = -100; GOTO 200; ENDIF

            ALLOCATE(LISUPPZ(NN), STAT=ISTAT)
            IF (ISTAT /= 0) THEN ; LINFO = -100; GOTO 300; ENDIF

            ALLOCATE(Z(LDZ, LZ), STAT = ISTAT)
            IF(ISTAT /= 0) THEN; LINFO = -100; GOTO 400; ENDIF

            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL; ELSE
!!              LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
              LABSTOL = 0.0_WP;  ENDIF
!! .. CALL LAPACK77 ROUTINE ..
              CALL HEEVR_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &          LIL, LIU, LABSTOL, LM, W, Z, LDZ, LISUPPZ, &
     &          WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, LINFO )
              IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
              IF( PRESENT(M) ) M = LM
              IF(PRESENT(ISUPPZ)) ISUPPZ = LISUPPZ

              DEALLOCATE(Z)
400           DEALLOCATE(LISUPPZ)
300           DEALLOCATE(WORK)
200           DEALLOCATE(IWORK, RWORK)
         ENDIF
100         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHEEVR_F95
SUBROUTINE ZHEEVX_F95( A, W, JOBZ, UPLO, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEEVX_F77 => LA_HEEVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYEVX / LA_HEEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex Hermitian
!! matrix A. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!         SUBROUTINE LA_SYEVX / LA_HEEVX ( A, W, JOBZ=jobz, UPLO=uplo, &
!!                        VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                        ABSTOL=abstol, INFO=info )
!!              <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!              REAL(<wp>), INTENT(OUT) :: W(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!              INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!              INTEGER, INTENT(OUT), OPTIONAL :: M
!!              INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!              REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of the
!!        matrix A.
!!        On exit:
!!        If JOBZ = "V", then the first M columns of A contain the
!!        orthonormal eigenvectors of the matrix A corresponding to the
!!        selected eigenvalues, with the i-th column of A containing the
!!        eigenvector associated with the eigenvalue in W(i) . If an
!!        eigenvector fails to converge, then that column of A contains the
!!        latest approximation to the eigenvector and the index of the
!!        eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!        = "N": Computes eigenvalues only;
!!        = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1 <= IL <= IU <= size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU-IL+1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the eigenvectors
!!        that failed to converge.
!!        Note: IFAIL must be absent if JOBZ = "N".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!        ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!        where <wp> is the working precision. If ABSTOL<= 0, then
!!        EPSILON(1.0_<wp>)*||T||1 will be used in its place, where ||T||1
!!        is the l1 norm of the tridiagonal matrix obtained by reducing A
!!        to tridiagonal form. Eigenvalues will be computed most accurately
!!        when ABSTOL is set to twice the underflow threshold
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with INFO > 0, then some
!!        eigenvectors did not converge. Try setting ABSTOL to
!!        2 * LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!        indices are stored in array IFAIL.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEEVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
   INTEGER :: N, LINFO, LD, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
              SIFAIL
   INTEGER, TARGET :: ISTAT1(1)
   REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LD = MAX(1,N); LINFO = 0; ISTAT = 0
   IF( PRESENT(JOBZ) )THEN; LJOBZ = JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(M)) M=0
   IF( PRESENT(IFAIL) )THEN
      SIFAIL = SIZE(IFAIL)
   ELSE
      SIFAIL = N
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
   IF( PRESENT(VL) )THEN
      LVL = VL
   ELSE
      LVL = -HUGE(LVL)
   ENDIF
   IF( PRESENT(VU) )THEN
      LVU = VU
   ELSE
      LVU = HUGE(LVU)
   ENDIF
   IF( PRESENT(IL) )THEN
      LIL = IL
   ELSE
      LIL = 1
   ENDIF
   IF( PRESENT(IU) )THEN
      LIU = IU
   ELSE
      LIU = N
   ENDIF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -2
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -4
   ELSE IF( LVU < LVL )THEN
      LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN
      LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N>0  )THEN
      LINFO = -7
   ELSE IF( N < LIU )THEN
      LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND.LSAME(LJOBZ,"N") )THEN
          LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN
         LRANGE = "V"
         LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN
         LRANGE = "I"
         LM = LIU-LIL+1
      ELSE
         LRANGE = "A"
         LM = N
      END IF
      IF ( LSAME(LJOBZ,"V") ) THEN
         LDZ = N
         LZ = LM
      ELSE
         LDZ = 1
         LZ = 1
      ENDIF
      IF( PRESENT(IFAIL) )THEN;
         LIFAIL => IFAIL
      ELSE
         LIFAIL => ISTAT1
      ENDIF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)
      ALLOCATE(IWORK(5*N),RWORK(7*N),Z(LDZ,LM), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, RWORK, Z, STAT=ISTAT1(1))
         ALLOCATE(IWORK(5*N), RWORK(7*N), Z(LDZ,LM), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
       LWORK = -1
       CALL HEEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
     &         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORKMIN, &
     &         LWORK, RWORK, IWORK, LIFAIL, LINFO )
       LWORK = WORKMIN(1)
       ALLOCATE (WORK(LWORK), STAT = ISTAT)
       IF  (ISTAT == 0) THEN
         IF( PRESENT(ABSTOL) )THEN
            LABSTOL = ABSTOL
         ELSE
            LABSTOL = 0.0_WP
         ENDIF
!!     .. CALL LAPACK77 ROUTINE
         CALL HEEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LD, LVL, LVU, &
                         LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
                         LWORK, RWORK, IWORK, LIFAIL, LINFO )
         IF( LSAME(LJOBZ,"V") ) A(1:LDZ,1:LM) = Z(1:LDZ,1:LM)
         IF( PRESENT(M) ) M = LM
         W(LM+1:N) = 0.0_WP
      END IF
      ENDIF
      DEALLOCATE(IWORK, Z, RWORK, STAT=ISTAT1(1))
      DEALLOCATE (WORK)
   END IF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE ZHEEVX_F95
SUBROUTINE ZHEGST_F95( A, B, ITYPE, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEGST_F77 => LA_HEGST                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(IN) :: B(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYGST / LA_HEGST reduces a real symmetric-definite or complex
!! Hermitian-definite generalized eigenproblem to standard form.
!
!! If ITYPE = 1, the problem is A*x = lambda*B*x,
!! and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)
!
!! If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
!! B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.
!
!! B must have been previously factorized as U**H*U or L*L**H
!! by LA_POTRF.
!
!! =======
!
!!    SUBROUTINE LA_SYGST / LA_HEGST( A, B, ITYPE, UPLO, INFO )
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       <type(<wp>), INTENT(IN) :: B(:,:)
!!       <type(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!       <type> ::= REAL | COMPLEX
!
!! Defaults
!! ========
!
!! 1. If ITYPE is not present then ITYPE = 1 is assumed.
!!
!! 2. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the transformed matrix, stored in the
!!            same format as A.
!
!! B       (input) either REAL or COMPLEX square array,
!!         shape (:,:), size(B,1) == size(A,1).
!!         The triangular factor from the Cholesky factorization of B,
!!         as returned by LA_POTRF.
!
!! ITYPE   Optional, (input) INTEGER
!!         If ITYPE is present then:
!!            = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
!!            = 2 or 3: compute U*A*U**H or L**H*A*L.
!!         otherwise ITYPE = 1 is assumed.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored and B is factored as
!!                    U**H*U;
!!            = "L":  Lower triangle of A is stored and B is factored as
!!                    L*L**H.
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SHEST"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LITYPE
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N )THEN; LINFO = -2
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. CALL LAPACK77 ROUTINE
      CALL HEGST_F77( LITYPE, LUPLO, N, A, LD, B, LD, LINFO )
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO)
END SUBROUTINE ZHEGST_F95
SUBROUTINE ZHEGV_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HEGV_F77 => LA_HEGV, ILAENV_F77 => ILAENV          !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEGV"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, LD, LITYPE, LRWORK,LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(ITYPE) )THEN
      LITYPE = ITYPE
   ELSE
      LITYPE = 1
   END IF
   IF( PRESENT(JOBZ) ) THEN
      LJOBZ = JOBZ
   ELSE
      LJOBZ = "N"
   END IF
   IF( PRESENT(UPLO) ) THEN
      LUPLO = UPLO
   ELSE
      LUPLO = "U"
   END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
      LINFO = -1
   ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
      LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN
      LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
      LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
      LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
      LINFO = -6
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB <= 1 .OR. NB >= N )THEN
         NB = 1
      ENDIF
      LWORK = N*(1+NB)
      LRWORK = MAX(1,3*N-2)
      ALLOCATE(RWORK(LRWORK), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(RWORK, WORK, STAT=ISTAT1)
         LWORK = N*2-1
         ALLOCATE(RWORK(LRWORK), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      ENDIF
      IF( LINFO == 0 .OR. LINFO <= -200 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEGV_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
                        WORK, LWORK, RWORK, LINFO )
      END IF
      DEALLOCATE(RWORK, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE ZHEGV_F95
SUBROUTINE ZHEGVD_F95( A, B, W, ITYPE, JOBZ, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: HEGVD_F77 => LA_HEGVD                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
      INTEGER, INTENT(IN), OPTIONAL :: ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!        LA_SYGV, LA_SYGVD, LA_HEGV and LA_HEGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems of
!! the form A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SYGV and LA_SYGVD
!! and complex Hermitian in the cases of LA_HEGV and LA_HEGVD. In all four
!! cases B is positive deffinite.
!!        LA_SYGVD and LA_HEGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SYGV and
!! LA_HEGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SYGV / LA_SYGVD / LA_HEGV / LA_HEGVD( A, B, &
!!                  W, ITYPE=itype, JOBZ=jobz, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A       (input/output) REAL or COMPLEX square array, shape (:,:).
!!         On entry, the matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of matrix A. If UPLO = "L", the lower
!!         triangular part of A contains the lower triangular part of
!!         matrix A.
!!         On exit, if JOBZ = "V", then the columns of A contain the
!!         eigenvectors, normalized as follows:
!!            if ITYPE = 1 or 2: Z^H*B*Z = I ,
!!            if ITYPE = 3: Z^H*B^-1*Z = I .
!!         If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!         lower triangle (if UPLO = "L") of A, including the diagonal,
!!         is destroyed.
!! B       (input/output) REAL or COMPLEX square array, shape (:,:) with
!!         size(B,1) = size(A,1).
!!         On entry, the matrix B. If UPLO = "U", the upper triangular
!!         part of B contains the upper triangular part of matrix B. If
!!         UPLO = "L", the lower triangular part of B contains the lower
!!         triangular part of matrix B.
!!         On exit, if the part of B containing the matrix is overwritten
!!         by the triangular factor U or L of the Cholesky factorization
!!         B = U^H*U or B = L*L^H , respectively.
!! W       (output) REAL array, shape (:) with size(W) = size(A,1).
!!         The eigenvalues in ascending order.
!! ITYPE   Optional (input) INTEGER.
!!         Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!         Default value: 1.
!! JOBZ    Optional (input) CHARACTER(LEN=1).
!!           = "N": Compute eigenvalues only;
!!           = "V": Compute eigenvalues and eigenvectors.
!!         Default value: "N".
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: the algorithm failed to converge or matrix B is not
!!         positive deffinite:
!!             <= n: if INFO = i, i off-diagonal elements of an
!!                   intermediate tridiagonal form did not converge to
!!                   zero.
!!             > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!                   of order i of B is not positive deffinite. The
!!                   factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HEGV"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO
      INTEGER :: LINFO, N, LD, LITYPE, LWORK, ISTAT, ISTAT1, LIWORK, &
     &         LRWORK
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), POINTER :: WORK(:)
      INTEGER, POINTER :: IWORK(:)
      COMPLEX(WP) :: WORKMIN(1)
      INTEGER :: IWORKMIN(1)
       REAL(WP), POINTER :: RWORK(:)
       REAL(WP) :: RWORKMIN(1)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
      IF( PRESENT(ITYPE) )THEN
        LITYPE = ITYPE
      ELSE
        LITYPE = 1
      END IF
      IF( PRESENT(JOBZ) ) THEN
        LJOBZ = JOBZ
      ELSE
        LJOBZ = "N"
      END IF
      IF( PRESENT(UPLO) ) THEN
        LUPLO = UPLO
      ELSE
        LUPLO = "U"
      END IF
!!  .. TEST THE ARGUMENTS ..
      IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN
        LINFO = -1
      ELSE IF( SIZE( B, 1 ) /= N .OR. SIZE( B, 2 ) /= N  )THEN
        LINFO = -2
      ELSE IF( SIZE( W ) /= N )THEN
        LINFO = -3
      ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN
        LINFO = -4
      ELSE IF( .NOT.LSAME(LJOBZ,"N") .AND. .NOT.LSAME(LJOBZ,"V") )THEN
        LINFO = -5
      ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN
        LINFO = -6
      ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE ..
!!  .. QUERING THE SIZE OF WORKSPACE ..
         LIWORK = -1
         LRWORK = -1
         LWORK = -1

         CALL HEGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, LIWORK, LINFO )

         LWORK = WORKMIN(1)
         LRWORK = RWORKMIN(1)
         LIWORK = IWORKMIN(1)

         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF (ISTAT == 0) THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HEGVD_F77( LITYPE, LJOBZ, LUPLO, N, A, LD, B, LD, W, &
     &      WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
           LINFO = -100
         END IF
         DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
      ENDIF
      CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE ZHEGVD_F95
SUBROUTINE ZHEGVX_F95( A, B, W, ITYPE, JOBZ, UPLO, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HEGVX_F77 => LA_HEGVX, ILAENV_F77 => ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYGVX and LA_HEGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!      A*z = lambda*B*z, A*B*z = lambda*z,  and  B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SYGVX and complex
!! Hermitian in the case of LA_HEGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SYGVX / LA_HEGVX (A, B, W, ITYPE= itype, &
!!             JOBZ= jobz, UPLO= uplo, VL= vl, VU= vu, IL= il, &
!!             IU= iu, M= m, IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!          <type>(<wp>), INTENT(INOUT) :: A(:,:), B(:,:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: JOBZ, UPLO
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the
!!        upper triangular part of matrix A. If UPLO = "L", the lower
!!        triangular part of A contains the lower triangular part of
!!        matrix A.
!!        On exit, if JOBZ = "V", the first M columns of A contain the
!!        orthonormal eigenvectors corresponding to the selected
!!        eigenvalues, with the i-th column of A holding the eigenvector
!!        associated with the eigenvalue in W(i).
!!        The eigenvectors are normalized as follows:
!!          if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!          if ITYPE = 3: Z^H * B^-1 * Z = I .
!!        If an eigenvector fails to converge, then that column of A
!!        contains the latest approximation to the eigenvector and the
!!        index of the eigenvector is returned in IFAIL.
!!        If JOBZ = "N", then the upper triangle (if UPLO = "U") or the
!!        lower triangle (if UPLO = "L") of A, including the diagonal, is
!!        destroyed.
!! B      (input/output) REAL or COMPLEX square array, shape (:,:) with
!!        size(B,1) = size(A,1).
!!        On entry, the matrix B.
!!        If UPLO = "U", the upper triangular part of B contains the
!!        upper triangular part of matrix B. If UPLO = "L", the lower
!!        triangular part of B contains the lower triangular part of
!!        matrix B.
!!        On exit, the part of B containing the matrix is overwritten by
!!        the triangular factor U or L of the Cholesky factorization
!!              B = U^H*U or B = L*L^H.
!! W      (output) REAL array, shape (:) with size(W) = size(A,1).
!!        The first M elements contain the selected eigenvalues in
!!        ascending order.
!! ITYPE  Optional (input) INTEGER.
!!        Specifies the problem type to be solved:
!!           = 1: A*z = lambda*B*z
!!           = 2: A*B*z = lambda*z
!!           = 3: B*A*z = lambda*z
!!        Default value: 1.
!! JOBZ   Optional (input) CHARACTER(LEN=1).
!!           = "N": Computes eigenvalues only;
!!           = "V": Computes eigenvalues and eigenvectors.
!!        Default value: "N".
!! UPLO   Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangles of A and B are stored;
!!           = "L": Lower triangles of A and B are stored.
!!        Default value: "U".
!! VL,VU  Optional (input) REAL.
!!        The lower and upper bounds of the interval to be searched for
!!        eigenvalues. VL < VU.
!!        Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!        <wp> ::= KIND(1.0) | KIND(1.0D0).
!!        Note: Neither VL nor VU may be present if IL and/or IU is
!!        present.
!! IL,IU  Optional (input) INTEGER.
!!        The indices of the smallest and largest eigenvalues to be
!!        returned. The IL-th through IU-th eigenvalues will be found.
!!        1<=IL<=IU<=size(A,1).
!!        Default values: IL = 1 and IU = size(A,1).
!!        Note: Neither IL nor IU may be present if VL and/or VU is
!!        present.
!!        Note: All eigenvalues are calculated if none of the arguments
!!        VL, VU, IL and IU are present.
!! M      Optional (output) INTEGER.
!!        The total number of eigenvalues found. 0 <= M <= size(A,1).
!!        Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL  Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!        size(A,1).
!!        If INFO = 0, the first M elements of IFAIL are zero.
!!        If INFO > 0, then IFAIL contains the indices of the
!!        eigenvectors that failed to converge.
!!        Note: IFAIL should be present if JOBZ = "V".
!! ABSTOL Optional (input) REAL.
!!        The absolute error tolerance for the eigenvalues. An approximate
!!        eigenvalue is accepted as converged when it is determined to lie
!!        in an interval [a,b] of width less than or equal to
!!             ABSTOL + EPSILON(1.0_<wp>) * max(| a |, | b |),
!!        where <wp> is the working precision. If ABSTOL <= 0, then
!!        EPSILON(1.0_<wp>)* ||T||1 will be used in its place, where
!!        ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!        reducing the generalized eigenvalue problem to tridiagonal form.
!!        Eigenvalues will be computed most accurately when ABSTOL is set
!!        to twice the underflow threshold 2 * LA_LAMCH(1.0_<wp>, "S"),
!!        not zero.
!!        Default value: 0.0_<wp>.
!!        Note: If this routine returns with 0 < INFO <= n, then some
!!        eigenvectors did not converge.
!!        Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: the algorithm failed to converge or matrix B is not
!!        positive definite:
!!           <= n: the algorithm failed to converge; if INFO = i, then i
!!             eigenvectors failed to converge. Their indices are stored
!!             in array IFAIL.
!!           > n: if INFO = n+i, for 1 <= i <= n, then the leading minor
!!             of order i of B is not positive definite. The
!!             factorization of B could not be completed and no
!!             eigenvalues or eigenvectors were computed.
!!         n is the order of A.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
       CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HEGVX"
       CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
      INTEGER :: N, LINFO, LDA, LDZ, LZ, LIL, LIU, LM, LWORK, NB, ISTAT, &
      &     SIFAIL, LDB, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      REAL(WP) :: LABSTOL, LVL, LVU
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:), Z(:,:)
      REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   N = SIZE(A,1); LDA = MAX(1,N); LDB=MAX(1,SIZE(B,1)); LINFO = 0; ISTAT = 0
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL);ELSE; SIFAIL = N; END IF
   IF( PRESENT(JOBZ ) )THEN; LJOBZ=JOBZ; ELSE; LJOBZ = "N"; ENDIF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN;  LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN ; LRANGE = "V"; LM=N
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN ; LRANGE = "I"; LM=LIU-LIL+1
   ELSE ; LRANGE = "A"; LM=N; END IF
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF (SIZE (B, 2) /= N ) THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN;  LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LJOBZ,"V") .AND. .NOT.LSAME(LJOBZ,"N") )THEN; LINFO = -5
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN ; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
            (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE, "I") .AND. ( LIU < MIN( N, LIL ) .OR. LIU>N))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN

    IF(LSAME(LJOBZ, "V")) THEN
       LDZ = MAX(1,N); LZ=LM
    ELSE
       LDZ = 1; LZ=1
    ENDIF
    IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
    ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
!!     .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB < 5 .OR. NB >= N )THEN
         NB = 5
      END IF
      LWORK = N*(3+NB)

      ALLOCATE(Z(LDZ, LZ), STAT=ISTAT)
      IF (ISTAT /= 0) LINFO = -100

      ALLOCATE(IWORK(10*5*N), WORK(10*LWORK), RWORK(7*N), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN
         DEALLOCATE(IWORK, WORK, STAT=ISTAT1(1))
         LWORK = N*8*10
         ALLOCATE(IWORK(10*5*N), WORK(LWORK), RWORK(7 *N), STAT=ISTAT)
         IF( ISTAT /= 0 ) THEN
            LINFO = - 100
         ELSE
            CALL ERINFO( -200, SRNAME, LINFO )
         ENDIF
      END IF
      IF( LINFO == 0 )THEN
         IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
         ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum");  ENDIF
!!     .. CALL LAPACK77 ROUTINE
            CALL HEGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, A, LDA, B, &
     &         LDB, LVL, LVU, LIL, LIU, LABSTOL, LM, W, Z, LDZ, WORK, &
     &         LWORK, RWORK, IWORK, LIFAIL, LINFO )

         IF( PRESENT(M) ) M = LM
         IF (LSAME(LJOBZ,"V"))  A(1:LDZ, 1:LM)=Z(1:LDZ, 1:LM)
      END IF
      DEALLOCATE(IWORK, WORK, RWORK, STAT=ISTAT1(1))
      DEALLOCATE(Z, STAT=ISTAT)
      END IF
      CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHEGVX_F95
 SUBROUTINE ZHESV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HESV_F77 => LA_HESV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HESV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL HESV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZHESV1_F95
 SUBROUTINE ZHESV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HESV_F77 => LA_HESV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HESV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL HESV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZHESV_F95
SUBROUTINE ZHESVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HESVX_F77 => LA_HESVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HESVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,2*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HESVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZHESVX1_F95
SUBROUTINE ZHESVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HESVX_F77 => LA_HESVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HESVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HESVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZHESVX_F95
SUBROUTINE ZHETRD_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HETRD_F77 => LA_HETRD, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
   COMPLEX(WP), INTENT(OUT) :: TAU(:)
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HETRD"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZHETRD"
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_SYTRD / LA_HETRD reduces a real symmetric or complex Hermitian
!! matrix A to real symmetric tridiagonal form T by an orthogonal
!! or unitary similarity transformation:
!! Q**H * A * Q = T.
!
!! =======
!
!!    SUBROUTINE LA_HETRD / LA_SYTRD|( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       <type>(<wp>), INTENT(OUT) :: TAU(:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A.
!!         On exit:
!!            If UPLO = "U", the diagonal and first superdiagonal
!!               of A are overwritten by the corresponding elements of the
!!               tridiagonal matrix T, and the elements above the first
!!               superdiagonal, with the array TAU, represent the unitary
!!               matrix Q as a product of elementary reflectors.
!!            If UPLO = "L", the diagonal and first subdiagonal of A are
!!               overwritten by the corresponding elements of the tridiagonal
!!               matrix T, and the elements below the first subdiagonal, with
!!               the array TAU, represent the unitary matrix Q as a product
!!               of elementary reflectors.
!!            See Further Details.
!
!! TAU     (output) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         The scalar factors of the elementary reflectors.
!!         See Further Details.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! Further Details
!! ===============
!
!! If UPLO = "U", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(n-1) . . . H(2) H(1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!! A(1:i-1,i+1), and tau in TAU(i).
!
!! If UPLO = "L", the matrix Q is represented as a product of elementary
!! reflectors
!
!!    Q = H(1) H(2) . . . H(n-1).
!
!! Each H(i) has the form
!
!!    H(i) = I - tau * v * v"
!
!! where tau is a complex scalar, and v is a complex vector with
!! v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!! and tau in TAU(i).
!
!! The contents of A on exit are illustrated by the following examples
!! with n = 5:
!
!! if UPLO = "U":                       if UPLO = "L":
!
!!   (  d   e   v2  v3  v4 )              (  d                  )
!!   (      d   e   v3  v4 )              (  e   d              )
!!   (          d   e   v4 )              (  v1  e   d          )
!!   (              d   e  )              (  v1  v2  e   d      )
!!   (                  d  )              (  v1  v2  v3  e   d  )
!
!! where d and e denote diagonal and off-diagonal elements of T, and vi
!! denotes an element of the vector defining H(i).
!
!! --------------------------------------
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   INTEGER :: LINFO, N, LD, LWORK, NB, ISTAT, ISTAT1
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: D(:), E(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
      IF( NB > 1 .AND. NB < N )THEN; LWORK = N*NB; ELSE; LWORK = 1; ENDIF
      ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(D, E, WORK, STAT=ISTAT1)
         LWORK = 1; ALLOCATE(D(N), E(N-1), WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HETRD_F77( LUPLO, N, A, LD, D, E, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(D, E, WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHETRD_F95
SUBROUTINE ZHPEV_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPEV_F77 => LA_HPEV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPEV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
      ALLOCATE(WORK(MAX(1,2*N-1)), RWORK(MAX(1,3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 ) THEN
         IF( PRESENT(Z) )THEN
   !!     .. CALL LAPACK77 ROUTINE
          CALL HPEV_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, RWORK, LINFO )
         ELSE
          CALL HPEV_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, RWORK, LINFO )
         ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPEV_F95
SUBROUTINE ZHPEVD_F95( A, W, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPEVD_F77 => LA_HPEVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPEV and LA_SPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a real symmetric matrix A in packed storage.
!!     LA_HPEV and LA_HPEVD compute all eigenvalues and, optionally, all
!! eigenvectors of a complex Hermitian matrix A in packed storage.
!!     LA_SPEVD and LA_HPEVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPEV and
!! LA_HPEV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPEV / LA_HPEV / LA_SPEVD / LA_HPEVD( AP, W, &
!!                     UPLO=uplo, Z=z, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:)
!!           REAL(<wp>), INTENT(OUT) :: W(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!         n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!         if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!         On exit, AP is overwritten by values generated during the
!!         reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!         diagonal and first superdiagonal of T overwrite the correspond-
!!         ing diagonals of A. If UPLO = "L", the diagonal and first
!!         subdiagonal of T overwrite the corresponding diagonals of A.
!! W       (output) REAL array, shape (:) with size(W) = n.
!!         The eigenvalues in ascending order.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! Z       Optional (output) REAL or COMPLEX square array, shape (:,:)
!!         with size(Z,1) = n.
!!         The columns of Z contain the orthonormal eigenvectors of A in
!!         the order of the eigenvalues.
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value
!!         > 0: if INFO = i, then i off-diagonal elements of an
!!         intermediate tridiagonal form did not converge to zero.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPEVD"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO, LJOBZ
   INTEGER :: N, NN, LINFO, LD, ISTAT, ISTAT1, S1Z, S2Z, LWORK, LRWORK, LIWORK, LGN
   INTEGER, SAVE :: LWORKN = 0, LIWORKN = 0, LWORKV = 0, LIWORKV = 0, &
                    LRWORKN = 0, LRWORKV = 0
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   INTEGER, POINTER :: IWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( N > 0 )THEN
!!  .. DETERMINE THE WORKSPACE
         LGN = 1+INT( LOG(REAL(N,WP))/LOG(REAL(2,WP)) )
         IF( LSAME(LJOBZ,"N") )THEN
            LWORK = MAX( 1, N, LWORKN ); LIWORK = MAX( 1, LIWORKN )
            LRWORK = MAX( 1, N, LRWORKN )
         ELSE
            LWORK = MAX( 1, 2*N, LWORKV )
            LRWORK = MAX( 1+ 5*N+2*N**2, LWORKV )
            LIWORK = MAX( 3+5*N, LIWORKV )
         END IF

      ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
      IF( ISTAT /= 0 ) THEN
         DEALLOCATE( WORK, RWORK, IWORK, STAT=ISTAT1 )
         IF( LSAME(LJOBZ,"N") )THEN; LWORK = MAX( 1, 2*N )
            LRWORK = MAX(1, 2*N ); LIWORK = 1
         ELSE; LWORK = MAX( 1, 2*N ); LIWORK = 2+5*N
            LWORK = 1+ 4*N+2*N*LGN+3*N**2; END IF
         ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      END IF
      IF( ISTAT == 0 ) THEN
        IF( PRESENT(Z) )THEN
           CALL HPEVD_F77( LJOBZ, LUPLO, N, A, W, Z, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ELSE
           CALL HPEVD_F77( LJOBZ, LUPLO, N, A, W, LLZ, S2Z, WORK, LWORK, &
                         RWORK, LRWORK, IWORK, LIWORK, LINFO )
         ENDIF

         IF (LINFO == 0 ) THEN
            IF (LSAME(LJOBZ,"N")) THEN; LWORKN = INT(WORK(1)+1)
               LRWORKN = INT(RWORK(1)+1); LIWORKN = IWORK(1)
            ELSE; LWORKV = INT(WORK(1)); LRWORKV = INT(RWORK(1)+1);
               LIWORKV = IWORK(1); END IF
         END IF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPEVD_F95
SUBROUTINE ZHPEVX_F95( A, W, UPLO, Z, VL, VU, IL, IU, &
                       M, IFAIL, ABSTOL, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                                !!((07-B-INT_LAPACK1.f90))
   use INT_LAPACK1, ONLY: HPEVX_F77 => LA_HPEVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(IN), OPTIONAL :: IL, IU
   INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
   REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
   COMPLEX(WP), INTENT(INOUT) :: A(:)
   REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SPEVX / LA_HPEVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of a real symmetric/complex hermitian
!! matrix A in packed storage. Eigenvalues and eigenvectors can be
!! selected by specifying either a range of values or a range of indices
!! for the desired eigenvalues.
!!
!! =========
!!
!!        SUBROUTINE LA_SPEVX / LA_HPEVX( AP, W, UPLO=uplo, Z=z, &
!!                 VL=vl, VU=vu, IL=il, IU=iu, M=m, IFAIL=ifail, &
!!                 ABSTOL=abstol, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:)
!!          REAL(<wp>), INTENT(OUT) :: W(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!          INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!          INTEGER, INTENT(OUT), OPTIONAL :: M
!!          INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!          REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!          <type> ::= REAL | COMPLEX
!!          <wp> ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!!  AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n+1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i+(j-1)*j/2)=A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i+(j-1)*(2*n-j)/2)=A(i,j) for 1<=j<=i<=n.
!!          On exit, AP is overwritten by values generated during the
!!          reduction of A to a tridiagonal matrix T . If UPLO = "U", the
!!          diagonal and first superdiagonal of T overwrite the correspond-
!!          ing diagonals of A. If UPLO = "L", the diagonal and first
!!          subdiagonal of T overwrite the corresponding diagonals of A.
!!  W       (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!!  UPLO    Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX array, shape (:,:) with
!!          size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors of
!!          the matrix A corresponding to the selected eigenvalues, with the
!!          i-th column of Z containing the eigenvector associated with
!!          the eigenvalue in W(i) . If an eigenvector fails to converge,
!!          then that column of Z contains the latest approximation to the
!!          eigenvector, and the index of the eigenvector is returned in
!!          IFAIL.
!!          Note: The USEr must ensure that at least M columns are supplied
!!          in the array Z. When the exact value of M is not known in
!!          advance, an upper bound must be used. In all cases M <= n.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th
!!          eigenvalues will be found. 1<=IL<=IU<=size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0<=M<=size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with
!!          size(IFAIL) = n.
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to ABSTOL+EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL<=0, then
!!          EPSILON(1.0_<wp>)*||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing A to tridiagonal form. Eigenvalues will be computed
!!          most accurately when ABSTOL is set to twice the underflow
!!          threshold 2*LA_LAMCH(1.0_<wp>, "Safe minimum"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with INFO > 0, then some
!!          eigenvectors did not converge. Try setting ABSTOL to
!!          2*LA_LAMCH(1.0_<wp>, "Safe minimum").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, then i eigenvectors failed to converge. Their
!!          indices are stored in array IFAIL.
!!          If INFO is not present and an error occurs, then the program is
!!          terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPEVX"
   CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
   INTEGER :: N, LINFO, LD, LIL, LIU, LM, ISTAT, &
              SIFAIL, S1Z, S2Z, NN
   INTEGER, TARGET :: ISTAT1(1)
   COMPLEX(WP), TARGET :: LLZ(1,1)
   REAL(WP) :: LABSTOL, LVL, LVU
   COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
   INTEGER, POINTER :: IWORK(:), LIFAIL(:)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -4
   ELSE IF( LVU < LVL )THEN; LINFO = -5
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &      (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -6
   ELSE IF(( LIU < LIL .OR. LIL < 1) .AND. N > 0 )THEN; LINFO = -7
   ELSE IF( N < LIU )THEN; LINFO = -8
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -10
   ELSE IF( N > 0 )THEN
      IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"; LM = N
      ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"; LM = LIU-LIL+1
      ELSE; LRANGE = "A"; LM = N; END IF
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
         IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
         ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
      ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
      IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), RWORK(MAX(1,7*N)), WORK(MAX(1,2*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
            IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
            ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
            IF (PRESENT (Z)) THEN
                CALL HPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                       LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, &
     &                       RWORK, IWORK, LIFAIL, LINFO )
            ELSE
               CALL HPEVX_F77( LJOBZ, LRANGE, LUPLO, N, A, LVL, LVU, &
     &                       LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, &
     &                       RWORK, IWORK, LIFAIL, LINFO )
            ENDIF
            IF( PRESENT(M) ) M = LM
            W(LM+1:N) = 0.0_WP
         ELSE; LINFO = -100; END IF
      END IF
      IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
      DEALLOCATE(IWORK, RWORK, WORK, STAT=ISTAT1(1))
   END IF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPEVX_F95
SUBROUTINE ZHPGV_F95( A, B, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPGV_F77 => LA_HPGV                                !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPGV"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LJOBZ, LUPLO
   INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, ISTAT1, S1Z, S2Z
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), TARGET :: LLZ(1,1)
   COMPLEX(WP), POINTER :: WORK(:)
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP) :: WW
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
   ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= SIZE(A)  )THEN; LINFO = -2
   ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
   ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( N > 0 )THEN
      ALLOCATE(WORK(MAX(1,2*N-1)), RWORK(MAX(1, 3*N-2)), STAT=ISTAT)
      IF( ISTAT == 0 )THEN
         IF( PRESENT(Z) )THEN
           CALL HPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, Z, S1Z, &
                         WORK, RWORK, LINFO )
        ELSE
           CALL HPGV_F77( LITYPE, LJOBZ, LUPLO, N, A, B, W, LLZ, S1Z, &
                        WORK, RWORK, LINFO )
        ENDIF
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPGV_F95
SUBROUTINE ZHPGVD_F95( AP, BP, W, ITYPE, UPLO, Z, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPGVD_F77 => LA_HPGVD                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
   INTEGER, INTENT(IN), OPTIONAL :: ITYPE
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: AP(:), BP(:)
   REAL(WP), INTENT(OUT) :: W(:)
   COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPGV, LA_SPGVD, LA_HPGV and LA_HPGVD compute all eigenvalues
!! and, optionally, all eigenvectors of generalized eigenvalue problems
!! of the form A*z = lambda*B*z, A*B*z = lambda*z; and B*A*z = lambda*z,
!! where A and B are real symmetric in the cases of LA_SPGV and LA_SPGVD
!! and complex Hermitian in the cases of LA_HPGV and LA_HPGVD. In all
!! four cases B is positive definite. Matrices A and B are stored in a
!! packed format.
!!     LA_SPGVD and LA_HPGVD use a divide and conquer algorithm. If
!! eigenvectors are desired, they can be much faster than LA_SPGV and
!! LA_HPGV for large matrices but use more workspace.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGV / LA_SPGVD / LA_HPGV / LA_HPGVD( AP, BP, &
!!                         W, ITYPE=itype, UPLO=uplo, Z=z, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!            REAL(<wp>), INTENT(OUT) :: W(:)
!!            INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) and
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^H*U or B = L*L^H, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX square array, shape (:,:)
!!          with size(Z,1) = n.
!!          The matrix Z of eigenvectors, normalized as follows:
!!             if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!             if ITYPE = 3: Z^H * B^-1 * Z = I .
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: the algorithm failed to converge or matrix B is not
!!             positive definite:
!!              <= n: if INFO = i, i off-diagonal elements of an
!!                 intermediate tridiagonal form did not converge to
!!                 zero.
!!              > n: if INFO = n+i, for 1<=i<=n, then the leading minor
!!                 of order i of B is not positive definite. The
!!                 factorization of B could not be completed and no
!!                   eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPGVD"
!!  .. LOCAL SCALARS ..
      CHARACTER(LEN=1) ::  LJOBZ, LUPLO
      INTEGER :: LINFO, N, NN, LD, LITYPE, ISTAT, S1Z, S2Z
      INTEGER :: LWORK, LIWORK, LRWORK
!!  .. LOCAL ARRAYS ..
      COMPLEX(WP), TARGET :: LLZ(1,1), WORKMIN(1)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
      REAL(WP):: RWORKMIN(1)
      INTEGER :: IWORKMIN(1)
      COMPLEX(WP) :: WW
      INTEGER, POINTER :: IWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC SIZE, MAX, PRESENT
!!  .. EXECUTABLE STATEMENTS ..
      LINFO = 0; ISTAT = 0; NN = SIZE(AP)
      WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW);  LD = MAX(1,N)
      IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
        IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2); LJOBZ = "V"
        ELSE; S1Z = 1; S2Z = 1; LJOBZ = "N"; END IF
          IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
            IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
            ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
            ELSE IF( SIZE(W) /= N )THEN; LINFO = -3
            ELSE IF( LITYPE < 1 .OR. LITYPE > 3 )THEN; LINFO = -4
            ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
            ELSE IF( PRESENT(Z) .AND. ( S1Z /= LD .OR. S2Z /= N ) )THEN; LINFO = -6
            ELSE IF( N > 0 )THEN
!!  QUERING THE SIZE OF WORKSPACE ...
                LWORK = -1
                LRWORK = -1
                LIWORK = -1
                IF (PRESENT (Z)) THEN
                  CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &               Z, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, &
     &               LIWORK, LINFO )
                ELSE
                  CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &               LLZ, S1Z, WORKMIN, LWORK, RWORKMIN, LRWORK, IWORKMIN, &
     &               LIWORK, LINFO )
                ENDIF

                LWORK = WORKMIN(1)
                LRWORK = RWORKMIN(1)
                LIWORK= IWORKMIN(1)

                ALLOCATE(WORK(LWORK), RWORK(LRWORK), IWORK(LIWORK), STAT=ISTAT)
                IF( ISTAT == 0 )THEN
                 IF (PRESENT(Z)) THEN
                    CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                Z, S1Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &
     &                LINFO )
                 ELSE
                     CALL HPGVD_F77( LITYPE, LJOBZ, LUPLO, N, AP, BP, W, &
     &                LLZ, S1Z, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &
     &                LINFO )
                 ENDIF
                ELSE; LINFO = -100; ENDIF
                ENDIF
                DEALLOCATE(WORK, RWORK, IWORK, STAT=ISTAT)
                CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPGVD_F95


SUBROUTINE ZHPGVX_F95( AP, BP, W, ITYPE, UPLO, Z, VL, VU, IL, IU, &
     &  M, IFAIL, ABSTOL, INFO )
!!  .. use STATEMENTS ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAMCH_F77 => DLAMCH                             !!((07-B-INT_LAPACK1.f90))
      use INT_LAPACK1, ONLY: HPGVX_F77 => LA_HPGVX                           !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
      IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
      INTEGER, INTENT(IN), OPTIONAL :: IL, IU, ITYPE
      INTEGER, INTENT(OUT), OPTIONAL :: INFO, M
      REAL(WP), INTENT(IN), OPTIONAL :: ABSTOL, VL, VU
!!  .. ARRAY ARGUMENTS ..
      INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IFAIL(:)
      COMPLEX(WP), INTENT(OUT), OPTIONAL, TARGET :: Z(:,:)
      COMPLEX(WP), INTENT(INOUT) :: AP(:), BP(:)
      REAL(WP), INTENT(OUT) :: W(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPGVX and LA_HPGVX compute selected eigenvalues and, optionally,
!! the corresponding eigenvectors of generalized eigenvalue problems of
!! the form
!!       A*z = lambda*B*z, A*B*z = lambda*z, and B*A*z = lambda*z,
!! where A and B are real symmetric in the case of LA_SPGVX and complex
!! Hermitian in the case of LA_HPGVX. In both cases B is positive
!! definite. Eigenvalues and eigenvectors can be selected by specifying
!! either a range of values or a range of indices for the desired
!! eigenvalues. Matrices A and B are stored in a packed format.
!!
!! =========
!!
!!       SUBROUTINE LA_SPGVX / LA_HPGVX( AP, BP, W, ITYPE= itype, &
!!             UPLO= uplo, Z= z, VL= vl, VU= vu, IL= il, IU= iu, M= m, &
!!             IFAIL= ifail, ABSTOL= abstol, INFO= info )
!!         <type>(<wp>), INTENT(INOUT) :: AP(:), BP(:)
!!         REAL(<wp>), INTENT(OUT) :: W(:)
!!         INTEGER, INTENT(IN), OPTIONAL :: ITYPE
!!         CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!         <type>(<wp>), INTENT(OUT), OPTIONAL :: Z(:,:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: VL, VU
!!         INTEGER, INTENT(IN), OPTIONAL :: IL, IU
!!         INTEGER, INTENT(OUT), OPTIONAL :: M
!!         INTEGER, INTENT(OUT), OPTIONAL :: IFAIL(:)
!!         REAL(<wp>), INTENT(IN), OPTIONAL :: ABSTOL
!!         INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!         <type> ::= REAL | COMPLEX
!!         <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(AP) = n*(n + 1)/2, where n is the order of A and B.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i +(j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i +(j-1)*(2*n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the contents of AP are destroyed.
!! BP       (input/output) REAL or COMPLEX array, shape (:) with
!!          size(BP) = size(AP).
!!          On entry, the upper or lower triangle of matrix B in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", BP(i +(j-1)*j/2) = B(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", BP(i +(j-1)*(2*n-j)/2) = B(i,j) for 1<=j<=i<=n.
!!          On exit, the triangular factor U or L of the Cholesky
!!          factorization B = U^T*U or B = L*L^T, in the same storage
!!          format as B.
!! W        (output) REAL array, shape (:) with size(W) = n.
!!          The eigenvalues in ascending order.
!! ITYPE    Optional (input) INTEGER.
!!          Specifies the problem type to be solved:
!!             = 1: A*z = lambda*B*z
!!             = 2: A*B*z = lambda*z
!!             = 3: B*A*z = lambda*z
!!          Default value: 1.
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!             = "U": Upper triangles of A and B are stored;
!!             = "L": Lower triangles of A and B are stored.
!!          Default value: "U".
!! Z        Optional (output) REAL or COMPLEX rectangular array, shape
!!          (:,:) with size(Z,1) = n and size(Z,2) = M.
!!          The first M columns of Z contain the orthonormal eigenvectors
!!          corresponding to the selected eigenvalues, with the i-th
!!          column of Z holding the eigenvector associated with the
!!          eigenvalue in W(i). The eigenvectors are normalized as
!!          follows:
!!            if ITYPE = 1 or 2: Z^H * B * Z = I ,
!!            if ITYPE = 3: Z^H * B^-1 * Z = I .
!!          If an eigenvector fails to converge, then that column of Z
!!          contains the latest approximation to the eigenvector and the
!!          index of the eigenvector is returned in IFAIL.
!! VL,VU    Optional (input) REAL.
!!          The lower and upper bounds of the interval to be searched for
!!          eigenvalues. VL < VU.
!!          Default values: VL = -HUGE(<wp>) and VU = HUGE(<wp>), where
!!          <wp> ::= KIND(1.0) | KIND(1.0D0).
!!          Note: Neither VL nor VU may be present if IL and/or IU is
!!          present.
!! IL,IU    Optional (input) INTEGER.
!!          The indices of the smallest and largest eigenvalues to be
!!          returned. The IL-th through IU-th eigenvalues will be found.
!!          1 <= IL <= IU <= size(A,1).
!!          Default values: IL = 1 and IU = size(A,1).
!!          Note: Neither IL nor IU may be present if VL and/or VU is
!!          present.
!!          Note: All eigenvalues are calculated if none of the arguments
!!          VL, VU, IL and IU are present.
!! M        Optional (output) INTEGER.
!!          The total number of eigenvalues found. 0 <= M <= size(A,1).
!!          Note: If IL and IU are present then M = IU - IL + 1.
!! IFAIL    Optional (output) INTEGER array, shape (:) with size(IFAIL) =
!!          size(A,1).
!!          If INFO = 0, the first M elements of IFAIL are zero.
!!          If INFO > 0, then IFAIL contains the indices of the
!!          eigenvectors that failed to converge.
!!          Note: If Z is present then IFAIL should also be present.
!! ABSTOL   Optional (input) REAL.
!!          The absolute error tolerance for the eigenvalues. An
!!          approximate eigenvalue is accepted as converged when it is
!!          determined to lie in an interval [a,b] of width less than or
!!          equal to
!!              ABSTOL + EPSILON(1.0_<wp>) * max(|a|,|b|),
!!          where <wp> is the working precision. If ABSTOL <= 0, then
!!          EPSILON(1.0_<wp>) * ||T||1 will be used in its place, where
!!          ||T||1 is the l1 norm of the tridiagonal matrix obtained by
!!          reducing the generalized eigenvalue problem to tridiagonal
!!          form. Eigenvalues will be computed most accurately when
!!          ABSTOL is set to twice the underflow threshold
!!          2 * LA_LAMCH(1.0_<wp>, "S"), not zero.
!!          Default value: 0.0_<wp>.
!!          Note: If this routine returns with 0 < INFO <= n, then some
!!          eigenvectors did not converge.
!!          Try setting ABSTOL to 2 * LA_LAMCH(1.0_<wp>, "S").
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!          > 0: the algorithm failed to converge or matrix B is not
!!            positive definite:
!!             <= n: the algorithm failed to converge; if INFO = i, then
!!              i eigenvectors failed to converge. Their indices are
!!              stored in array IFAIL.
!!             > n: if INFO = n + i, for 1 <= i <= n, then the leading
!!              minor of order i of B is not positive definite. The
!!              factorization of B could not be completed and no
!!                eigenvalues or eigenvectors were computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. LOCAL PARAMETERS ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPGVX"
      CHARACTER(LEN=1) :: LJOBZ, LUPLO, LRANGE
!!  .. LOCAL SCALARS ..
      INTEGER :: N, LINFO, LIL, LIU, LM, ISTAT, &
     &  SIFAIL, S1Z, S2Z, NN, LITYPE
      INTEGER, TARGET :: ISTAT1(1)
      COMPLEX(WP), TARGET :: LLZ(1,1)
      REAL(WP) :: LABSTOL, LVL, LVU
      COMPLEX(WP) :: WW
!!  .. LOCAL ARRAYS ..
      INTEGER, POINTER :: IWORK(:), LIFAIL(:)
      COMPLEX(WP), POINTER :: WORK(:)
      REAL(WP), POINTER :: RWORK(:)
!!  .. INTRINSIC FUNCTIONS ..
      INTRINSIC HUGE, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(AP)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(ITYPE) )THEN; LITYPE = ITYPE; ELSE; LITYPE = 1; END IF
   IF( PRESENT(IFAIL) )THEN; SIFAIL = SIZE(IFAIL); ELSE; SIFAIL = N; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(VL) )THEN; LVL = VL; ELSE; LVL = -HUGE(LVL); ENDIF
   IF( PRESENT(VU) )THEN; LVU = VU; ELSE; LVU = HUGE(LVU); ENDIF
   IF( PRESENT(IL) )THEN; LIL = IL; ELSE; LIL = 1; ENDIF
   IF( PRESENT(IU) )THEN; LIU = IU; ELSE; LIU = N; ENDIF
   IF( PRESENT(Z) )THEN; S1Z = SIZE(Z,1); S2Z = SIZE(Z,2)
    ELSE; S1Z = 1; S2Z = 1; ENDIF
!!  .. TEST THE ARGUMENTS
   IF( PRESENT(VL) .OR. PRESENT(VU) )THEN; LRANGE = "V"
   ELSE IF( PRESENT(IL) .OR. PRESENT(IU) )THEN; LRANGE = "I"
   ELSE ; LRANGE = "A"; END IF

   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(BP) /= SIZE(AP)  )THEN; LINFO = -2
   ELSE IF( SIZE( W ) /= N )THEN; LINFO = -3
   ELSE IF (LITYPE <1 .OR. LITYPE >3) THEN; LINFO = -4
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -5
   ELSE IF( PRESENT(Z) .AND. ( S1Z /= N .OR. S2Z /= N ) )THEN; LINFO = -6
   ELSE IF( LVU < LVL )THEN; LINFO = -7
   ELSE IF( (PRESENT(VL) .OR. PRESENT(VU)) .AND. &
     &  (PRESENT(IL) .OR. PRESENT(IU)) )THEN; LINFO = -8
   ELSE IF( LSAME(LRANGE,"I") .AND. ( LIU < MIN(N, LIL) .OR. LIU > N ))THEN; LINFO = -9
   ELSE IF( N < LIU )THEN; LINFO = -10
   ELSE IF( SIFAIL /= N .OR. PRESENT(IFAIL).AND..NOT.PRESENT(Z) )THEN; LINFO = -12
   ELSE IF( N > 0 )THEN
      IF( PRESENT(Z) ) THEN; LJOBZ = "V"
        IF( PRESENT(IFAIL) )THEN; LIFAIL => IFAIL
        ELSE; ALLOCATE( LIFAIL(N), STAT=ISTAT ); END IF
        ELSE; LJOBZ = "N"; LIFAIL => ISTAT1; ENDIF
!!     .. DETERMINE THE WORKSPACE
       IF( ISTAT == 0 ) THEN
         ALLOCATE(IWORK(MAX(1,5*N)), WORK(MAX(1,8*N)), RWORK(MAX(1,7*N)), STAT=ISTAT)
         IF( ISTAT == 0 )THEN
           IF( PRESENT(ABSTOL) )THEN; LABSTOL = ABSTOL
           ELSE; LABSTOL = 2*LAMCH_F77("Safe minimum"); ENDIF
             IF (PRESENT (Z)) THEN
                  CALL HPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &                   LVU, LIL, LIU, LABSTOL, LM, W, Z, S1Z, WORK, RWORK, IWORK, LIFAIL, &
     &                   LINFO )
             ELSE
                  CALL HPGVX_F77( LITYPE, LJOBZ, LRANGE, LUPLO, N, AP, BP, LVL, &
     &                   LVU, LIL, LIU, LABSTOL, LM, W, LLZ, S1Z, WORK, RWORK, IWORK, LIFAIL, &
     &                   LINFO )
             ENDIF
             IF( PRESENT(M) ) M = LM
           ELSE; LINFO = -100; END IF
           END IF
           IF( PRESENT(Z) .AND. .NOT.PRESENT(IFAIL) ) DEALLOCATE( LIFAIL, STAT=ISTAT1(1) )
           DEALLOCATE(IWORK, WORK, RWORK, STAT=ISTAT1(1))
         END IF
         CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZHPGVX_F95
 SUBROUTINE ZHPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HPSV_F77 => LA_HPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL HPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZHPSV1_F95
 SUBROUTINE ZHPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: HPSV_F77 => LA_HPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_HPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL HPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZHPSV_F95
SUBROUTINE ZHPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPSVX_F77 => LA_HPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZHPSVX1_F95
SUBROUTINE ZHPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: HPSVX_F77 => LA_HPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_HPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,2*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL HPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZHPSVX_F95
      SUBROUTINE ZLAGGE_F95( A, KL, KU, D, ISEED, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO                                        !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LAGGE_F77 => LA_LAGGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Scalar Arguments" ..
      INTEGER, INTENT(IN), OPTIONAL :: KL, KU
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: ISEED(4)
      REAL(WP), INTENT(IN), OPTIONAL, TARGET :: D(:)
      COMPLEX(WP), INTENT(OUT) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LAGGE generates a real general m by n matrix A, by pre- and post-
!!  multiplying a real diagonal matrix D with random orthogonal matrices:
!!  A = U*D*V. The lower and upper bandwidths may then be reduced to
!!  kl and ku by additional orthogonal transformations.
!
!!  Arguments
!!  =========
!
!!  SUBROUTINE LA_LAGGE( A, KL, KU, D, ISEED, INFO )
!!     <type>(<wp>), INTENT(OUT) :: A(:,:)
!!     INTEGER, INTENT(IN), OPTIONAL :: KL, KU
!!     REAL(<wp>), INTENT(IN), OPTIONAL, TARGET :: D(:)
!!     INTEGER, INTENT(INOUT), OPTIONAL :: ISEED(4)
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!!  =====================
!
!!  A       (output) REAL array, shape (:,:), SIZE(A,1) == m,
!!          SIZE(A,2) == n.
!!          The generated m by n matrix A.
!
!!  KL      (input) INTEGER
!!          The number of nonzero subdiagonals within the band of A.
!!          0 <= KL <= M-1.
!
!!  KU      (input) INTEGER
!!          The number of nonzero superdiagonals within the band of A.
!!          0 <= KU <= N-1.
!
!!  D       (input) REAL array, dimension (min(M,N))
!!          The diagonal elements of the diagonal matrix D.
!
!!  ISEED   Optional (input/output) INTEGER array, shape (:),
!!          SIZE(ISEED) == 4.
!!          On entry, the seed of the random number generator; the array
!!          elements must be between 0 and 4095, and ISEED(4) must be
!!          odd.
!!          On exit, the seed is updated.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LAGGE"
!!     .. "LOCAL Scalars" ..
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, LKL, LKU, M, MN, N, SD, SISEED
!!     .. "Local Arrays" ..
      INTEGER :: LISEED(4)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: LD(:)
      COMPLEX(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX, MIN
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      MN = MIN(M,N); ISTAT = 0
      IF( PRESENT(KL) )THEN; LKL = KL; ELSE; LKL = M-1; ENDIF
      IF( PRESENT(KU) )THEN; LKU = KU; ELSE; LKU = M-1; ENDIF
      IF( PRESENT(D) )THEN; SD = SIZE(D); ELSE; SD = MN; ENDIF
      IF( PRESENT(ISEED) )THEN; SISEED = SIZE(ISEED); LISEED = ISEED
      ELSE; SISEED = 4
            LISEED(1) = 15; LISEED(2) = 1926
            LISEED(3) = 16; LISEED(4) = 1931; ENDIF
!!     .. "Test the arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( LKL < 0 .OR. LKL > M-1 )THEN; LINFO = -2
      ELSE IF( LKU < 0 .OR. LKU > N-1 )THEN; LINFO = -3
      ELSE IF( SD /= MN )THEN; LINFO = -4
      ELSE IF( SISEED /= 4 .OR. PRESENT(ISEED) .AND. (                  &
     &   ( LISEED(1) < 0 .OR. LISEED(1) > 4095 ) .OR.                   &
     &   ( LISEED(2) < 0 .OR. LISEED(2) > 4095 ) .OR.                   &
     &   ( LISEED(3) < 0 .OR. LISEED(3) > 4095 ) .OR.                   &
     &   ( LISEED(4) < 0 .OR. LISEED(4) > 4095 ) .OR.                   &
     &   ( MOD( LISEED(4), 2 ) == 0 ) ) )THEN; LINFO = -5
      ELSE
         IF( PRESENT(D) )THEN; LD => D
         ELSE; ALLOCATE( LD( MN ), STAT=ISTAT); ENDIF
         IF( ISTAT == 0 )THEN
            ALLOCATE( WORK( M + N ), STAT=ISTAT )
            IF( ISTAT == 0 )THEN
               IF( .NOT. PRESENT(D) )THEN
                  LD(1:MN-1) = 1.0_WP; LD(MN) = 0.5_WP; ENDIF
               CALL LAGGE_F77( M, N, LKL, LKU, LD, A, LDA, LISEED, WORK, LINFO )
               IF( PRESENT(ISEED) )ISEED = LISEED
            ELSE; LINFO = -100; END IF
            DEALLOCATE( WORK, STAT=ISTAT1 )
         ENDIF
         IF( .NOT. PRESENT(D) )DEALLOCATE( LD, STAT=ISTAT1)
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END SUBROUTINE ZLAGGE_F95
      FUNCTION ZLANGE1_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: ZLANGE1_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      COMPLEX(WP), INTENT(IN) :: A(:)
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET :: LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A); N = 1; LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           ZLANGE1_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION ZLANGE1_F95
      FUNCTION ZLANGE_F95( A, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!     .. "Use Statements" ..
      use KND_LA_PRECISION, ONLY: WP => DP                                   !!((05-B-KND_LA_PRECISION.f90))
      use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                 !!((06-B-LIB_LA_AUXMOD.f90))
      use INT_LAPACK1, ONLY: LANGE_F77 => LA_LANGE                           !!((07-B-INT_LAPACK1.f90))
!!     .. "Implicit Statement" ..
      IMPLICIT NONE
!!     .. "Function Type" ..
      REAL(WP) :: ZLANGE_F95
!!     .. "Scalar Arguments" ..
      CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
      INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     .. "Array Arguments" ..
      COMPLEX(WP), INTENT(IN) :: A(:,:)
!-----------------------------------------------------------------
!
!!  Purpose
!!  =======
!
!!  LA_LANGE  returns the value of the one norm,  or the Frobenius norm,
!!  or the  infinity norm,  or the  element of  largest absolute value
!!  of a complex matrix A.
!
!!  Description
!!  ===========
!
!!  LA_LANGE returns the value
!
!!     LA_LANGE = ( max(abs(A(i,j))), NORM = "M" or "m"
!!              (
!!              ( norm1(A),         NORM = "1", "O" or "o"
!!              (
!!              ( normI(A),         NORM = "I" or "i"
!!              (
!!              ( normF(A),         NORM = "F", "f", "E" or "e"
!
!!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!!  =========
!
!!  FUNCTION LA_ANGE( A, NORM, INFO )
!!     REAL(<wp>) :: LA_ANGE
!!     <type>(<wp>), INTENT(IN) :: <a>
!!     CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!     INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     <type> ::= REAL | COMPLEX
!!     <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!     <a>    ::= A(:,:) | A(:)
!
!!  Arguments
!!  =========
!
!!  A       (input) COMPLEX array, shape either (:,:) or (:).
!!          If shape is (:,:) then SIZE(A,1) == m, SIZE(A,2) == n.
!!          If shape is (:) then SIZE(A) == n.
!!          If either m or n == 0 LA_LANGE is set to zero.
!!          The m by n matrix A.
!
!!  NORM    (input) CHARACTER*1
!!          Specifies the value to be returned in LA_LANGE as described
!!          above.
!
!!  INFO    (output) INTEGER
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value
!!      If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!
!!  ---------------------------------------------------------------------
!!     .. "Parameters" ..
      CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_LANGE"
!!     .. "Local Scalars" ..
      CHARACTER(LEN=1) :: LNORM
      INTEGER :: ISTAT, ISTAT1, LDA, LINFO, M, N
      REAL(WP), TARGET ::LLWORK(1)
!!     .. "Local Pointers" ..
      REAL(WP), POINTER :: WORK(:)
!!     .. "Intrinsic Functions" ..
      INTRINSIC SIZE, PRESENT, MAX
!!     .. "Executable Statements" ..
      LINFO = 0; M = SIZE(A,1); N = SIZE(A,2); LDA = MAX(1,M)
      ISTAT = 0
      IF( PRESENT(NORM) )THEN; LNORM = NORM; ELSE; LNORM = "1"; ENDIF
!!     .. "Testing The Arguments" ..
      IF( M < 0 .OR. N < 0 )THEN; LINFO = -1
      ELSE IF( .NOT. ( LSAME(LNORM,"M") .OR. LSAME(LNORM,"1") .OR. &
         LSAME(LNORM,"I") .OR. LSAME(LNORM,"F") .OR. &
         LSAME(LNORM,"E") ) )THEN; LINFO = -2
      ELSE
         IF( LSAME(LNORM,"I") )THEN; ALLOCATE( WORK( M), STAT=ISTAT )
         ELSE; WORK => LLWORK; ENDIF
         IF( ISTAT == 0 ) &
           ZLANGE_F95 = LANGE_F77( LNORM, M, N, A, LDA, WORK )
         IF( LSAME(LNORM,"I") )DEALLOCATE( WORK, STAT=ISTAT1 )
      ENDIF
      CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
      END FUNCTION ZLANGE_F95
 SUBROUTINE ZPBSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, 1, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPBSV1_F95
 SUBROUTINE ZPBSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PBSV_F77 => LA_PBSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSV computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. The Cholesky decomposition is used to
!! factor A as A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular band matrix and L is a lower triangular
!! band matrix, each with the same number of superdiagonals or subdiagonals
!! as A. The factored form of A is then used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_PBSV( AB, B, UPLO=uplo, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AB      (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!         of superdiagonals or subdiagonals in the band and n is the
!!         order of A.
!!         On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!         triangle of matrix A in band storage. The (kd + 1) diagonals of
!!         A are stored in the rows of AB so that the j-th column of A is
!!         stored in the j-th column of AB as follows:
!!         if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                  1<=j<=n
!!         if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                  1<=j<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U = L*L^H in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1)
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program
!!         is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PBSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, KD, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; KD = SIZE(A,1)-1; N = SIZE(A,2); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; ENDIF
!!   .. TEST THE ARGUMENTS
    IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PBSV_F77( LUPLO, N, KD, NRHS, A, KD+1, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPBSV_F95
SUBROUTINE ZPBSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                            S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, KD
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( KD < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, 1, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPBSVX1_F95
SUBROUTINE ZPBSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, &
                           S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PBSVX_F77 => LA_PBSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PBSVX computes the solution to a linear system of equations
!! A*X = B, where A has band form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B
!! are rectangular matrices or vectors.
!!     LA_PBSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PBSVX( AB, B, X, UPLO=uplo, AFB=afb, FACT=fact, &
!!                             EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                             RCOND=rcond, INFO=info )
!!             <type>(<wp>), INTENT(INOUT) :: AB(:,:), <rhs>
!!             <type>(<wp>), INTENT(OUT) :: <sol>
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!             <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFB(:,:)
!!             CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!             CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!             REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!             REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!             INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!             <type> ::= REAL | COMPLEX
!!             <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!             <rhs>  ::= B(:,:) | B(:)
!!             <sol>  ::= X(:,:) | X(:)
!!             <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AB       (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(AB,1) = kd + 1 and size(AB,2) = n, where kd is the number
!!          of superdiagonals or subdiagonals and n is the order of A.
!!          On entry, the upper (if UPLO = "U") or lower (if UPLO = "L")
!!          triangle of matrix A, or its equilibration, in band storage.
!!          The (kd + 1) diagonals of A are stored in the rows of AB so
!!          that the j-th column of A is stored in the j-th column of AB
!!          as follows:
!!          if UPLO = "U", AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j
!!                                                   1<=j<=n
!!          if UPLO = "L", AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd)
!!                                                   1<=j<=n.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in AB; otherwise, AB is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!          and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFB      Optional (input or output) REAL or COMPLEX array, shape (:)
!!          with the same size as AB.
!!          If FACT = "F" then AFB is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_PBSVX.
!!          If FACT /= "F" then AFB is an output argument that contains
!!          the factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is supplied
!!          on entry, and if not, whether A should be equilibrated before
!!          it is factored.
!!            = "N": The matrix A will be copied to AFB and factored (no
!!                 equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to
!!                 AFB and factored.
!!            = "F": AFB contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)
!!          = size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!                is not positive definite, so the factorization could
!!                not be completed and the solution and error bounds
!!                could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!                machine precision, so the matrix is singular to
!!                working precision. Nevertheless, the solution and
!!                error bounds are computed because the computed solution
!!                can be more accurate than the value of RCOND would
!!                suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PBSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, &
              SS, SFERR, SBERR, KD
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   KD = SIZE(A,1)-1; N = SIZE(A, 2); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = KD+1; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A,1) < 0 .OR. N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= KD+1 .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(S1AF,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PBSVX_F77( LFACT, LUPLO, N, KD, NRHS, A, KD+1, LAF, S1AF, &
                         LEQUED, LS, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPBSVX_F95
 SUBROUTINE ZPOSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, 1, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPOSV1_F95
 SUBROUTINE ZPOSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: POSV_F77 => LA_POSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_POSV computes the solution to a linear system of equations
!! A*X=B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices
!! or vectors. The Cholesky decomposition is used to factor A as
!! A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!         SUBROUTINE LA_POSV( A, B, UPLO=uplo, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A     (input/output) REAL or COMPLEX square array, shape (:,:).
!!       On entry, the matrix A.
!!       If UPLO = "U", the upper triangular part of A contains the upper
!!       triangular part of the matrix A, and the strictly lower triangular
!!       part of A is not referenced. If UPLO = "L", the lower triangular
!!       part of A contains the lower triangular part of the matrix A, and
!!       the strictly upper triangular part of A is not referenced.
!!       On exit, the factor U or L from the Cholesky factorization
!!       A = U^H*U = L*L^H.
!! B     (input/output) REAL or COMPLEX array, shape (:,:) with
!!       size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!       On entry, the matrix B.
!!       On exit, the solution matrix X.
!! UPLO  Optional (input) CHARACTER(LEN=1)
!!        = "U": Upper triangle of A is stored;
!!        = "L": Lower triangle of A is stored.
!!       Default value: "U".
!! INFO  Optional (output) INTEGER
!!       = 0: sauccessful exit.
!!       < 0: if INFO = -i, the i-th argument had an illegal value.
!!       > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!          completed and the solution could not be computed.
!!       If INFO is not present and an error occurs, then the program is
!!       terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_POSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL POSV_F77( LUPLO, N, NRHS, A, N, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPOSV_F95
SUBROUTINE ZPOSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, ISTAT, ISTAT1, S1AF, S2AF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPOSVX1_F95
SUBROUTINE ZPOSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POSVX_F77 => LA_POSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!   LA_POSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors.
!!   LA_POSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_POSVX( A, B, X, UPLO=uplo, AF=af, FACT=fact, &
!!                          EQUED=equed, S=s, FERR=ferr, BERR=berr, &
!!                          RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!            REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A        (input/output) REAL or COMPLEX square array, shape (:,:).
!!          On entry, the matrix A or its equilibration:
!!          If UPLO = "U", then the upper triangular part of A contains
!!          the upper triangular part of (the equilibrated) A, and the
!!          strictly lower triangular part of A is not referenced.
!!          If UPLO = "L", then the lower triangular part of A contains
!!          the lower triangular part of (the equilibrated) A, and the
!!          strictly upper triangular part of A is not referenced.
!!          If FACT = "F" and EQUED = "Y", then A has been equilibrated
!!          by the scaling factors in S during a previous call to
!!          LA_POSVX.
!!          On exit, if FACT = "E", then the equilibrated version of A is
!!          stored in A; otherwise, A is unchanged.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = size(A,1) or shape (:) with size(B) =
!!          size(A,1).
!!          On entry, the matrix B.
!!          On exit, the scaled version of B if the system has been
!!          equilibrated; otherwise, B is unchanged.
!! X        (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!          size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!          = size(A,1).
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AF       Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as A.
!!          If FACT = "F" then AF is an input argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A, in the same storage format as A, returned by
!!          a previous call to LA_POSVX
!!          If FACT /= "F" then AF is an output argument that contains the
!!          factor U or L from the Cholesky factorization of (the
!!          equilibrated) A in the same storage format as A.
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of the matrix A is
!!          supplied on entry, and, if not, whether A should be
!!          equilibrated before it is factored.
!!            = "N": The matrix A will be copied to AF and factored
!!                 (no equilibration).
!!            = "E": The matrix A will be equilibrated, then copied to AF
!!                 and factored.
!!            = "F": AF contains the factored form of (the equilibrated)
!!                 A.
!!          Default value: "N".
!! EQUED    Optional (input or output) CHARACTER(LEN=1).
!!          Specifies the form of equilibration that was done.
!!          EQUED is an input argument if FACT = "F", otherwise it is an
!!          output argument:
!!            = "N": No equilibration (always true if FACT = "N").
!!            = "Y": Equilibration, i.e., A has been premultiplied and
!!                 postmultiplied by diag(S).
!!          Default value: "N".
!! S        Optional (input or output) REAL array, shape (:) with size(S)=
!!          size(A,1).
!!          The scaling factors for A.
!!          S is an input argument if FACT = "F" and EQUED = "Y".
!!          S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR) =
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j), FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of (the
!!          equilibrated) A. If RCOND is less than the machine precision,
!!          the matrix is singular to working precision. This condition is
!!          indicated by a return code of INFO > 0.
!! INFO     Optional (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!              <= n: the leading minor of order i of (the equilibrated)
!!                  A is not positive definite, so the factorization
!!                  could not be completed and the solution and error
!!                  bounds could not be computed. RCOND= 0 is returned.
!!              = n+1: U or L is nonsingular, but RCOND is less than
!!                  machine precision, so the matrix is singular to
!!                  working precision. Nevertheless, the solution and
!!                  error bounds are computed because the computed
!!                  solution can be more accurate than the value of
!!                    RCOND would suggest.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, S1AF, S2AF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL POSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPOSVX_F95
SUBROUTINE ZPOTRF_F95( A, UPLO, RCOND, NORM, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: POTRF_F77 => LA_POTRF, LANSY_F77 => LA_LANSY, &    !!((07-B-INT_LAPACK1.f90))
                                  POCON_F77 => LA_POCON
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM, UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL  :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_POTRF computes the Cholesky factorization of a real symmetric or
!! complex Hermitian positive definite matrix A.
!
!! The factorization has the form
!!    A = U**H * U,  if UPLO = "U", or
!!    A = L * L**H,  if UPLO = "L",
!! where U is an upper triangular matrix and L is lower triangular.
!
!! This is the block version of the algorithm, calling Level 3 BLAS.
!
!! LA_POTRF optionally estimates the reciprocal of the condition number
!! (in the 1-norm) of a real symmetric or complex Hermitian positive
!! definite matrix A.
!! An estimate is obtained for norm(inv(A)), and the reciprocal of the
!! condition number is computed as RCOND = 1 / (norm(A) * norm(inv(A))).
!
!! =======
!
!!    SUBROUTINE LA_POTRF( A, UPLO, RCOND, NORM, INFO )
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: NORM
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the symmetric (Hermitian) matrix A.
!!            If UPLO = "U", the upper triangular part of A contains
!!               the upper triangular part of the matrix A, and the
!!               strictly lower triangular part of A is not referenced.
!!            If UPLO = "L", the lower triangular part of A contains
!!               the lower triangular part of the matrix A, and the
!!               strictly upper triangular part of A is not referenced.
!!         On exit, if INFO = 0, the factor U or L from the Cholesky
!!            factorization A = U**H*U or A = L*L**H.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored;
!!            = "L":  Lower triangle of A is stored.
!!         otherwise UPLO = "U" is assumed.
!
!! RCOND   Optional (output) REAL
!!         The reciprocal of the condition number of the matrix A
!!         computed as RCOND = 1/(norm(A) * norm(inv(A))).
!! NORM    Optional (input) CHARACTER*1
!!         Specifies whether the 1-norm condition number or the
!!         infinity-norm condition number is required:
!!           If NORM is present then:
!!              = "1", "O" or "o": 1-norm;
!!              = "I" or "i": infinity-norm.
!!           otherwise NORM = "1" is used.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!            > 0: if INFO = i, the leading minor of order i is not
!!               positive definite, and the factorization could not be
!!               completed.
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! --------------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_POTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LNORM, LUPLO
   INTEGER :: LINFO, N, ISTAT, ISTAT1, LD
   REAL(WP) :: ANORM
!!  .. LOCAL POINTERS ..
   REAL(WP), POINTER :: RWORK(:)
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(NORM) ) THEN; LNORM = NORM; ELSE; LNORM = "1"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .AND. N < 0 )THEN; LINFO = -1
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -2
   ELSE IF( ( .NOT.PRESENT(RCOND) .AND. PRESENT(NORM) ) .OR. &
            ( .NOT.LSAME(LNORM,"I") .AND. .NOT.LSAME(LNORM,"O") &
              .AND. LNORM /= "1" ) ) THEN; LINFO = -4
   ELSE IF(  N > 0 )THEN
      IF( PRESENT(RCOND) ) THEN
!!     .. COMPUTE THE NORM OF THE MATRIX A
         ALLOCATE(RWORK(N), STAT=ISTAT)
         IF( ISTAT == 0 )THEN; ANORM = LANSY_F77( LNORM, LUPLO, LD, A, N, RWORK )
         ELSE; LINFO = -100; END IF
         DEALLOCATE(RWORK, STAT=ISTAT1)
      END IF
!
      IF( LINFO == 0 ) THEN
!!     .. COMPUTE THE CHOLESKY FACTORS OF THE MATRIX A
         CALL POTRF_F77( LUPLO, N, A, LD, LINFO )
!
         IF( PRESENT(RCOND) .AND. LINFO == 0 ) THEN
!!        .. COMPUTE THE RECIPROCAL OF THE CONDITION NUMBER OF A
            IF( ANORM == 0.0_WP )THEN; RCOND = 0.0_WP
            ELSE; ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT)
               IF( ISTAT == 0 )THEN
                  CALL POCON_F77( LUPLO, N, A, LD, ANORM, RCOND, &
                                  WORK, RWORK, LINFO )
               ELSE; LINFO = -100; END IF
               DEALLOCATE(WORK, RWORK, STAT=ISTAT1)
            END IF
         END IF
      END IF
   ELSE IF( PRESENT(RCOND) ) THEN; RCOND = 1.0_WP; ENDIF
   CALL ERINFO(LINFO,SRNAME,INFO,ISTAT)
END SUBROUTINE ZPOTRF_F95
 SUBROUTINE ZPPSV1_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, 1, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPPSV1_F95
 SUBROUTINE ZPPSV_F95( A, B, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PPSV_F77 => LA_PPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    COMPLEX(WP), INTENT(INOUT) :: A(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PPSV computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format. The Cholesky decomposition is
!! used to factor A as
!!      A = U^H*U if UPLO = "U", or A = L*L^H if UPLO = "L"
!! where U is an upper triangular matrix and L is a lower triangular
!! matrix (L = U^H ). The factored form of A is then used to solve the
!! above system.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSV( AP, B, UPLO=uplo, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX array, shape (:) with size(AP)
!!         = n*(n+1)/2, where n is the order of A.
!!         On entry, the upper or lower triangle of matrix A in packed
!!         storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, the factor U or L from the Cholesky factorization
!!         A = U^H*U or A = L*L^H , in the same storage format as A.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the solution matrix X.
!! UPLO    Optional, (input) CHARACTER(LEN=1)
!!         = "U": Upper triangle of A is stored;
!!         = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! INFO    Optional (output) INTEGER.
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, the leading minor of order i of A is not
!!            positive definite, so the factorization could not be
!!            completed and the solution could not be computed.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS
    COMPLEX(WP) :: WW
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; NN = SIZE(A); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PPSV_F77( LUPLO, N, NRHS, A, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPPSV_F95
SUBROUTINE ZPPSVX1_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SAF, SS
   REAL(WP) :: LRCOND, MVS, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPPSVX1_F95
SUBROUTINE ZPPSVX_F95(A, B, X, UPLO, AF, FACT, EQUED, S, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PPSVX_F77 => LA_PPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(INOUT) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: S(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_PPSVX computes the solution to a linear system of equations
!! A*X = B, where A is real symmetric or complex Hermitian and, in either
!! case, positive definite, and where X and B are rectangular matrices or
!! vectors. A is stored in packed format.
!!     LA_PPSVX can also optionally equilibrate the system if A is poorly
!! scaled, estimate the condition number of (the equilibrated) A, and
!! compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_PPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                  FACT=fact, EQUED=equed, S=s, FERR=ferr, &
!!                  BERR=berr, RCOND=rcond, INFO=info )
!!           <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!           <type>(<wp>), INTENT(OUT) :: <sol>
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!           <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!           CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!           CHARACTER(LEN=1), INTENT(INOUT), OPTIONAL :: EQUED
!!           REAL(<wp>), INTENT(INOUT), OPTIONAL :: S(:)
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>
!!           REAL(<wp>), INTENT(OUT), OPTIONAL :: RCOND
!!           INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!           <type> ::= REAL | COMPLEX
!!           <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!           <rhs>  ::= B(:,:) | B(:)
!!           <sol>  ::= X(:,:) | X(:)
!!           <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP      (input/output) REAL or COMPLEX square array, shape (:) with
!!         size(AP) = n*(n + 1)=2, where n is a rank of the matrix A.
!!         On entry, the upper or lower triangle of matrix A, or its
!!         equilibration, in packed storage. The elements are stored
!!         columnwise as follows:
!!         if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!         if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!         On exit, if FACT = "E", then the equilibrated version of A is
!!         stored in AP; otherwise, AP is unchanged.
!! B       (input/output) REAL or COMPLEX array, shape (:,:) with
!!         size(B,1) = n or shape (:) with size(B) = n.
!!         On entry, the matrix B.
!!         On exit, the scaled version of B if the system has been
!!         equilibrated; otherwise, B is unchanged.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1)=n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!           = "U": Upper triangle of A is stored;
!!           = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AFP     Optional (input or output) REAL or COMPLEX array, shape (:)
!!         with the same size as AP.
!!         If FACT = "F" then AFP is an input argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A, in the same storage format as A, returned by
!!         a previous call to LA_PPSVX.
!!         If FACT 6= "F" then AFP is an output argument that contains the
!!         factor U or L from the Cholesky factorization of (the
!!         equilibrated) A in the same storage format as A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A is supplied
!!         on entry, and, if not, whether A should be equilibrated before
!!         it is factored.
!!           = "N": The matrix A will be copied to AFP and factored
!!                (no equilibration).
!!           = "E": The matrix A will be equilibrated, then copied to AFP
!!                and factored.
!!           = "F": AFP contains the factored form of (the equilibrated) A.
!!         Default value: "N".
!! EQUED   Optional (input or output) CHARACTER(LEN=1).
!!         Specifies the form of equilibration that was done.
!!         EQUED is an input argument if FACT = "F", otherwise it is an
!!         output argument:
!!           = "N": No equilibration (always true if FACT = "N").
!!           = "Y": Equilibration, i.e., A has been premultiplied and
!!                postmultiplied by diag(S).
!!         Default value: "N".
!! S       Optional (input or output) REAL array, shape (:) with size(S)
!!         = size(A,1).
!!         The scaling factors for A.
!!         S is an input argument if FACT = "F" and EQUED = "Y".
!!         S is an output argument if FACT = "E" and EQUED = "Y".
!! FERR    Optional (output) REAL array of shape (:), with size(FERR) =
!!         size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j) , FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of (the
!!         equilibrated) A. If RCOND is less than the machine precision,
!!         the matrix is singular to working precision. This condition is
!!         indicated by a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of (the equilibrated) A
!!               is not positive definite, so the factorization could
!!               not be completed and the solution and error bounds
!!               could not be computed. RCOND= 0 is returned.
!!             = n+1: U or L is nonsingular, but RCOND is less than
!!               machine precision, so the matrix is singular to
!!               working precision. Nevertheless, the solution and
!!               error bounds are computed because the computed solution
!!               can be more accurate than the value of RCOND would
!!               suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO, LEQUED
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SAF, SS, SFERR, SBERR
   REAL(WP) :: LRCOND, MVS
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LS(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF( :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MINVAL, TINY, REAL, INT, AIMAG
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A, 1); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(EQUED) .AND. LSAME(LFACT,"F") )THEN; LEQUED = EQUED
   ELSE; LEQUED="N"; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = N*(N+1)/2; END IF
   IF( ( PRESENT(S) ) )THEN; SS = SIZE(S); ELSE; SS = N; END IF
   IF( PRESENT(S) .AND. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") ) THEN
       MVS = MINVAL(S); ELSE; MVS = TINY(1.0_WP); ENDIF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
   IF(PRESENT(UPLO))THEN; LUPLO = UPLO; ELSE; LUPLO="U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= N*(N+1)/2 ) THEN; LINFO = -5
   ELSE IF( ( .NOT. ( LSAME(LFACT,"F") .OR. LSAME(LFACT,"N") .OR. &
                    LSAME(LFACT,"E") ) ) .OR. &
      ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(AF) ) )THEN; LINFO = -6
   ELSE IF( .NOT.LSAME(LEQUED,"N") .AND. .NOT.LSAME(LEQUED,"Y") )THEN; LINFO = -7
   ELSE IF( SS /= N .OR. LSAME(LFACT,"F") .AND. LSAME(LEQUED,"Y") &
      .AND. MVS  <= 0.0_WP )THEN; LINFO = -8
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -9
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -10
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N*(N+1)/2), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(S) )THEN; ALLOCATE( LS(N), STAT=ISTAT )
         ELSE; LS => S; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(2*N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LEQUED, LS, &
                  B, N, X, N, LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(S) ) DEALLOCATE( LS, STAT=ISTAT1 )
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      IF( PRESENT(EQUED) .AND. .NOT.LSAME(LFACT,"F") ) EQUED=LEQUED
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPPSVX_F95
 SUBROUTINE ZPTSV1_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    COMPLEX(WP), INTENT(INOUT) :: E(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, 1, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPTSV1_F95
 SUBROUTINE ZPTSV_F95( D, E, B, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO                                          !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: PTSV_F77 => LA_PTSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    REAL(WP), INTENT(INOUT) :: D(:)
    COMPLEX(WP), INTENT(INOUT) :: E(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSV computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors. A is factored as A = L*D*L^H, where L
!! is a unit lower bidiagonal matrix and D is a diagonal matrix. The
!! factored form of A is then used to solve the above system.
!!
!! =========
!!
!!        SUBROUTINE LA_PTSV( D, E, B, INFO=info )
!!            REAL(<wp>), INTENT(INOUT) :: D(:)
!!            <type>(<wp>), INTENT(INOUT) :: E(:), <rhs>
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!        where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! D      (input/output) REAL array, shape (:) with size(D) = n, where n
!!        is the order of A.
!!        On entry, the diagonal of A.
!!        On exit, the diagonal of D.
!! E      (input/output) REAL or COMPLEX array, shape (:), with
!!        size(E) = n-1.
!!        On entry, the subdiagonal of A.
!!        On exit, the subdiagonal of L.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = n or shape (:) with size(B) = n.
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! INFO   Optional (output) INTEGER.
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, the leading minor of order i of A is not
!!             positive definite, and the solution has not been computed.
!!           The factorization has not been completed unless i = n.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_PTSV"
!!   .. LOCAL SCALARS ..
    INTEGER :: LINFO, N, NRHS
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0
    N = SIZE(D); NRHS = SIZE(B,2)
!!   .. TEST THE ARGUMENTS
    IF( N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -3
    ELSE IF ( N > 0 ) THEN
       CALL PTSV_F77( N, NRHS, D, E, B, N, LINFO )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO )
 END SUBROUTINE ZPTSV_F95
SUBROUTINE ZPTSVX1_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   COMPLEX(WP), INTENT(IN) :: E(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, N, ISTAT, ISTAT1, SDF, SEF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LDF(:)
   COMPLEX(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -3
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, 1, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPTSVX1_F95
SUBROUTINE ZPTSVX_F95(D, E, B, X, DF, EF, FACT, FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: PTSVX_F77 => LA_PTSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   REAL(WP), INTENT(IN) :: D(:)
   COMPLEX(WP), INTENT(IN) :: E(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   REAL(WP), INTENT(INOUT), OPTIONAL, TARGET :: DF(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: EF(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_PTSVX computes the solution to a linear system of equations
!! A*X = B, where A has tridiagonal form and is real symmetric or complex
!! Hermitian and, in either case, positive definite, and where X and B are
!! rectangular matrices or vectors.
!!    LA_PTSVX can also optionally estimate the condition number of A and
!! compute error bounds.
!!
!! =========
!!
!!     SUBROUTINE LA_PTSVX( D, E, B, X, DF=df, EF=ef, FACT=fact, &
!!                  FERR=ferr, BERR=berr, RCOND=rcond, INFO=info )
!!          REAL(<wp>), INTENT(IN) :: D(:)
!!          <type>(<wp>), INTENT(IN) :: E(:), <rhs>
!!          <type>(<wp>), INTENT(OUT) :: <sol>
!!          REAL(<wp>), INTENT(INOUT), OPTIONAL :: DF(:)
!!          <type>(<wp>), INTENT(INOUT), OPTIONAL :: EF(:)
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!          REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!     where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!          <sol>  ::= X(:,:) | X(:)
!!          <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! D       (input) REAL array, shape (:) with size(D) = n, where n is the
!!         order of A.
!!         The diagonal of A.
!! E       (input) REAL or COMPLEX array, shape (:) with size(E) = n-1.
!!         The subdiagonal of A.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) = n
!!         or shape (:) with size(B) = n.
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) = n
!!         and size(X,2) = size(B,2), or shape (:) with size(X) = n.
!!         The solution matrix X .
!! DF      Optional (input or output) REAL array, shape (:) with the same
!!         size as D.
!!         If FACT = "F", then DF is an input argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!!         If FACT = "N", then DF is an output argument that contains the
!!         diagonal of D from the L*D*L^H factorization of A.
!! EF      Optional (input or output) REAL or COMPLEX array, shape (:) with
!!         the same size as E.
!!         If FACT = "F", then EF is an input argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!!         If FACT = "N", then EF is an output argument that contains the
!!         subdiagonal of L from the L*D*L^H factorization of A.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of A has been supplied on
!!         entry.
!!           = "N": The matrix A will be copied to DF and EF and factored.
!!           = "F": DF and EF contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector X(j)
!!         (the j-th column of the solution matrix X). If XTRUE is the
!!         true solution corresponding to X(j), FERR(j) is an estimated
!!         upper bound for the magnitude of the largest element in
!!         (X(j)-XTRUE) divided by the magnitude of the largest element in
!!         X(j).
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL.
!!         The estimate of the reciprocal condition number of the matrix
!!         A. If RCOND is less than the machine precision, the matrix is
!!         singular to working precision. This condition is indicated by
!!         a return code of INFO > 0.
!! INFO    Optional (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: the leading minor of order i of A is not positive
!!                definite, so the factorization could not be completed
!!                unless i = n, and the solution and error bounds could
!!                not be computed. RCOND = 0 is returned.
!!             = n+1: L is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error
!!                  bounds are computed because the computed solution can
!!                  be more accurate than the value of RCOND would suggest.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!-----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_PTSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT
   INTEGER :: LINFO, NRHS, N, ISTAT, ISTAT1, SDF, SEF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   REAL(WP),  POINTER :: RWORK(:), LDF(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LEF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0
   N = SIZE(D); NRHS = SIZE(B,2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(DF) )THEN; SDF = SIZE(DF); ELSE; SDF = N; END IF
   IF( PRESENT(EF) )THEN; SEF = SIZE(EF); ELSE; SEF = N-1; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( N < 0 ) THEN; LINFO = -1
   ELSE IF( SIZE( E ) /= N-1 .AND. N /= 0 ) THEN; LINFO = -2
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -3
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -4
   ELSE IF( SDF /= N ) THEN; LINFO = -5
   ELSE IF( .NOT.( PRESENT(DF).AND.PRESENT(EF) ) &
       .AND.( PRESENT(DF).OR.PRESENT(EF) ) )THEN; LINFO = -5
   ELSE IF( SEF /= N-1 .AND. N>0 ) THEN; LINFO = -6
   ELSE IF( ( .NOT.LSAME(LFACT,"F") .AND. .NOT.LSAME(LFACT,"N") ) .OR. &
            ( LSAME(LFACT,"F") .AND. .NOT.PRESENT(DF) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(DF) ) THEN; ALLOCATE( LDF(N), LEF(N-1), STAT=ISTAT )
      ELSE; LDF => DF; LEF => EF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 ) ALLOCATE(WORK(N), RWORK(N), STAT=ISTAT )
      IF( ISTAT == 0 )THEN
         CALL PTSVX_F77( LFACT, N, NRHS, D, E, LDF, LEF, B, N, X, N, LRCOND, &
                         LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(DF) ) DEALLOCATE( LDF, LEF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZPTSVX_F95
 SUBROUTINE ZSPSV1_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, 1, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZSPSV1_F95
 SUBROUTINE ZSPSV_F95( AP, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SPSV_F77 => LA_SPSV                               !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: AP(:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!     LA_SPSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors. A diagonal
!! pivoting method is used to factor A as
!!    A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!     LA_HPSV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors. A diagonal pivoting
!! method is used to factor A as
!!     A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal matrix
!! with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then
!! used to solve the above system.
!!
!! =========
!!
!!      SUBROUTINE LA_SPSV / LA_HESV( AP, B, UPLO=uplo, &
!!                                 IPIV=ipiv, INFO=info )
!!          <type>(<wp>), INTENT(INOUT) :: AP(:), <rhs>
!!          CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!          INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!          INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!      where
!!          <type> ::= REAL | COMPLEX
!!          <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!          <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! AP       (input/output) REAL or COMPLEX array, shape (:) with size(AP)=
!!          n*(n + 1)=2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!!          On exit, the block diagonal matrix D and the multipliers used
!!          to obtain U or L from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! B        (input/output) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          On entry, the matrix B.
!!          On exit, the solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1)
!!             = "U": Upper triangle of A is stored;
!!             = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! IPIV     Optional (output) INTEGER array, shape (:) with size(IPIV)=n.
!!          Details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!          interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV k < 0, then there are two cases:
!!            1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows
!!             and columns (k-1) and -IPIV(k) were interchanged and
!!             D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!            2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows
!!             and columns (k + 1) and -IPIV(k) were interchanged and
!!             D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO     Optional (output) INTEGER.
!!          = 0: successful exit
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!            completed, but the block diagonal matrix D is singular,
!!            so the solution could not be computed.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SPSV"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, N, NN, NRHS, SIPIV, ISTAT, ISTAT1
    COMPLEX(WP) :: WW
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT, REAL, INT, AIMAG
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; NN = SIZE(AP); NRHS = SIZE(B,2)
    WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
    IF( PRESENT(UPLO) )THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
!!   .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 ) THEN
         CALL SPSV_F77( LUPLO, N, NRHS, AP, LPIV, B, N, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZSPSV_F95
SUBROUTINE ZSPSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NN, ISTAT, ISTAT1, SIPIV, SAF
   REAL(WP) :: LRCOND, LFERR, LBERR
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; SAF = SIZE(AF); ELSE; SAF = NN; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,3*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, 1, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZSPSVX1_F95
SUBROUTINE ZSPSVX_F95(A, B, X, UPLO, AFP, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SPSVX_F77 => LA_SPSVX                              !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AFP(:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix stored in packed
!! format and X and B are rectangular matrices or vectors.
!!    LA_HPSVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix stored in packed format
!! and X and B are rectangular matrices or vectors.
!!    LA_SPSVX and LA_HPSVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!       SUBROUTINE LA_SPSVX / LA_HPSVX( AP, B, X, UPLO=uplo, AFP=afp, &
!!                         IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                         RCOND=rcond, INFO=info )
!!            <type>(<wp>), INTENT(IN) :: AP(:), <rhs>
!!            <type>(<wp>), INTENT(OUT) :: <sol>
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!            <type>(<wp>), INTENT(INOUT), OPTIONAL :: AFP(:)
!!            INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!            CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!            REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!            INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!       where
!!            <type> ::= REAL | COMPLEX
!!            <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!            <rhs>  ::= B(:,:) | B(:)
!!            <sol>  ::= X(:,:) | X(:)
!!            <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! AP       (input) REAL or COMPLEX array, shape (:) with size(AP ) =
!!          n*(n + 1)/2, where n is the order of A.
!!          On entry, the upper or lower triangle of matrix A in packed
!!          storage. The elements are stored columnwise as follows:
!!          if UPLO = "U", AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j<=n;
!!          if UPLO = "L", AP(i + (j-1)*(2n-j)/2) = A(i,j) for 1<=j<=i<=n.
!! B        (input) REAL or COMPLEX array, shape (:,:) with
!!          size(B,1) = n or shape (:) with size(B) = n.
!!          The matrix B.
!! X        (output) REAL or COMPLEX array, shape (:,:) with
!!          size(X,1) = n and size(X,2) = size(B,2), or shape (:) with
!!          size(X) = n.
!!          The solution matrix X .
!! UPLO     Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!          Default value: "U".
!! AFP      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!          with the same size as AP.
!!          If FACT = "F", then AFP is an input argument that contains
!!          the block diagonal matrix D and the multipliers used to
!!          obtain the factor L or U from the factorization of A, returned
!!          by a previous call to LA_SPSVX or LA_HPSVX and stored as a
!!          packed triangular matrix in the same storage format as A.
!!          If FACT = "N", then AFP is an output argument that contains
!!          the block diagonal matrix D and the multipliers used to obtain
!!          the factor L or U from the factorization of A, stored as a
!!          packed triangular matrix in the same storage format as A.
!! IPIV     Optional (input or output) INTEGER array, shape (:) with
!!          size(IPIV) = size(A,1).
!!          If FACT = "F", then IPIV is an input argument that contains
!!          details of the row and column interchanges and the block
!!          structure of D.
!!          If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!          interchanged and D(k,k) is a 1 by 1 diagonal block.
!!          If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns (k-1) and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns (k+1) and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!          If FACT = "N", then IPIV is an output argument and on exit
!!          contains details of the interchanges and the block structure
!!          of D (as described above).
!! FACT     Optional (input) CHARACTER(LEN=1).
!!          Specifies whether the factored form of A has been supplied
!!          on entry.
!!            = "N": The matrix A will be copied to AFP and factored.
!!            = "F": AFP and IPIV contain the factored form of A.
!!          Default value: "N".
!! FERR     Optional (output) REAL array of shape (:), with size(FERR)=
!!          size(X,2), or REAL scalar.
!!          The estimated forward error bound for each solution vector
!!          X(j) (the j-th column of the solution matrix X). If XTRUE is
!!          the true solution corresponding to X(j) , FERR(j) is an
!!          estimated upper bound for the magnitude of the largest element
!!          in (X(j)-XTRUE) divided by the magnitude of the largest
!!          element in X(j). The estimate is as reliable as the estimate
!!          for RCOND, and is almost always a slight overestimate of the
!!          true error.
!! BERR     Optional (output) REAL array of shape (:), with size(BERR) =
!!          size(X,2), or REAL scalar.
!!          The componentwise relative backward error of each solution
!!          vector X(j) (i.e., the smallest relative change in any element
!!          of A or B that makes X(j) an exact solution).
!! RCOND    Optional (output) REAL
!!          The estimate of the reciprocal condition number of A. If RCOND
!!          is less than the machine precision, the matrix is singular to
!!          working precision. This condition is indicated by a return
!!          code of INFO > 0.
!! INFO     (output) INTEGER
!!          = 0: successful exit.
!!          < 0: if INFO = -i, the i-th argument had an illegal value.
!!          > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!            n is the order of A.
!!          If INFO is not present and an error occurs, then the program
!!          is terminated with an error message.
!----------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SPSVX"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NN, ISTAT, ISTAT1, SIPIV, SAF, SFERR, SBERR
   REAL(WP) :: LRCOND
   COMPLEX(WP) :: WW
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; NN = SIZE(A); NRHS = SIZE(B, 2)
   WW = (-1+SQRT(1+8*REAL(NN,WP)))*0.5; N = INT(WW)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AFP) )THEN; SAF = SIZE(AFP); ELSE; SAF = NN; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
    IF( NN < 0 .OR. AIMAG(WW) /= 0 .OR. REAL(N,WP) /= REAL(WW) ) THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( SAF /= NN ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AFP) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AFP) ) THEN; ALLOCATE( LAF(NN), STAT=ISTAT )
      ELSE; LAF => AFP; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         ALLOCATE(WORK(MAX(1,2*N)), RWORK(N), STAT=ISTAT)
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SPSVX_F77( LFACT, LUPLO, N, NRHS, A, LAF, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AFP) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZSPSVX_F95

 SUBROUTINE ZSYSV1_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:)
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B ) /= N ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(SIZE(A,1)), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N-1
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, 1, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZSYSV1_F95
 SUBROUTINE ZSYSV_F95( A, B, UPLO, IPIV, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!   .. use STATEMENTS ..
    use KND_LA_PRECISION, ONLY: WP => DP                                     !!((05-B-KND_LA_PRECISION.f90))
    use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                   !!((06-B-LIB_LA_AUXMOD.f90))
    use INT_LAPACK1, ONLY: SYSV_F77 => LA_SYSV, ILAENV_F77 => ILAENV         !!((07-B-INT_LAPACK1.f90))
!!   .. IMPLICIT STATEMENT ..
    IMPLICIT NONE
!!   .. SCALAR ARGUMENTS ..
    CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
    INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!   .. ARRAY ARGUMENTS ..
    INTEGER, INTENT(OUT), OPTIONAL, TARGET :: IPIV(:)
    COMPLEX(WP), INTENT(INOUT) :: A(:,:), B(:,:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!    LA_SYSV computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^T if UPLO = "U", or A = L*D*L^T if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a symmetric block diagonal matrix with
!! 1 by 1 and 2 by 2 diagonal blocks. The factored form of A is then used
!! to solve the above system.
!!    LA_HESV computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors. A diagonal pivoting method is used to
!! factor A as
!!      A = U*D*U^H if UPLO = "U", or A = L*D*L^H if UPLO = "L"
!! where U (or L) is a product of permutation and unit upper (or lower)
!! triangular matrices, and D is a complex Hermitian block diagonal
!! matrix with 1 by 1 and 2 by 2 diagonal blocks. The factored form of A
!! is then used to solve the above system.
!!
!! =========
!!
!!          SUBROUTINE LA_SYSV / LA_HESV( A, B, UPLO=uplo, &
!!                                   IPIV=ipiv, INFO=info )
!!                <type>(<wp>), INTENT(INOUT) :: A(:,:), <rhs>
!!                CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!                INTEGER, INTENT(OUT), OPTIONAL :: IPIV(:)
!!                INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!          where
!!                <type> ::= REAL | COMPLEX
!!                <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!                <rhs>  ::= B(:,:) | B(:)
!!
!! Arguments
!! =========
!!
!! A      (input/output) REAL or COMPLEX square array, shape (:,:).
!!        On entry, the matrix A.
!!        If UPLO = "U", the upper triangular part of A contains the upper
!!        triangular part of the matrix A, and the strictly lower
!!        triangular part of A is not referenced.
!!        If UPLO = "L", the lower triangular part of A contains the lower
!!        triangular part of the matrix A, and the strictly upper
!!        triangular part of A is not referenced.
!!        On exit, the block diagonal matrix D and the multipliers used to
!!        obtain the factor U or L from the factorization of A.
!! B      (input/output) REAL or COMPLEX array, shape (:,:) with
!!        size(B,1) = size(A,1) or shape (:) with size(B) = size(A,1).
!!        On entry, the matrix B.
!!        On exit, the solution matrix X.
!! UPLO   Optional (input) CHARACTER(LEN=1)
!!          = "U": Upper triangle of A is stored;
!!          = "L": Lower triangle of A is stored.
!!        Default value: "U".
!! IPIV   Optional (output) INTEGER array, shape (:) with size(IPIV) =
!!        size(A,1).
!!        Details of the row and column interchanges and the block
!!        structure of D.
!!        If IPIV(k) > 0, then rows and columns k and IPIV(k) were
!!        interchanged, and D(k,k) is a 1 by 1 diagonal block.
!!        If IPIV k < 0, then there are two cases:
!!         1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!          columns (k-1) and -IPIV(k) were interchanged and
!!          D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!         2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!          columns (k + 1) and -IPIV(k) were interchanged and
!!          D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!! INFO   Optional (output) INTEGER
!!        = 0: successful exit.
!!        < 0: if INFO = -i, the i-th argument had an illegal value.
!!        > 0: if INFO = i, D(i,i) = 0. The factorization has been
!!             completed, but the block diagonal matrix D is singular, so
!!           the solution could not be computed.
!!        If INFO is not present and an error occurs, then the program is
!!        terminated with an error message.
!-----------------------------------------------------------------------
!!   .. PARAMETERS ..
    CHARACTER(LEN=7), PARAMETER :: SRNAME = "LA_SYSV"
    CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZSYTRF"
!!   .. LOCAL SCALARS ..
    CHARACTER(LEN=1) :: LUPLO
    INTEGER :: LINFO, ISTAT, ISTAT1, SIPIV, N, NRHS, LWORK, NB
!!   .. LOCAL POINTERS ..
    INTEGER, POINTER :: LPIV(:)
    COMPLEX(WP), POINTER :: WORK(:)
!!   .. INTRINSIC FUNCTIONS ..
    INTRINSIC SIZE, PRESENT
!!   .. EXECUTABLE STATEMENTS ..
    LINFO = 0; ISTAT = 0; N = SIZE(A,1); NRHS = SIZE(B,2)
    IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
    IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = SIZE(A,1); END IF
!!   .. TEST THE ARGUMENTS
    IF( SIZE( A, 2 ) /= N .OR. N < 0 ) THEN; LINFO = -1
    ELSE IF( SIZE( B, 1 ) /= N .OR. NRHS < 0 ) THEN; LINFO = -2
    ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
    ELSE IF( SIPIV /= N )THEN; LINFO = -4
    ELSE IF ( N > 0 ) THEN
!!  .. DETERMINE THE WORKSPACE
      IF( PRESENT(IPIV) )THEN; LPIV => IPIV
      ELSE; ALLOCATE( LPIV(N), STAT = ISTAT ); END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = N*NB
         ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, STAT=ISTAT1); LWORK = 3*N
            ALLOCATE(WORK(LWORK), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
         IF ( ISTAT == 0 ) &
!!           .. CALL LAPACK77 ROUTINE
            CALL SYSV_F77( LUPLO, N, NRHS, A, N, LPIV, B, N, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(IPIV) )DEALLOCATE(LPIV, STAT = ISTAT1 )
    END IF
    CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
 END SUBROUTINE ZSYSV_F95
SUBROUTINE ZSYSVX1_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND, FERR, BERR
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:)
   COMPLEX(WP), INTENT(OUT) :: X(:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF
   REAL(WP) :: LRCOND, LFERR, LBERR
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B) /= N )THEN; LINFO = -2
   ELSE IF( SIZE(X) /= N )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,2*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, 1, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( PRESENT(FERR) ) FERR = LFERR
      IF( PRESENT(BERR) ) BERR = LBERR
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZSYSVX1_F95
SUBROUTINE ZSYSVX_F95(A, B, X, UPLO, AF, IPIV, FACT, &
                      FERR, BERR, RCOND, INFO)
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: LSAME, ERINFO                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: SYSVX_F77 => LA_SYSVX, ILAENV_F77 => ILAENV        !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. SCALAR ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO, FACT
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
   REAL(WP), INTENT(OUT), OPTIONAL :: RCOND
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: A(:,:), B(:,:)
   COMPLEX(WP), INTENT(OUT) :: X(:,:)
   INTEGER, INTENT(INOUT), OPTIONAL, TARGET :: IPIV(:)
   COMPLEX(WP), INTENT(INOUT), OPTIONAL, TARGET :: AF(:,:)
   REAL(WP), INTENT(OUT), OPTIONAL, TARGET :: FERR(:), BERR(:)
!----------------------------------------------------------------------
!!
!! Purpose
!! =======
!!
!!      LA_SYSVX computes the solution to a linear system of equations
!! A*X = B, where A is a real or complex symmetric matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_HESVX computes the solution to a linear system of equations
!! A*X = B, where A is a complex Hermitian matrix and X and B are
!! rectangular matrices or vectors.
!!      LA_SYSVX and LA_HESVX can also optionally estimate the condition
!! number of A and compute error bounds.
!!
!! =========
!!
!!         SUBROUTINE LA_SYSVX / LA HESVX( A, B, X, UPLO=uplo, AF=af, &
!!                        IPIV=ipiv, FACT=fact, FERR=ferr, BERR=berr, &
!!                        RCOND=rcond, INFO=info )
!!              <type>(<wp>), INTENT(IN) :: A(:,:), <rhs>
!!              <type>(<wp>), INTENT(OUT) :: <sol>
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!              <type>(<wp>), INTENT(INOUT), OPTIONAL :: AF(:,:)
!!              INTEGER, INTENT(INOUT), OPTIONAL :: IPIV(:)
!!              CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: FACT
!!              REAL(<wp>), INTENT(OUT), OPTIONAL :: <err>, RCOND
!!              INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!         where
!!              <type> ::= REAL | COMPLEX
!!              <wp>   ::= KIND(1.0) | KIND(1.0D0)
!!              <rhs>  ::= B(:,:) | B(:)
!!              <sol>  ::= X(:,:) | X(:)
!!              <err>  ::= FERR(:), BERR(:) | FERR, BERR
!!
!! Arguments
!! =========
!!
!! A       (input) REAL or COMPLEX square array, shape (:,:).
!!         The symmetric or Hermitian matrix A.
!!         If UPLO = "U", the upper triangular part of A contains the
!!         upper triangular part of the matrix A, and the strictly lower
!!         triangular part of A is not referenced. If UPLO = "L", the
!!         lower triangular part of A contains the lower triangular part
!!         of the matrix A, and the strictly upper triangular part of A is
!!         not referenced.
!! B       (input) REAL or COMPLEX array, shape (:,:) with size(B,1) =
!!         size(A,1) or shape (:) with size(B) = size(A,1).
!!         The matrix B.
!! X       (output) REAL or COMPLEX array, shape (:,:) with size(X,1) =
!!         size(A,1) and size(X,2) = size(B,2), or shape (:) with size(X)
!!         = size(A,1).
!!         The solution matrix X.
!! UPLO    Optional (input) CHARACTER(LEN=1).
!!            = "U": Upper triangle of A is stored;
!!            = "L": Lower triangle of A is stored.
!!         Default value: "U".
!! AF      Optional (input or output) REAL or COMPLEX array, shape (:,:)
!!         with the same size as A.
!!         If FACT = "F", then AF is an input argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A, returned by a
!!         previous call to LA_SYSVX or LA_HESVX.
!!         If FACT = "N", then AF is an output argument that contains the
!!         block diagonal matrix D and the multipliers used to obtain the
!!         factor L or U from the factorization of A.
!! IPIV    Optional (input or output) INTEGER array, shape (:) with
!!         size(IPIV) = size(A,1).
!!         If FACT = "F", then IPIV is an input argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D.
!!         If IPIV(k) > 0 , then rows and columns k and IPIV(k) were
!!         interchanged and D(k,k) is a 1 by 1 diagonal block.
!!         If IPIV(k) < 0 , then there are two cases:
!!           1. If UPLO = "U" and IPIV(k) = IPIV(k-1) < 0, then rows and
!!            columns k-1 and -IPIV(k) were interchanged and
!!            D(k-1:k,k-1:k) is a 2 by 2 diagonal block.
!!           2. If UPLO = "L" and IPIV(k) = IPIV(k+1) < 0, then rows and
!!            columns k+1 and -IPIV(k) were interchanged and
!!            D(k:k+1,k:k+1) is a 2 by 2 diagonal block.
!!         If FACT = "N", then IPIV is an output argument that contains
!!         details of the row and column interchanges and the block
!!         structure of D; as described above.
!! FACT    Optional (input) CHARACTER(LEN=1).
!!         Specifies whether the factored form of the matrix A has been
!!         supplied on entry.
!!           = "N": The matrix A will be copied to AF and factored.
!!           = "F": AF and IPIV contain the factored form of A.
!!         Default value: "N".
!! FERR    Optional (output) REAL array of shape (:), with
!!         size(FERR) = size(X,2), or REAL scalar.
!!         The estimated forward error bound for each solution vector
!!         X(j) (the j-th column of the solution matrix X). If XTRUE is
!!         the true solution corresponding to X(j), FERR(j) is an
!!         estimated upper bound for the magnitude of the largest element
!!         in (X(j)-XTRUE) divided by the magnitude of the largest element
!!         in X(j). The estimate is as reliable as the estimate for RCOND,
!!         and is almost always a slight overestimate of the true error.
!! BERR    Optional (output) REAL array of shape (:), with size(BERR) =
!!         size(X,2), or REAL scalar.
!!         The componentwise relative backward error of each solution
!!         vector X(j) (i.e., the smallest relative change in any element
!!         of A or B that makes X(j) an exact solution).
!! RCOND   Optional (output) REAL
!!         The estimate of the reciprocal condition number of A. If RCOND
!!         is less than the machine
!!         precision, the matrix is singular to working precision. This
!!         condition is indicated by a return code of INFO > 0.
!! INFO    (output) INTEGER
!!         = 0: successful exit.
!!         < 0: if INFO = -i, the i-th argument had an illegal value.
!!         > 0: if INFO = i, and i is
!!             <= n: D(i,i) = 0. The factorization has been completed, but
!!                the block diagonal matrix D is singular, so the
!!                solution could not be computed.
!!             = n+1: D is nonsingular, but RCOND is less than machine
!!                precision, so the matrix is singular to working
!!                precision. Nevertheless, the solution and error bounds
!!                are computed because the computed solution can be more
!!                accurate than the value of RCOND would suggest.
!!             n is the order of A.
!!         If INFO is not present and an error occurs, then the program is
!!         terminated with an error message.
!------------------------------------------------------------------------
!!  .. PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_SYSVX"
   CHARACTER(LEN=6), PARAMETER :: BSNAME = "ZSYTRF"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LFACT, LUPLO
   INTEGER :: LINFO, NRHS, N, NB, LWORK, ISTAT, ISTAT1, SIPIV, S1AF, S2AF, SFERR, SBERR
   REAL(WP) :: LRCOND
!!  .. LOCAL POINTERS ..
   INTEGER, POINTER :: LPIV(:)
   REAL(WP),  POINTER :: RWORK(:), LFERR(:), LBERR(:)
   COMPLEX(WP),  POINTER :: WORK(:), LAF(:, :)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC PRESENT, SIZE, MAX
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; ISTAT = 0; N = SIZE(A, 1); NRHS = SIZE(B, 2)
   IF( PRESENT(RCOND) ) RCOND = 1.0_WP
   IF( PRESENT(FACT) )THEN; LFACT = FACT; ELSE; LFACT="N"; END IF
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
   IF( PRESENT(IPIV) )THEN; SIPIV = SIZE(IPIV); ELSE; SIPIV = N; END IF
   IF( PRESENT(AF) )THEN; S1AF = SIZE(AF,1); S2AF = SIZE(AF,2)
   ELSE; S1AF = N; S2AF = N; END IF
   IF( PRESENT(FERR) )THEN; SFERR = SIZE(FERR); ELSE; SFERR = NRHS; END IF
   IF( PRESENT(BERR) )THEN; SBERR = SIZE(BERR); ELSE; SBERR = NRHS; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE(A, 2) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE(B, 1) /= N .OR. NRHS < 0 )THEN; LINFO = -2
   ELSE IF( SIZE(X, 1) /= N .OR. SIZE(X, 2) /= NRHS )THEN; LINFO = -3
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -4
   ELSE IF( S1AF /= N .OR. S2AF /= N ) THEN; LINFO = -5
   ELSE IF( SIPIV /= N )THEN; LINFO = -6
   ELSE IF( ( .NOT. LSAME(LFACT,"F") .AND. .NOT. LSAME(LFACT,"N") ) .OR. &
     ( LSAME(LFACT,"F") .AND. .NOT.( PRESENT(AF) .AND. PRESENT(IPIV) ) ) )THEN; LINFO = -7
   ELSE IF( SFERR /= NRHS )THEN; LINFO = -8
   ELSE IF( SBERR /= NRHS )THEN; LINFO = -9
   ELSE IF ( N > 0 )THEN
      IF( .NOT.PRESENT(AF) ) THEN; ALLOCATE( LAF(N,N), STAT=ISTAT )
      ELSE; LAF => AF; END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(IPIV) )THEN; ALLOCATE( LPIV(N), STAT=ISTAT )
         ELSE; LPIV => IPIV; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(FERR) )THEN; ALLOCATE( LFERR(NRHS), STAT=ISTAT )
         ELSE; LFERR => FERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         IF( .NOT.PRESENT(BERR) )THEN; ALLOCATE( LBERR(NRHS), STAT=ISTAT )
         ELSE; LBERR => BERR; END IF
      END IF
      IF( ISTAT == 0 )THEN
         NB = ILAENV_F77( 1, BSNAME, LUPLO, N, -1, -1, -1 )
         IF( NB <= 1 .OR. NB >= N ) NB = 1; LWORK = MAX(1,2*N,N*NB)
         ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
         IF( ISTAT /= 0 )THEN
            DEALLOCATE(WORK, RWORK, STAT=ISTAT1); LWORK = MAX(1,3*N)
            ALLOCATE(WORK(LWORK), RWORK(N), STAT=ISTAT)
            IF( ISTAT /= 0 ) THEN; LINFO = - 100
            ELSE; CALL ERINFO( -200, SRNAME, LINFO ); ENDIF
         ENDIF
      END IF
      IF( ISTAT == 0 )THEN
!!        .. CALL LAPACK77 ROUTINE
         CALL SYSVX_F77( LFACT, LUPLO, N, NRHS, A, N, LAF, N, LPIV, B, N, X, N, &
                         LRCOND, LFERR, LBERR, WORK, LWORK, RWORK, LINFO )
      ELSE; LINFO = -100; END IF
      IF( .NOT.PRESENT(AF) ) DEALLOCATE( LAF, STAT=ISTAT1 )
      IF( .NOT.PRESENT(IPIV) ) DEALLOCATE( LPIV, STAT=ISTAT1 )
      IF( .NOT.PRESENT(FERR) ) DEALLOCATE( LFERR, STAT=ISTAT1 )
      IF( .NOT.PRESENT(BERR) ) DEALLOCATE( LBERR, STAT=ISTAT1 )
      IF( PRESENT(RCOND) ) RCOND=LRCOND
      DEALLOCATE( WORK, RWORK, STAT=ISTAT1 )
   END IF
   CALL ERINFO( LINFO, SRNAME, INFO, ISTAT )
END SUBROUTINE ZSYSVX_F95

SUBROUTINE ZUNGTR_F95( A, TAU, UPLO, INFO )
!
!!  -- LAPACK95 interface driver routine (version 3.0) --
!!     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
!!     September, 2000
!
!!  .. use STATEMENTS ..
   use KND_LA_PRECISION, ONLY: WP => DP                                      !!((05-B-KND_LA_PRECISION.f90))
   use LIB_LA_AUXMOD, ONLY: ERINFO, LSAME                                    !!((06-B-LIB_LA_AUXMOD.f90))
   use INT_LAPACK1, ONLY: UNGTR_F77 => LA_UNGTR, ILAENV_F77 => LA_ILAENV     !!((07-B-INT_LAPACK1.f90))
!!  .. IMPLICIT STATEMENT ..
   IMPLICIT NONE
!!  .. CHARACTER ARGUMENTS ..
   CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!  .. SCALAR ARGUMENTS ..
   INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!  .. ARRAY ARGUMENTS ..
   COMPLEX(WP), INTENT(IN) :: TAU(:)
   COMPLEX(WP), INTENT(INOUT) :: A(:,:)
!-----------------------------------------------------------------
!
!! Purpose
!! =======
!
!! LA_ORGTR / LA_UNGTR generates a real orthogonal / complex unitary
!! matrix Q which is defined as the product of elementary reflectors,
!! as returned by LA_SYTRD / LA_HETRD:
!!
!! if UPLO = "U", Q = H(n-1) . . . H(2) H(1),
!
!! if UPLO = "L", Q = H(1) H(2) . . . H(n-1).
!
!! =======
!
!!    SUBROUTINE LA_ORGTR / LA_UNGTR( A, TAU, UPLO, INFO )
!!    .. Scalar Arguments ..
!!       CHARACTER(LEN=1), INTENT(IN), OPTIONAL :: UPLO
!!       INTEGER, INTENT(OUT), OPTIONAL :: INFO
!!    .. Array Arguments ..
!!       <type>(<wp>), INTENT(IN) :: TAU(:)
!!       <type>(<wp>), INTENT(INOUT) :: A(:,:)
!!    where
!!       <type> ::= REAL | COMPLEX
!!       <wp>   ::= KIND(1.0) | KIND(1.0D0)
!
!! Defaults
!! ========
!
!! 1. If UPLO is not present then UPLO = "U" is assumed.
!
!! Arguments
!! =========
!
!! A       (input/output) either REAL or COMPLEX square array,
!!         shape (:,:), size(A,1) == size(A,2) >= 0.
!!         On entry, the vectors which define the elementary
!!            reflectors, as returned by LA_SYTRD or LA_HETRD.
!!         On exit the orthogonal or unitary matrix Q.
!
!! TAU     (input) either REAL or COMPLEX array,
!!         shape (:), size(TAU) == size(A,1)-1.
!!         TAU(i) must contain the scalar factor of the elementary
!!         reflector H(i), as returned by LA_SYTRD or LA_HETRD.
!
!! UPLO    Optional, (input) CHARACTER*1
!!         If UPLO is present then:
!!            = "U":  Upper triangle of A is stored
!!            = "L":  Lower triangle of A is stored
!!         otherwise UPLO = "U" is assumed.
!
!! INFO    Optional, (output) INTEGER
!!         If INFO is present:
!!            = 0: successful exit
!!            < 0: if INFO = -i, the i-th argument had an illegal value
!!         If INFO is not present and an error occurs, then the program
!!            is terminated with an error message.
!
!! ----------------------------------
!!  .. LOCAL PARAMETERS ..
   CHARACTER(LEN=8), PARAMETER :: SRNAME = "LA_UNGTR"
   CHARACTER(LEN=5), PARAMETER :: BSNAM  = "ZUNGQ"
!!  .. LOCAL SCALARS ..
   CHARACTER(LEN=1) :: LUPLO
   CHARACTER(LEN=6) :: BSNAME
   INTEGER :: LINFO, LWORK, NB, ISTAT, ISTAT1, N, LD
!!  .. LOCAL ARRAYS ..
   COMPLEX(WP), POINTER :: WORK(:)
!!  .. INTRINSIC FUNCTIONS ..
   INTRINSIC MAX, PRESENT, SIZE
!!  .. EXECUTABLE STATEMENTS ..
   LINFO = 0; N = SIZE(A,1); LD = MAX(1,N); ISTAT = 0
   IF( PRESENT(UPLO) ) THEN; LUPLO = UPLO; ELSE; LUPLO = "U"; END IF
!!  .. TEST THE ARGUMENTS
   IF( SIZE( A, 2 ) /= N .OR. N < 0 )THEN; LINFO = -1
   ELSE IF( SIZE( TAU ) /= N-1 )THEN; LINFO = -2
   ELSE IF( .NOT.LSAME(LUPLO,"U") .AND. .NOT.LSAME(LUPLO,"L") )THEN; LINFO = -3
   ELSE IF( N > 0 )THEN
!!     .. DETERMINE THE WORKSPACE
      IF( LSAME(LUPLO,"U") )THEN; BSNAME = BSNAM // "L"
      ELSE; BSNAME = BSNAM // "R"; ENDIF
      NB = ILAENV_F77( 1, BSNAME, " ", N-1, N-1, N-1, -1 )
      IF( NB < 1 .OR. NB >= N ) NB = 1
      LWORK = MAX( 1, (N-1)*NB ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
      IF( ISTAT /= 0 )THEN; DEALLOCATE(WORK, STAT=ISTAT)
         LWORK = MAX( 1, N-1 ); ALLOCATE(WORK(LWORK), STAT=ISTAT)
         IF( ISTAT == 0 ) CALL ERINFO( -200, SRNAME, LINFO )
      ENDIF
      IF( ISTAT == 0 )THEN
!!     .. CALL LAPACK77 ROUTINE
         CALL UNGTR_F77( LUPLO, N, A, LD, TAU, WORK, LWORK, LINFO )
      ELSE; LINFO = -100; ENDIF
      DEALLOCATE(WORK, STAT=ISTAT1)
   ENDIF
   CALL ERINFO(LINFO, SRNAME, INFO, ISTAT)
END SUBROUTINE ZUNGTR_F95

      END MODULE INT_LAPACK2
