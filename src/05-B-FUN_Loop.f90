MODULE FUN_Loop
!!#### PURPOSE
!! Allows an Integer to be "looped" over a range from.
!
!!                 I = Loop( I , N )
!
!! Increments I from 1:N, and Loop( 0 , N ) = 1, always.


!!#### DEFAULT IMPLICIT
IMPLICIT NONE


!!#### DEFAULT ACCESS
PRIVATE

!!#### Loop PROCEDURE OVERLOADING
INTERFACE Loop
 MODULE PROCEDURE Loop_I1
 MODULE PROCEDURE Loop_I2
 MODULE PROCEDURE Loop_I4
 MODULE PROCEDURE Loop_I8
END INTERFACE

!!#### ACCESS
PUBLIC :: Loop

CONTAINS

FUNCTION Loop_I1( I , N , COUNTER ) RESULT(J)
USE KND_IntrinsicTypes,ONLY: KIND_I=>KIND_I1 !!((01-A-KND_IntrinsicTypes.f90))
INTEGER(KIND_I),INTENT(IN) :: I,N
INTEGER(KIND_I),OPTIONAL,INTENT(INOUT) :: COUNTER
INTEGER(KIND_I) :: J
J = MOD(I,N)+1_KIND_I
IF( PRESENT(COUNTER) )COUNTER = COUNTER + 1
END FUNCTION

FUNCTION Loop_I2( I , N , COUNTER ) RESULT(J)
USE KND_IntrinsicTypes,ONLY: KIND_I=>KIND_I2 !!((01-A-KND_IntrinsicTypes.f90))
INTEGER(KIND_I),INTENT(IN) :: I,N
INTEGER(KIND_I),OPTIONAL,INTENT(INOUT) :: COUNTER
INTEGER(KIND_I) :: J
J = MOD(I,N)+1_KIND_I
IF( PRESENT(COUNTER) )COUNTER = COUNTER + 1
END FUNCTION

FUNCTION Loop_I4( I , N , COUNTER ) RESULT(J)
USE KND_IntrinsicTypes,ONLY: KIND_I=>KIND_I4 !!((01-A-KND_IntrinsicTypes.f90))
INTEGER(KIND_I),INTENT(IN) :: I,N
INTEGER(KIND_I),OPTIONAL,INTENT(INOUT) :: COUNTER
INTEGER(KIND_I) :: J
J = MOD(I,N)+1_KIND_I
IF( PRESENT(COUNTER) )COUNTER = COUNTER + 1
END FUNCTION

FUNCTION Loop_I8( I , N , COUNTER ) RESULT(J)
USE KND_IntrinsicTypes,ONLY: KIND_I=>KIND_I8 !!((01-A-KND_IntrinsicTypes.f90))
INTEGER(KIND_I),INTENT(IN) :: I,N
INTEGER(KIND_I),OPTIONAL,INTENT(INOUT) :: COUNTER
INTEGER(KIND_I) :: J
J = MOD(I,N)+1_KIND_I
IF( PRESENT(COUNTER) )COUNTER = COUNTER + 1
END FUNCTION

END MODULE
